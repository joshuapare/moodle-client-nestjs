/**
 * Moodle Webservice API
 * Auto-generated OpenAPI spec for Moodle\'s Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable } from 'rxjs';
import { CoreCalendarDeleteSubscription200Response } from '../model/core-calendar-delete-subscription-200-response';
import { ErrorResponse } from '../model/error-response';
import { ModChatGetChatsByCoursesRequest } from '../model/mod-chat-get-chats-by-courses-request';
import { ModLtiCreateToolProxy200Response } from '../model/mod-lti-create-tool-proxy-200-response';
import { ModLtiCreateToolProxyRequest } from '../model/mod-lti-create-tool-proxy-request';
import { ModLtiCreateToolType200Response } from '../model/mod-lti-create-tool-type-200-response';
import { ModLtiCreateToolTypeRequest } from '../model/mod-lti-create-tool-type-request';
import { ModLtiDeleteCourseToolTypeRequest } from '../model/mod-lti-delete-course-tool-type-request';
import { ModLtiDeleteToolProxy200Response } from '../model/mod-lti-delete-tool-proxy-200-response';
import { ModLtiDeleteToolProxyRequest } from '../model/mod-lti-delete-tool-proxy-request';
import { ModLtiDeleteToolTypeRequest } from '../model/mod-lti-delete-tool-type-request';
import { ModLtiGetLtisByCourses200Response } from '../model/mod-lti-get-ltis-by-courses-200-response';
import { ModLtiGetToolLaunchData200Response } from '../model/mod-lti-get-tool-launch-data-200-response';
import { ModLtiGetToolLaunchDataRequest } from '../model/mod-lti-get-tool-launch-data-request';
import { ModLtiGetToolProxiesRequest } from '../model/mod-lti-get-tool-proxies-request';
import { ModLtiGetToolProxyRegistrationRequest200Response } from '../model/mod-lti-get-tool-proxy-registration-request-200-response';
import { ModLtiGetToolTypesAndProxies200Response } from '../model/mod-lti-get-tool-types-and-proxies-200-response';
import { ModLtiGetToolTypesAndProxiesCount200Response } from '../model/mod-lti-get-tool-types-and-proxies-count-200-response';
import { ModLtiGetToolTypesAndProxiesCountRequest } from '../model/mod-lti-get-tool-types-and-proxies-count-request';
import { ModLtiGetToolTypesAndProxiesRequest } from '../model/mod-lti-get-tool-types-and-proxies-request';
import { ModLtiGetToolTypesRequest } from '../model/mod-lti-get-tool-types-request';
import { ModLtiIsCartridge200Response } from '../model/mod-lti-is-cartridge-200-response';
import { ModLtiIsCartridgeRequest } from '../model/mod-lti-is-cartridge-request';
import { ModLtiToggleShowinactivitychooserRequest } from '../model/mod-lti-toggle-showinactivitychooser-request';
import { ModLtiUpdateToolType200Response } from '../model/mod-lti-update-tool-type-200-response';
import { ModLtiUpdateToolTypeRequest } from '../model/mod-lti-update-tool-type-request';
import { ModLtiViewLtiRequest } from '../model/mod-lti-view-lti-request';
import { Configuration } from '../configuration';


@Injectable()
export class ModLtiService {

    protected basePath = 'https://localhost/webservice/restful/server.php';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Create a tool proxy
     * Create a tool proxy
     * @param modLtiCreateToolProxyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiCreateToolProxy(modLtiCreateToolProxyRequest: ModLtiCreateToolProxyRequest, ): Observable<AxiosResponse<ModLtiCreateToolProxy200Response>>;
    public modLtiCreateToolProxy(modLtiCreateToolProxyRequest: ModLtiCreateToolProxyRequest, ): Observable<any> {

        if (modLtiCreateToolProxyRequest === null || modLtiCreateToolProxyRequest === undefined) {
            throw new Error('Required parameter modLtiCreateToolProxyRequest was null or undefined when calling modLtiCreateToolProxy.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiCreateToolProxy200Response>(`${this.basePath}/mod_lti_create_tool_proxy`,
            modLtiCreateToolProxyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create a tool type
     * Create a tool type
     * @param modLtiCreateToolTypeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiCreateToolType(modLtiCreateToolTypeRequest: ModLtiCreateToolTypeRequest, ): Observable<AxiosResponse<ModLtiCreateToolType200Response>>;
    public modLtiCreateToolType(modLtiCreateToolTypeRequest: ModLtiCreateToolTypeRequest, ): Observable<any> {

        if (modLtiCreateToolTypeRequest === null || modLtiCreateToolTypeRequest === undefined) {
            throw new Error('Required parameter modLtiCreateToolTypeRequest was null or undefined when calling modLtiCreateToolType.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiCreateToolType200Response>(`${this.basePath}/mod_lti_create_tool_type`,
            modLtiCreateToolTypeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a course tool type
     * Delete a course tool type
     * @param modLtiDeleteCourseToolTypeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiDeleteCourseToolType(modLtiDeleteCourseToolTypeRequest: ModLtiDeleteCourseToolTypeRequest, ): Observable<AxiosResponse<object>>;
    public modLtiDeleteCourseToolType(modLtiDeleteCourseToolTypeRequest: ModLtiDeleteCourseToolTypeRequest, ): Observable<any> {

        if (modLtiDeleteCourseToolTypeRequest === null || modLtiDeleteCourseToolTypeRequest === undefined) {
            throw new Error('Required parameter modLtiDeleteCourseToolTypeRequest was null or undefined when calling modLtiDeleteCourseToolType.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/mod_lti_delete_course_tool_type`,
            modLtiDeleteCourseToolTypeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a tool proxy
     * Delete a tool proxy
     * @param modLtiDeleteToolProxyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiDeleteToolProxy(modLtiDeleteToolProxyRequest: ModLtiDeleteToolProxyRequest, ): Observable<AxiosResponse<ModLtiDeleteToolProxy200Response>>;
    public modLtiDeleteToolProxy(modLtiDeleteToolProxyRequest: ModLtiDeleteToolProxyRequest, ): Observable<any> {

        if (modLtiDeleteToolProxyRequest === null || modLtiDeleteToolProxyRequest === undefined) {
            throw new Error('Required parameter modLtiDeleteToolProxyRequest was null or undefined when calling modLtiDeleteToolProxy.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiDeleteToolProxy200Response>(`${this.basePath}/mod_lti_delete_tool_proxy`,
            modLtiDeleteToolProxyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a tool type
     * Delete a tool type
     * @param modLtiDeleteToolTypeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiDeleteToolType(modLtiDeleteToolTypeRequest: ModLtiDeleteToolTypeRequest, ): Observable<AxiosResponse<ModLtiDeleteToolTypeRequest>>;
    public modLtiDeleteToolType(modLtiDeleteToolTypeRequest: ModLtiDeleteToolTypeRequest, ): Observable<any> {

        if (modLtiDeleteToolTypeRequest === null || modLtiDeleteToolTypeRequest === undefined) {
            throw new Error('Required parameter modLtiDeleteToolTypeRequest was null or undefined when calling modLtiDeleteToolType.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiDeleteToolTypeRequest>(`${this.basePath}/mod_lti_delete_tool_type`,
            modLtiDeleteToolTypeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns a list of external tool instances in a provided set of courses, if                             no courses are provided then all the external tool instances the user has access to will be returned.
     * Returns a list of external tool instances in a provided set of courses, if                             no courses are provided then all the external tool instances the user has access to will be returned.
     * @param modChatGetChatsByCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetLtisByCourses(modChatGetChatsByCoursesRequest: ModChatGetChatsByCoursesRequest, ): Observable<AxiosResponse<ModLtiGetLtisByCourses200Response>>;
    public modLtiGetLtisByCourses(modChatGetChatsByCoursesRequest: ModChatGetChatsByCoursesRequest, ): Observable<any> {

        if (modChatGetChatsByCoursesRequest === null || modChatGetChatsByCoursesRequest === undefined) {
            throw new Error('Required parameter modChatGetChatsByCoursesRequest was null or undefined when calling modLtiGetLtisByCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiGetLtisByCourses200Response>(`${this.basePath}/mod_lti_get_ltis_by_courses`,
            modChatGetChatsByCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return the launch data for a given external tool.
     * Return the launch data for a given external tool.
     * @param modLtiGetToolLaunchDataRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolLaunchData(modLtiGetToolLaunchDataRequest: ModLtiGetToolLaunchDataRequest, ): Observable<AxiosResponse<ModLtiGetToolLaunchData200Response>>;
    public modLtiGetToolLaunchData(modLtiGetToolLaunchDataRequest: ModLtiGetToolLaunchDataRequest, ): Observable<any> {

        if (modLtiGetToolLaunchDataRequest === null || modLtiGetToolLaunchDataRequest === undefined) {
            throw new Error('Required parameter modLtiGetToolLaunchDataRequest was null or undefined when calling modLtiGetToolLaunchData.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiGetToolLaunchData200Response>(`${this.basePath}/mod_lti_get_tool_launch_data`,
            modLtiGetToolLaunchDataRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get a list of the tool proxies
     * Get a list of the tool proxies
     * @param modLtiGetToolProxiesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolProxies(modLtiGetToolProxiesRequest: ModLtiGetToolProxiesRequest, ): Observable<AxiosResponse<object>>;
    public modLtiGetToolProxies(modLtiGetToolProxiesRequest: ModLtiGetToolProxiesRequest, ): Observable<any> {

        if (modLtiGetToolProxiesRequest === null || modLtiGetToolProxiesRequest === undefined) {
            throw new Error('Required parameter modLtiGetToolProxiesRequest was null or undefined when calling modLtiGetToolProxies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/mod_lti_get_tool_proxies`,
            modLtiGetToolProxiesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get a registration request for a tool proxy
     * Get a registration request for a tool proxy
     * @param modLtiDeleteToolProxyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolProxyRegistrationRequest(modLtiDeleteToolProxyRequest: ModLtiDeleteToolProxyRequest, ): Observable<AxiosResponse<ModLtiGetToolProxyRegistrationRequest200Response>>;
    public modLtiGetToolProxyRegistrationRequest(modLtiDeleteToolProxyRequest: ModLtiDeleteToolProxyRequest, ): Observable<any> {

        if (modLtiDeleteToolProxyRequest === null || modLtiDeleteToolProxyRequest === undefined) {
            throw new Error('Required parameter modLtiDeleteToolProxyRequest was null or undefined when calling modLtiGetToolProxyRegistrationRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiGetToolProxyRegistrationRequest200Response>(`${this.basePath}/mod_lti_get_tool_proxy_registration_request`,
            modLtiDeleteToolProxyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get a list of the tool types
     * Get a list of the tool types
     * @param modLtiGetToolTypesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolTypes(modLtiGetToolTypesRequest: ModLtiGetToolTypesRequest, ): Observable<AxiosResponse<object>>;
    public modLtiGetToolTypes(modLtiGetToolTypesRequest: ModLtiGetToolTypesRequest, ): Observable<any> {

        if (modLtiGetToolTypesRequest === null || modLtiGetToolTypesRequest === undefined) {
            throw new Error('Required parameter modLtiGetToolTypesRequest was null or undefined when calling modLtiGetToolTypes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/mod_lti_get_tool_types`,
            modLtiGetToolTypesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get a list of the tool types and tool proxies
     * Get a list of the tool types and tool proxies
     * @param modLtiGetToolTypesAndProxiesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolTypesAndProxies(modLtiGetToolTypesAndProxiesRequest: ModLtiGetToolTypesAndProxiesRequest, ): Observable<AxiosResponse<ModLtiGetToolTypesAndProxies200Response>>;
    public modLtiGetToolTypesAndProxies(modLtiGetToolTypesAndProxiesRequest: ModLtiGetToolTypesAndProxiesRequest, ): Observable<any> {

        if (modLtiGetToolTypesAndProxiesRequest === null || modLtiGetToolTypesAndProxiesRequest === undefined) {
            throw new Error('Required parameter modLtiGetToolTypesAndProxiesRequest was null or undefined when calling modLtiGetToolTypesAndProxies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiGetToolTypesAndProxies200Response>(`${this.basePath}/mod_lti_get_tool_types_and_proxies`,
            modLtiGetToolTypesAndProxiesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get total number of the tool types and tool proxies
     * Get total number of the tool types and tool proxies
     * @param modLtiGetToolTypesAndProxiesCountRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiGetToolTypesAndProxiesCount(modLtiGetToolTypesAndProxiesCountRequest: ModLtiGetToolTypesAndProxiesCountRequest, ): Observable<AxiosResponse<ModLtiGetToolTypesAndProxiesCount200Response>>;
    public modLtiGetToolTypesAndProxiesCount(modLtiGetToolTypesAndProxiesCountRequest: ModLtiGetToolTypesAndProxiesCountRequest, ): Observable<any> {

        if (modLtiGetToolTypesAndProxiesCountRequest === null || modLtiGetToolTypesAndProxiesCountRequest === undefined) {
            throw new Error('Required parameter modLtiGetToolTypesAndProxiesCountRequest was null or undefined when calling modLtiGetToolTypesAndProxiesCount.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiGetToolTypesAndProxiesCount200Response>(`${this.basePath}/mod_lti_get_tool_types_and_proxies_count`,
            modLtiGetToolTypesAndProxiesCountRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Determine if the given url is for a cartridge
     * Determine if the given url is for a cartridge
     * @param modLtiIsCartridgeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiIsCartridge(modLtiIsCartridgeRequest: ModLtiIsCartridgeRequest, ): Observable<AxiosResponse<ModLtiIsCartridge200Response>>;
    public modLtiIsCartridge(modLtiIsCartridgeRequest: ModLtiIsCartridgeRequest, ): Observable<any> {

        if (modLtiIsCartridgeRequest === null || modLtiIsCartridgeRequest === undefined) {
            throw new Error('Required parameter modLtiIsCartridgeRequest was null or undefined when calling modLtiIsCartridge.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiIsCartridge200Response>(`${this.basePath}/mod_lti_is_cartridge`,
            modLtiIsCartridgeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Toggle showinactivitychooser for a tool type in a course
     * Toggle showinactivitychooser for a tool type in a course
     * @param modLtiToggleShowinactivitychooserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiToggleShowinactivitychooser(modLtiToggleShowinactivitychooserRequest: ModLtiToggleShowinactivitychooserRequest, ): Observable<AxiosResponse<object>>;
    public modLtiToggleShowinactivitychooser(modLtiToggleShowinactivitychooserRequest: ModLtiToggleShowinactivitychooserRequest, ): Observable<any> {

        if (modLtiToggleShowinactivitychooserRequest === null || modLtiToggleShowinactivitychooserRequest === undefined) {
            throw new Error('Required parameter modLtiToggleShowinactivitychooserRequest was null or undefined when calling modLtiToggleShowinactivitychooser.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/mod_lti_toggle_showinactivitychooser`,
            modLtiToggleShowinactivitychooserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a tool type
     * Update a tool type
     * @param modLtiUpdateToolTypeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiUpdateToolType(modLtiUpdateToolTypeRequest: ModLtiUpdateToolTypeRequest, ): Observable<AxiosResponse<ModLtiUpdateToolType200Response>>;
    public modLtiUpdateToolType(modLtiUpdateToolTypeRequest: ModLtiUpdateToolTypeRequest, ): Observable<any> {

        if (modLtiUpdateToolTypeRequest === null || modLtiUpdateToolTypeRequest === undefined) {
            throw new Error('Required parameter modLtiUpdateToolTypeRequest was null or undefined when calling modLtiUpdateToolType.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ModLtiUpdateToolType200Response>(`${this.basePath}/mod_lti_update_tool_type`,
            modLtiUpdateToolTypeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Trigger the course module viewed event and update the module completion status.
     * Trigger the course module viewed event and update the module completion status.
     * @param modLtiViewLtiRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modLtiViewLti(modLtiViewLtiRequest: ModLtiViewLtiRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public modLtiViewLti(modLtiViewLtiRequest: ModLtiViewLtiRequest, ): Observable<any> {

        if (modLtiViewLtiRequest === null || modLtiViewLtiRequest === undefined) {
            throw new Error('Required parameter modLtiViewLtiRequest was null or undefined when calling modLtiViewLti.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/mod_lti_view_lti`,
            modLtiViewLtiRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
}
