/**
 * Moodle Webservice API
 * Auto-generated OpenAPI spec for Moodle\'s Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable } from 'rxjs';
import { CoreCompetencyCompetencyViewedRequest } from '../model/core-competency-competency-viewed-request';
import { CoreCompetencyCompletePlanRequest } from '../model/core-competency-complete-plan-request';
import { ErrorResponse } from '../model/error-response';
import { ToolLpDataForCompetenciesManagePage200Response } from '../model/tool-lp-data-for-competencies-manage-page-200-response';
import { ToolLpDataForCompetenciesManagePageRequest } from '../model/tool-lp-data-for-competencies-manage-page-request';
import { ToolLpDataForCompetencyFrameworksManagePage200Response } from '../model/tool-lp-data-for-competency-frameworks-manage-page-200-response';
import { ToolLpDataForCompetencyFrameworksManagePageRequest } from '../model/tool-lp-data-for-competency-frameworks-manage-page-request';
import { ToolLpDataForCompetencySummary200Response } from '../model/tool-lp-data-for-competency-summary-200-response';
import { ToolLpDataForCompetencySummaryRequest } from '../model/tool-lp-data-for-competency-summary-request';
import { ToolLpDataForCourseCompetenciesPage200Response } from '../model/tool-lp-data-for-course-competencies-page-200-response';
import { ToolLpDataForCourseCompetenciesPageRequest } from '../model/tool-lp-data-for-course-competencies-page-request';
import { ToolLpDataForPlanPage200Response } from '../model/tool-lp-data-for-plan-page-200-response';
import { ToolLpDataForPlansPage200Response } from '../model/tool-lp-data-for-plans-page-200-response';
import { ToolLpDataForPlansPageRequest } from '../model/tool-lp-data-for-plans-page-request';
import { ToolLpDataForRelatedCompetenciesSection200Response } from '../model/tool-lp-data-for-related-competencies-section-200-response';
import { ToolLpDataForRelatedCompetenciesSectionRequest } from '../model/tool-lp-data-for-related-competencies-section-request';
import { ToolLpDataForTemplateCompetenciesPage200Response } from '../model/tool-lp-data-for-template-competencies-page-200-response';
import { ToolLpDataForTemplateCompetenciesPageRequest } from '../model/tool-lp-data-for-template-competencies-page-request';
import { ToolLpDataForTemplatesManagePage200Response } from '../model/tool-lp-data-for-templates-manage-page-200-response';
import { ToolLpDataForUserCompetencySummary200Response } from '../model/tool-lp-data-for-user-competency-summary-200-response';
import { ToolLpDataForUserCompetencySummaryInCourse200Response } from '../model/tool-lp-data-for-user-competency-summary-in-course-200-response';
import { ToolLpDataForUserCompetencySummaryInCourseRequest } from '../model/tool-lp-data-for-user-competency-summary-in-course-request';
import { ToolLpDataForUserCompetencySummaryInPlan200Response } from '../model/tool-lp-data-for-user-competency-summary-in-plan-200-response';
import { ToolLpDataForUserCompetencySummaryInPlanRequest } from '../model/tool-lp-data-for-user-competency-summary-in-plan-request';
import { ToolLpDataForUserCompetencySummaryRequest } from '../model/tool-lp-data-for-user-competency-summary-request';
import { ToolLpDataForUserEvidenceListPage200Response } from '../model/tool-lp-data-for-user-evidence-list-page-200-response';
import { ToolLpDataForUserEvidenceListPageRequest } from '../model/tool-lp-data-for-user-evidence-list-page-request';
import { ToolLpDataForUserEvidencePage200Response } from '../model/tool-lp-data-for-user-evidence-page-200-response';
import { ToolLpDataForUserEvidencePageRequest } from '../model/tool-lp-data-for-user-evidence-page-request';
import { ToolLpSearchCohorts200Response } from '../model/tool-lp-search-cohorts-200-response';
import { ToolLpSearchCohortsRequest } from '../model/tool-lp-search-cohorts-request';
import { ToolLpSearchUsers200Response } from '../model/tool-lp-search-users-200-response';
import { ToolLpSearchUsersRequest } from '../model/tool-lp-search-users-request';
import { Configuration } from '../configuration';


@Injectable()
export class ToolLpService {

    protected basePath = 'https://localhost/webservice/restful/server.php';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Load the data for the competencies manage page template
     * Load the data for the competencies manage page template
     * @param toolLpDataForCompetenciesManagePageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForCompetenciesManagePage(toolLpDataForCompetenciesManagePageRequest: ToolLpDataForCompetenciesManagePageRequest, ): Observable<AxiosResponse<ToolLpDataForCompetenciesManagePage200Response>>;
    public toolLpDataForCompetenciesManagePage(toolLpDataForCompetenciesManagePageRequest: ToolLpDataForCompetenciesManagePageRequest, ): Observable<any> {

        if (toolLpDataForCompetenciesManagePageRequest === null || toolLpDataForCompetenciesManagePageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForCompetenciesManagePageRequest was null or undefined when calling toolLpDataForCompetenciesManagePage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForCompetenciesManagePage200Response>(`${this.basePath}/tool_lp_data_for_competencies_manage_page`,
            toolLpDataForCompetenciesManagePageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the competency frameworks manage page template
     * Load the data for the competency frameworks manage page template
     * @param toolLpDataForCompetencyFrameworksManagePageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForCompetencyFrameworksManagePage(toolLpDataForCompetencyFrameworksManagePageRequest: ToolLpDataForCompetencyFrameworksManagePageRequest, ): Observable<AxiosResponse<ToolLpDataForCompetencyFrameworksManagePage200Response>>;
    public toolLpDataForCompetencyFrameworksManagePage(toolLpDataForCompetencyFrameworksManagePageRequest: ToolLpDataForCompetencyFrameworksManagePageRequest, ): Observable<any> {

        if (toolLpDataForCompetencyFrameworksManagePageRequest === null || toolLpDataForCompetencyFrameworksManagePageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForCompetencyFrameworksManagePageRequest was null or undefined when calling toolLpDataForCompetencyFrameworksManagePage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForCompetencyFrameworksManagePage200Response>(`${this.basePath}/tool_lp_data_for_competency_frameworks_manage_page`,
            toolLpDataForCompetencyFrameworksManagePageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load competency data for summary template.
     * Load competency data for summary template.
     * @param toolLpDataForCompetencySummaryRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForCompetencySummary(toolLpDataForCompetencySummaryRequest: ToolLpDataForCompetencySummaryRequest, ): Observable<AxiosResponse<ToolLpDataForCompetencySummary200Response>>;
    public toolLpDataForCompetencySummary(toolLpDataForCompetencySummaryRequest: ToolLpDataForCompetencySummaryRequest, ): Observable<any> {

        if (toolLpDataForCompetencySummaryRequest === null || toolLpDataForCompetencySummaryRequest === undefined) {
            throw new Error('Required parameter toolLpDataForCompetencySummaryRequest was null or undefined when calling toolLpDataForCompetencySummary.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForCompetencySummary200Response>(`${this.basePath}/tool_lp_data_for_competency_summary`,
            toolLpDataForCompetencySummaryRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the course competencies page template.
     * Load the data for the course competencies page template.
     * @param toolLpDataForCourseCompetenciesPageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForCourseCompetenciesPage(toolLpDataForCourseCompetenciesPageRequest: ToolLpDataForCourseCompetenciesPageRequest, ): Observable<AxiosResponse<ToolLpDataForCourseCompetenciesPage200Response>>;
    public toolLpDataForCourseCompetenciesPage(toolLpDataForCourseCompetenciesPageRequest: ToolLpDataForCourseCompetenciesPageRequest, ): Observable<any> {

        if (toolLpDataForCourseCompetenciesPageRequest === null || toolLpDataForCourseCompetenciesPageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForCourseCompetenciesPageRequest was null or undefined when calling toolLpDataForCourseCompetenciesPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForCourseCompetenciesPage200Response>(`${this.basePath}/tool_lp_data_for_course_competencies_page`,
            toolLpDataForCourseCompetenciesPageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the plan page template.
     * Load the data for the plan page template.
     * @param coreCompetencyCompletePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForPlanPage(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<AxiosResponse<ToolLpDataForPlanPage200Response>>;
    public toolLpDataForPlanPage(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<any> {

        if (coreCompetencyCompletePlanRequest === null || coreCompetencyCompletePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompletePlanRequest was null or undefined when calling toolLpDataForPlanPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForPlanPage200Response>(`${this.basePath}/tool_lp_data_for_plan_page`,
            coreCompetencyCompletePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the plans page template
     * Load the data for the plans page template
     * @param toolLpDataForPlansPageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForPlansPage(toolLpDataForPlansPageRequest: ToolLpDataForPlansPageRequest, ): Observable<AxiosResponse<ToolLpDataForPlansPage200Response>>;
    public toolLpDataForPlansPage(toolLpDataForPlansPageRequest: ToolLpDataForPlansPageRequest, ): Observable<any> {

        if (toolLpDataForPlansPageRequest === null || toolLpDataForPlansPageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForPlansPageRequest was null or undefined when calling toolLpDataForPlansPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForPlansPage200Response>(`${this.basePath}/tool_lp_data_for_plans_page`,
            toolLpDataForPlansPageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the related competencies template.
     * Load the data for the related competencies template.
     * @param toolLpDataForRelatedCompetenciesSectionRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForRelatedCompetenciesSection(toolLpDataForRelatedCompetenciesSectionRequest: ToolLpDataForRelatedCompetenciesSectionRequest, ): Observable<AxiosResponse<ToolLpDataForRelatedCompetenciesSection200Response>>;
    public toolLpDataForRelatedCompetenciesSection(toolLpDataForRelatedCompetenciesSectionRequest: ToolLpDataForRelatedCompetenciesSectionRequest, ): Observable<any> {

        if (toolLpDataForRelatedCompetenciesSectionRequest === null || toolLpDataForRelatedCompetenciesSectionRequest === undefined) {
            throw new Error('Required parameter toolLpDataForRelatedCompetenciesSectionRequest was null or undefined when calling toolLpDataForRelatedCompetenciesSection.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForRelatedCompetenciesSection200Response>(`${this.basePath}/tool_lp_data_for_related_competencies_section`,
            toolLpDataForRelatedCompetenciesSectionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the template competencies page template.
     * Load the data for the template competencies page template.
     * @param toolLpDataForTemplateCompetenciesPageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForTemplateCompetenciesPage(toolLpDataForTemplateCompetenciesPageRequest: ToolLpDataForTemplateCompetenciesPageRequest, ): Observable<AxiosResponse<ToolLpDataForTemplateCompetenciesPage200Response>>;
    public toolLpDataForTemplateCompetenciesPage(toolLpDataForTemplateCompetenciesPageRequest: ToolLpDataForTemplateCompetenciesPageRequest, ): Observable<any> {

        if (toolLpDataForTemplateCompetenciesPageRequest === null || toolLpDataForTemplateCompetenciesPageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForTemplateCompetenciesPageRequest was null or undefined when calling toolLpDataForTemplateCompetenciesPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForTemplateCompetenciesPage200Response>(`${this.basePath}/tool_lp_data_for_template_competencies_page`,
            toolLpDataForTemplateCompetenciesPageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the learning plan templates manage page template
     * Load the data for the learning plan templates manage page template
     * @param toolLpDataForCompetencyFrameworksManagePageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForTemplatesManagePage(toolLpDataForCompetencyFrameworksManagePageRequest: ToolLpDataForCompetencyFrameworksManagePageRequest, ): Observable<AxiosResponse<ToolLpDataForTemplatesManagePage200Response>>;
    public toolLpDataForTemplatesManagePage(toolLpDataForCompetencyFrameworksManagePageRequest: ToolLpDataForCompetencyFrameworksManagePageRequest, ): Observable<any> {

        if (toolLpDataForCompetencyFrameworksManagePageRequest === null || toolLpDataForCompetencyFrameworksManagePageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForCompetencyFrameworksManagePageRequest was null or undefined when calling toolLpDataForTemplatesManagePage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForTemplatesManagePage200Response>(`${this.basePath}/tool_lp_data_for_templates_manage_page`,
            toolLpDataForCompetencyFrameworksManagePageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a user competency.
     * Load a summary of a user competency.
     * @param toolLpDataForUserCompetencySummaryRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForUserCompetencySummary(toolLpDataForUserCompetencySummaryRequest: ToolLpDataForUserCompetencySummaryRequest, ): Observable<AxiosResponse<ToolLpDataForUserCompetencySummary200Response>>;
    public toolLpDataForUserCompetencySummary(toolLpDataForUserCompetencySummaryRequest: ToolLpDataForUserCompetencySummaryRequest, ): Observable<any> {

        if (toolLpDataForUserCompetencySummaryRequest === null || toolLpDataForUserCompetencySummaryRequest === undefined) {
            throw new Error('Required parameter toolLpDataForUserCompetencySummaryRequest was null or undefined when calling toolLpDataForUserCompetencySummary.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForUserCompetencySummary200Response>(`${this.basePath}/tool_lp_data_for_user_competency_summary`,
            toolLpDataForUserCompetencySummaryRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a user competency.
     * Load a summary of a user competency.
     * @param toolLpDataForUserCompetencySummaryInCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForUserCompetencySummaryInCourse(toolLpDataForUserCompetencySummaryInCourseRequest: ToolLpDataForUserCompetencySummaryInCourseRequest, ): Observable<AxiosResponse<ToolLpDataForUserCompetencySummaryInCourse200Response>>;
    public toolLpDataForUserCompetencySummaryInCourse(toolLpDataForUserCompetencySummaryInCourseRequest: ToolLpDataForUserCompetencySummaryInCourseRequest, ): Observable<any> {

        if (toolLpDataForUserCompetencySummaryInCourseRequest === null || toolLpDataForUserCompetencySummaryInCourseRequest === undefined) {
            throw new Error('Required parameter toolLpDataForUserCompetencySummaryInCourseRequest was null or undefined when calling toolLpDataForUserCompetencySummaryInCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForUserCompetencySummaryInCourse200Response>(`${this.basePath}/tool_lp_data_for_user_competency_summary_in_course`,
            toolLpDataForUserCompetencySummaryInCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a user competency.
     * Load a summary of a user competency.
     * @param toolLpDataForUserCompetencySummaryInPlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForUserCompetencySummaryInPlan(toolLpDataForUserCompetencySummaryInPlanRequest: ToolLpDataForUserCompetencySummaryInPlanRequest, ): Observable<AxiosResponse<ToolLpDataForUserCompetencySummaryInPlan200Response>>;
    public toolLpDataForUserCompetencySummaryInPlan(toolLpDataForUserCompetencySummaryInPlanRequest: ToolLpDataForUserCompetencySummaryInPlanRequest, ): Observable<any> {

        if (toolLpDataForUserCompetencySummaryInPlanRequest === null || toolLpDataForUserCompetencySummaryInPlanRequest === undefined) {
            throw new Error('Required parameter toolLpDataForUserCompetencySummaryInPlanRequest was null or undefined when calling toolLpDataForUserCompetencySummaryInPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForUserCompetencySummaryInPlan200Response>(`${this.basePath}/tool_lp_data_for_user_competency_summary_in_plan`,
            toolLpDataForUserCompetencySummaryInPlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the user evidence list page template
     * Load the data for the user evidence list page template
     * @param toolLpDataForUserEvidenceListPageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForUserEvidenceListPage(toolLpDataForUserEvidenceListPageRequest: ToolLpDataForUserEvidenceListPageRequest, ): Observable<AxiosResponse<ToolLpDataForUserEvidenceListPage200Response>>;
    public toolLpDataForUserEvidenceListPage(toolLpDataForUserEvidenceListPageRequest: ToolLpDataForUserEvidenceListPageRequest, ): Observable<any> {

        if (toolLpDataForUserEvidenceListPageRequest === null || toolLpDataForUserEvidenceListPageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForUserEvidenceListPageRequest was null or undefined when calling toolLpDataForUserEvidenceListPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForUserEvidenceListPage200Response>(`${this.basePath}/tool_lp_data_for_user_evidence_list_page`,
            toolLpDataForUserEvidenceListPageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the data for the user evidence page template
     * Load the data for the user evidence page template
     * @param toolLpDataForUserEvidencePageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpDataForUserEvidencePage(toolLpDataForUserEvidencePageRequest: ToolLpDataForUserEvidencePageRequest, ): Observable<AxiosResponse<ToolLpDataForUserEvidencePage200Response>>;
    public toolLpDataForUserEvidencePage(toolLpDataForUserEvidencePageRequest: ToolLpDataForUserEvidencePageRequest, ): Observable<any> {

        if (toolLpDataForUserEvidencePageRequest === null || toolLpDataForUserEvidencePageRequest === undefined) {
            throw new Error('Required parameter toolLpDataForUserEvidencePageRequest was null or undefined when calling toolLpDataForUserEvidencePage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpDataForUserEvidencePage200Response>(`${this.basePath}/tool_lp_data_for_user_evidence_page`,
            toolLpDataForUserEvidencePageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the courses using a competency
     * List the courses using a competency
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpListCoursesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public toolLpListCoursesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling toolLpListCoursesUsingCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/tool_lp_list_courses_using_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search for cohorts. This method is deprecated, please call \&#39;core_cohort_search_cohorts\&#39; instead
     * Search for cohorts. This method is deprecated, please call \&#39;core_cohort_search_cohorts\&#39; instead
     * @param toolLpSearchCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpSearchCohorts(toolLpSearchCohortsRequest: ToolLpSearchCohortsRequest, ): Observable<AxiosResponse<ToolLpSearchCohorts200Response>>;
    public toolLpSearchCohorts(toolLpSearchCohortsRequest: ToolLpSearchCohortsRequest, ): Observable<any> {

        if (toolLpSearchCohortsRequest === null || toolLpSearchCohortsRequest === undefined) {
            throw new Error('Required parameter toolLpSearchCohortsRequest was null or undefined when calling toolLpSearchCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpSearchCohorts200Response>(`${this.basePath}/tool_lp_search_cohorts`,
            toolLpSearchCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search for users.
     * Search for users.
     * @param toolLpSearchUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolLpSearchUsers(toolLpSearchUsersRequest: ToolLpSearchUsersRequest, ): Observable<AxiosResponse<ToolLpSearchUsers200Response>>;
    public toolLpSearchUsers(toolLpSearchUsersRequest: ToolLpSearchUsersRequest, ): Observable<any> {

        if (toolLpSearchUsersRequest === null || toolLpSearchUsersRequest === undefined) {
            throw new Error('Required parameter toolLpSearchUsersRequest was null or undefined when calling toolLpSearchUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<ToolLpSearchUsers200Response>(`${this.basePath}/tool_lp_search_users`,
            toolLpSearchUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
}
