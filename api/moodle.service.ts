/**
 * Moodle Webservice API
 * Auto-generated OpenAPI spec for Moodle\'s Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable } from 'rxjs';
import { CoreAdminSetBlockProtectionRequest } from '../model/core-admin-set-block-protection-request';
import { CoreAdminSetPluginOrderRequest } from '../model/core-admin-set-plugin-order-request';
import { CoreAdminSetPluginStateRequest } from '../model/core-admin-set-plugin-state-request';
import { CoreAuthConfirmUser200Response } from '../model/core-auth-confirm-user-200-response';
import { CoreAuthConfirmUserRequest } from '../model/core-auth-confirm-user-request';
import { CoreAuthIsAgeDigitalConsentVerificationEnabled200Response } from '../model/core-auth-is-age-digital-consent-verification-enabled-200-response';
import { CoreAuthIsMinor200Response } from '../model/core-auth-is-minor-200-response';
import { CoreAuthIsMinorRequest } from '../model/core-auth-is-minor-request';
import { CoreAuthRequestPasswordReset200Response } from '../model/core-auth-request-password-reset-200-response';
import { CoreAuthRequestPasswordResetRequest } from '../model/core-auth-request-password-reset-request';
import { CoreAuthResendConfirmationEmail200Response } from '../model/core-auth-resend-confirmation-email-200-response';
import { CoreAuthResendConfirmationEmailRequest } from '../model/core-auth-resend-confirmation-email-request';
import { CoreBackupGetAsyncBackupLinksBackup200Response } from '../model/core-backup-get-async-backup-links-backup-200-response';
import { CoreBackupGetAsyncBackupLinksBackupRequest } from '../model/core-backup-get-async-backup-links-backup-request';
import { CoreBackupGetAsyncBackupLinksRestore200Response } from '../model/core-backup-get-async-backup-links-restore-200-response';
import { CoreBackupGetAsyncBackupLinksRestoreRequest } from '../model/core-backup-get-async-backup-links-restore-request';
import { CoreBackupGetAsyncBackupProgressRequest } from '../model/core-backup-get-async-backup-progress-request';
import { CoreBackupGetCopyProgressRequest } from '../model/core-backup-get-copy-progress-request';
import { CoreBackupSubmitCopyFormRequest } from '../model/core-backup-submit-copy-form-request';
import { CoreBadgesGetUserBadgeByHash200Response } from '../model/core-badges-get-user-badge-by-hash-200-response';
import { CoreBadgesGetUserBadgeByHashRequest } from '../model/core-badges-get-user-badge-by-hash-request';
import { CoreBadgesGetUserBadges200Response } from '../model/core-badges-get-user-badges-200-response';
import { CoreBadgesGetUserBadgesRequest } from '../model/core-badges-get-user-badges-request';
import { CoreBlockFetchAddableBlocksRequest } from '../model/core-block-fetch-addable-blocks-request';
import { CoreBlockGetCourseBlocks200Response } from '../model/core-block-get-course-blocks-200-response';
import { CoreBlockGetCourseBlocksRequest } from '../model/core-block-get-course-blocks-request';
import { CoreBlockGetDashboardBlocks200Response } from '../model/core-block-get-dashboard-blocks-200-response';
import { CoreBlockGetDashboardBlocksRequest } from '../model/core-block-get-dashboard-blocks-request';
import { CoreBlogGetEntries200Response } from '../model/core-blog-get-entries-200-response';
import { CoreBlogGetEntriesRequest } from '../model/core-blog-get-entries-request';
import { CoreBlogViewEntries200Response } from '../model/core-blog-view-entries-200-response';
import { CoreBlogViewEntriesRequest } from '../model/core-blog-view-entries-request';
import { CoreCalendarCreateCalendarEvents200Response } from '../model/core-calendar-create-calendar-events-200-response';
import { CoreCalendarCreateCalendarEventsRequest } from '../model/core-calendar-create-calendar-events-request';
import { CoreCalendarDeleteCalendarEventsRequest } from '../model/core-calendar-delete-calendar-events-request';
import { CoreCalendarDeleteSubscription200Response } from '../model/core-calendar-delete-subscription-200-response';
import { CoreCalendarDeleteSubscriptionRequest } from '../model/core-calendar-delete-subscription-request';
import { CoreCalendarGetActionEventsByCourse200Response } from '../model/core-calendar-get-action-events-by-course-200-response';
import { CoreCalendarGetActionEventsByCourseRequest } from '../model/core-calendar-get-action-events-by-course-request';
import { CoreCalendarGetActionEventsByCourses200Response } from '../model/core-calendar-get-action-events-by-courses-200-response';
import { CoreCalendarGetActionEventsByCoursesRequest } from '../model/core-calendar-get-action-events-by-courses-request';
import { CoreCalendarGetActionEventsByTimesort200Response } from '../model/core-calendar-get-action-events-by-timesort-200-response';
import { CoreCalendarGetActionEventsByTimesortRequest } from '../model/core-calendar-get-action-events-by-timesort-request';
import { CoreCalendarGetAllowedEventTypes200Response } from '../model/core-calendar-get-allowed-event-types-200-response';
import { CoreCalendarGetAllowedEventTypesRequest } from '../model/core-calendar-get-allowed-event-types-request';
import { CoreCalendarGetCalendarAccessInformation200Response } from '../model/core-calendar-get-calendar-access-information-200-response';
import { CoreCalendarGetCalendarAccessInformationRequest } from '../model/core-calendar-get-calendar-access-information-request';
import { CoreCalendarGetCalendarDayView200Response } from '../model/core-calendar-get-calendar-day-view-200-response';
import { CoreCalendarGetCalendarDayViewRequest } from '../model/core-calendar-get-calendar-day-view-request';
import { CoreCalendarGetCalendarEventById200Response } from '../model/core-calendar-get-calendar-event-by-id-200-response';
import { CoreCalendarGetCalendarEventByIdRequest } from '../model/core-calendar-get-calendar-event-by-id-request';
import { CoreCalendarGetCalendarEvents200Response } from '../model/core-calendar-get-calendar-events-200-response';
import { CoreCalendarGetCalendarEventsRequest } from '../model/core-calendar-get-calendar-events-request';
import { CoreCalendarGetCalendarExportToken200Response } from '../model/core-calendar-get-calendar-export-token-200-response';
import { CoreCalendarGetCalendarMonthlyView200Response } from '../model/core-calendar-get-calendar-monthly-view-200-response';
import { CoreCalendarGetCalendarMonthlyViewRequest } from '../model/core-calendar-get-calendar-monthly-view-request';
import { CoreCalendarGetCalendarUpcomingView200Response } from '../model/core-calendar-get-calendar-upcoming-view-200-response';
import { CoreCalendarGetCalendarUpcomingViewRequest } from '../model/core-calendar-get-calendar-upcoming-view-request';
import { CoreCalendarGetTimestamps200Response } from '../model/core-calendar-get-timestamps-200-response';
import { CoreCalendarGetTimestampsRequest } from '../model/core-calendar-get-timestamps-request';
import { CoreCalendarSubmitCreateUpdateForm200Response } from '../model/core-calendar-submit-create-update-form-200-response';
import { CoreCalendarSubmitCreateUpdateFormRequest } from '../model/core-calendar-submit-create-update-form-request';
import { CoreCalendarUpdateEventStartDay200Response } from '../model/core-calendar-update-event-start-day-200-response';
import { CoreCalendarUpdateEventStartDayRequest } from '../model/core-calendar-update-event-start-day-request';
import { CoreChangeEditmode200Response } from '../model/core-change-editmode-200-response';
import { CoreChangeEditmodeRequest } from '../model/core-change-editmode-request';
import { CoreCohortAddCohortMembers200Response } from '../model/core-cohort-add-cohort-members-200-response';
import { CoreCohortAddCohortMembersRequest } from '../model/core-cohort-add-cohort-members-request';
import { CoreCohortCreateCohortsRequest } from '../model/core-cohort-create-cohorts-request';
import { CoreCohortDeleteCohortMembersRequest } from '../model/core-cohort-delete-cohort-members-request';
import { CoreCohortDeleteCohortsRequest } from '../model/core-cohort-delete-cohorts-request';
import { CoreCohortGetCohortMembersRequest } from '../model/core-cohort-get-cohort-members-request';
import { CoreCohortGetCohortsRequest } from '../model/core-cohort-get-cohorts-request';
import { CoreCohortSearchCohorts200Response } from '../model/core-cohort-search-cohorts-200-response';
import { CoreCohortSearchCohortsRequest } from '../model/core-cohort-search-cohorts-request';
import { CoreCohortUpdateCohortsRequest } from '../model/core-cohort-update-cohorts-request';
import { CoreCommentAddCommentsRequest } from '../model/core-comment-add-comments-request';
import { CoreCommentDeleteCommentsRequest } from '../model/core-comment-delete-comments-request';
import { CoreCommentGetComments200Response } from '../model/core-comment-get-comments-200-response';
import { CoreCommentGetCommentsRequest } from '../model/core-comment-get-comments-request';
import { CoreCompetencyAddCompetencyToCourseRequest } from '../model/core-competency-add-competency-to-course-request';
import { CoreCompetencyAddCompetencyToPlanRequest } from '../model/core-competency-add-competency-to-plan-request';
import { CoreCompetencyAddCompetencyToTemplateRequest } from '../model/core-competency-add-competency-to-template-request';
import { CoreCompetencyAddRelatedCompetencyRequest } from '../model/core-competency-add-related-competency-request';
import { CoreCompetencyApprovePlanRequest } from '../model/core-competency-approve-plan-request';
import { CoreCompetencyCompetencyFrameworkViewedRequest } from '../model/core-competency-competency-framework-viewed-request';
import { CoreCompetencyCompetencyViewedRequest } from '../model/core-competency-competency-viewed-request';
import { CoreCompetencyCompletePlanRequest } from '../model/core-competency-complete-plan-request';
import { CoreCompetencyCountCompetenciesInCourseRequest } from '../model/core-competency-count-competencies-in-course-request';
import { CoreCompetencyCountCompetenciesInTemplateRequest } from '../model/core-competency-count-competencies-in-template-request';
import { CoreCompetencyCountCompetenciesRequest } from '../model/core-competency-count-competencies-request';
import { CoreCompetencyCountCompetencyFrameworksRequest } from '../model/core-competency-count-competency-frameworks-request';
import { CoreCompetencyCountCourseModuleCompetenciesRequest } from '../model/core-competency-count-course-module-competencies-request';
import { CoreCompetencyCreateCompetency200Response } from '../model/core-competency-create-competency-200-response';
import { CoreCompetencyCreateCompetencyFramework200Response } from '../model/core-competency-create-competency-framework-200-response';
import { CoreCompetencyCreateCompetencyFrameworkRequest } from '../model/core-competency-create-competency-framework-request';
import { CoreCompetencyCreateCompetencyRequest } from '../model/core-competency-create-competency-request';
import { CoreCompetencyCreatePlan200Response } from '../model/core-competency-create-plan-200-response';
import { CoreCompetencyCreatePlanRequest } from '../model/core-competency-create-plan-request';
import { CoreCompetencyCreateTemplate200Response } from '../model/core-competency-create-template-200-response';
import { CoreCompetencyCreateTemplateRequest } from '../model/core-competency-create-template-request';
import { CoreCompetencyCreateUserEvidenceCompetency200Response } from '../model/core-competency-create-user-evidence-competency-200-response';
import { CoreCompetencyCreateUserEvidenceCompetencyRequest } from '../model/core-competency-create-user-evidence-competency-request';
import { CoreCompetencyDeleteCompetencyFrameworkRequest } from '../model/core-competency-delete-competency-framework-request';
import { CoreCompetencyDeleteCompetencyRequest } from '../model/core-competency-delete-competency-request';
import { CoreCompetencyDeleteEvidenceRequest } from '../model/core-competency-delete-evidence-request';
import { CoreCompetencyDeletePlanRequest } from '../model/core-competency-delete-plan-request';
import { CoreCompetencyDeleteTemplateRequest } from '../model/core-competency-delete-template-request';
import { CoreCompetencyDeleteUserEvidenceCompetencyRequest } from '../model/core-competency-delete-user-evidence-competency-request';
import { CoreCompetencyDeleteUserEvidenceRequest } from '../model/core-competency-delete-user-evidence-request';
import { CoreCompetencyDuplicateCompetencyFramework200Response } from '../model/core-competency-duplicate-competency-framework-200-response';
import { CoreCompetencyDuplicateCompetencyFrameworkRequest } from '../model/core-competency-duplicate-competency-framework-request';
import { CoreCompetencyGetScaleValuesRequest } from '../model/core-competency-get-scale-values-request';
import { CoreCompetencyGradeCompetency200Response } from '../model/core-competency-grade-competency-200-response';
import { CoreCompetencyGradeCompetencyInCourse200Response } from '../model/core-competency-grade-competency-in-course-200-response';
import { CoreCompetencyGradeCompetencyInCourseRequest } from '../model/core-competency-grade-competency-in-course-request';
import { CoreCompetencyGradeCompetencyInPlanRequest } from '../model/core-competency-grade-competency-in-plan-request';
import { CoreCompetencyGradeCompetencyRequest } from '../model/core-competency-grade-competency-request';
import { CoreCompetencyListCompetenciesRequest } from '../model/core-competency-list-competencies-request';
import { CoreCompetencyListCompetencyFrameworksRequest } from '../model/core-competency-list-competency-frameworks-request';
import { CoreCompetencyListCourseModuleCompetenciesRequest } from '../model/core-competency-list-course-module-competencies-request';
import { CoreCompetencyListPlanCompetenciesRequest } from '../model/core-competency-list-plan-competencies-request';
import { CoreCompetencyListTemplatesRequest } from '../model/core-competency-list-templates-request';
import { CoreCompetencyListUserPlansRequest } from '../model/core-competency-list-user-plans-request';
import { CoreCompetencyPlanCancelReviewRequestRequest } from '../model/core-competency-plan-cancel-review-request-request';
import { CoreCompetencyReadCompetencyRequest } from '../model/core-competency-read-competency-request';
import { CoreCompetencyReadPlan200Response } from '../model/core-competency-read-plan-200-response';
import { CoreCompetencyReadPlanRequest } from '../model/core-competency-read-plan-request';
import { CoreCompetencyReadTemplateRequest } from '../model/core-competency-read-template-request';
import { CoreCompetencyReadUserEvidence200Response } from '../model/core-competency-read-user-evidence-200-response';
import { CoreCompetencyRemoveCompetencyFromCourseRequest } from '../model/core-competency-remove-competency-from-course-request';
import { CoreCompetencyRemoveCompetencyFromPlanRequest } from '../model/core-competency-remove-competency-from-plan-request';
import { CoreCompetencyRemoveCompetencyFromTemplateRequest } from '../model/core-competency-remove-competency-from-template-request';
import { CoreCompetencyRemoveRelatedCompetencyRequest } from '../model/core-competency-remove-related-competency-request';
import { CoreCompetencyReorderCourseCompetencyRequest } from '../model/core-competency-reorder-course-competency-request';
import { CoreCompetencyReorderPlanCompetencyRequest } from '../model/core-competency-reorder-plan-competency-request';
import { CoreCompetencyReorderTemplateCompetencyRequest } from '../model/core-competency-reorder-template-competency-request';
import { CoreCompetencySearchCompetenciesRequest } from '../model/core-competency-search-competencies-request';
import { CoreCompetencySetCourseCompetencyRuleoutcomeRequest } from '../model/core-competency-set-course-competency-ruleoutcome-request';
import { CoreCompetencySetParentCompetencyRequest } from '../model/core-competency-set-parent-competency-request';
import { CoreCompetencyUnlinkPlanFromTemplateRequest } from '../model/core-competency-unlink-plan-from-template-request';
import { CoreCompetencyUpdateCompetencyFrameworkRequest } from '../model/core-competency-update-competency-framework-request';
import { CoreCompetencyUpdateCompetencyRequest } from '../model/core-competency-update-competency-request';
import { CoreCompetencyUpdateCourseCompetencySettingsRequest } from '../model/core-competency-update-course-competency-settings-request';
import { CoreCompetencyUpdatePlanRequest } from '../model/core-competency-update-plan-request';
import { CoreCompetencyUpdateTemplateRequest } from '../model/core-competency-update-template-request';
import { CoreCompetencyUserCompetencyCancelReviewRequestRequest } from '../model/core-competency-user-competency-cancel-review-request-request';
import { CoreCompetencyUserCompetencyPlanViewedRequest } from '../model/core-competency-user-competency-plan-viewed-request';
import { CoreCompetencyUserCompetencyRequestReviewRequest } from '../model/core-competency-user-competency-request-review-request';
import { CoreCompetencyUserCompetencyViewedInCourseRequest } from '../model/core-competency-user-competency-viewed-in-course-request';
import { CoreCompetencyUserCompetencyViewedRequest } from '../model/core-competency-user-competency-viewed-request';
import { CoreCompletionGetActivitiesCompletionStatus200Response } from '../model/core-completion-get-activities-completion-status-200-response';
import { CoreCompletionGetActivitiesCompletionStatusRequest } from '../model/core-completion-get-activities-completion-status-request';
import { CoreCompletionGetCourseCompletionStatus200Response } from '../model/core-completion-get-course-completion-status-200-response';
import { CoreCompletionMarkCourseSelfCompleted200Response } from '../model/core-completion-mark-course-self-completed-200-response';
import { CoreCompletionMarkCourseSelfCompletedRequest } from '../model/core-completion-mark-course-self-completed-request';
import { CoreCompletionOverrideActivityCompletionStatus200Response } from '../model/core-completion-override-activity-completion-status-200-response';
import { CoreCompletionOverrideActivityCompletionStatusRequest } from '../model/core-completion-override-activity-completion-status-request';
import { CoreCompletionUpdateActivityCompletionStatusManually200Response } from '../model/core-completion-update-activity-completion-status-manually-200-response';
import { CoreCompletionUpdateActivityCompletionStatusManuallyRequest } from '../model/core-completion-update-activity-completion-status-manually-request';
import { CoreContentbankCopyContent200Response } from '../model/core-contentbank-copy-content-200-response';
import { CoreContentbankCopyContentRequest } from '../model/core-contentbank-copy-content-request';
import { CoreContentbankDeleteContent200Response } from '../model/core-contentbank-delete-content-200-response';
import { CoreContentbankDeleteContentRequest } from '../model/core-contentbank-delete-content-request';
import { CoreContentbankRenameContent200Response } from '../model/core-contentbank-rename-content-200-response';
import { CoreContentbankRenameContentRequest } from '../model/core-contentbank-rename-content-request';
import { CoreContentbankSetContentVisibilityRequest } from '../model/core-contentbank-set-content-visibility-request';
import { CoreCourseAddContentItemToUserFavourites200Response } from '../model/core-course-add-content-item-to-user-favourites-200-response';
import { CoreCourseAddContentItemToUserFavouritesRequest } from '../model/core-course-add-content-item-to-user-favourites-request';
import { CoreCourseCheckUpdates200Response } from '../model/core-course-check-updates-200-response';
import { CoreCourseCheckUpdatesRequest } from '../model/core-course-check-updates-request';
import { CoreCourseCreateCategoriesRequest } from '../model/core-course-create-categories-request';
import { CoreCourseCreateCoursesRequest } from '../model/core-course-create-courses-request';
import { CoreCourseDeleteCategoriesRequest } from '../model/core-course-delete-categories-request';
import { CoreCourseDeleteCoursesRequest } from '../model/core-course-delete-courses-request';
import { CoreCourseDeleteModulesRequest } from '../model/core-course-delete-modules-request';
import { CoreCourseDuplicateCourse200Response } from '../model/core-course-duplicate-course-200-response';
import { CoreCourseDuplicateCourseRequest } from '../model/core-course-duplicate-course-request';
import { CoreCourseEditModuleRequest } from '../model/core-course-edit-module-request';
import { CoreCourseEditSectionRequest } from '../model/core-course-edit-section-request';
import { CoreCourseGetActivityChooserFooter200Response } from '../model/core-course-get-activity-chooser-footer-200-response';
import { CoreCourseGetActivityChooserFooterRequest } from '../model/core-course-get-activity-chooser-footer-request';
import { CoreCourseGetCategoriesRequest } from '../model/core-course-get-categories-request';
import { CoreCourseGetContentsRequest } from '../model/core-course-get-contents-request';
import { CoreCourseGetCourseContentItems200Response } from '../model/core-course-get-course-content-items-200-response';
import { CoreCourseGetCourseContentItemsRequest } from '../model/core-course-get-course-content-items-request';
import { CoreCourseGetCourseModule200Response } from '../model/core-course-get-course-module-200-response';
import { CoreCourseGetCourseModuleByInstance200Response } from '../model/core-course-get-course-module-by-instance-200-response';
import { CoreCourseGetCourseModuleByInstanceRequest } from '../model/core-course-get-course-module-by-instance-request';
import { CoreCourseGetCoursesByField200Response } from '../model/core-course-get-courses-by-field-200-response';
import { CoreCourseGetCoursesByFieldRequest } from '../model/core-course-get-courses-by-field-request';
import { CoreCourseGetCoursesRequest } from '../model/core-course-get-courses-request';
import { CoreCourseGetEnrolledCoursesByTimelineClassification200Response } from '../model/core-course-get-enrolled-courses-by-timeline-classification-200-response';
import { CoreCourseGetEnrolledCoursesByTimelineClassificationRequest } from '../model/core-course-get-enrolled-courses-by-timeline-classification-request';
import { CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification200Response } from '../model/core-course-get-enrolled-courses-with-action-events-by-timeline-classification-200-response';
import { CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest } from '../model/core-course-get-enrolled-courses-with-action-events-by-timeline-classification-request';
import { CoreCourseGetEnrolledUsersByCmid200Response } from '../model/core-course-get-enrolled-users-by-cmid-200-response';
import { CoreCourseGetEnrolledUsersByCmidRequest } from '../model/core-course-get-enrolled-users-by-cmid-request';
import { CoreCourseGetModuleRequest } from '../model/core-course-get-module-request';
import { CoreCourseGetRecentCoursesRequest } from '../model/core-course-get-recent-courses-request';
import { CoreCourseGetUpdatesSince200Response } from '../model/core-course-get-updates-since-200-response';
import { CoreCourseGetUpdatesSinceRequest } from '../model/core-course-get-updates-since-request';
import { CoreCourseGetUserAdministrationOptions200Response } from '../model/core-course-get-user-administration-options-200-response';
import { CoreCourseGetUserAdministrationOptionsRequest } from '../model/core-course-get-user-administration-options-request';
import { CoreCourseGetUserNavigationOptions200Response } from '../model/core-course-get-user-navigation-options-200-response';
import { CoreCourseGetUserNavigationOptionsRequest } from '../model/core-course-get-user-navigation-options-request';
import { CoreCourseImportCourseRequest } from '../model/core-course-import-course-request';
import { CoreCourseRemoveContentItemFromUserFavouritesRequest } from '../model/core-course-remove-content-item-from-user-favourites-request';
import { CoreCourseSearchCourses200Response } from '../model/core-course-search-courses-200-response';
import { CoreCourseSearchCoursesRequest } from '../model/core-course-search-courses-request';
import { CoreCourseSetFavouriteCoursesRequest } from '../model/core-course-set-favourite-courses-request';
import { CoreCourseToggleActivityRecommendation200Response } from '../model/core-course-toggle-activity-recommendation-200-response';
import { CoreCourseToggleActivityRecommendationRequest } from '../model/core-course-toggle-activity-recommendation-request';
import { CoreCourseUpdateCategoriesRequest } from '../model/core-course-update-categories-request';
import { CoreCourseUpdateCoursesRequest } from '../model/core-course-update-courses-request';
import { CoreCourseViewCourseRequest } from '../model/core-course-view-course-request';
import { CoreCourseformatFileHandlersRequest } from '../model/core-courseformat-file-handlers-request';
import { CoreCourseformatUpdateCourseRequest } from '../model/core-courseformat-update-course-request';
import { CoreCreateUserfeedbackActionRecordRequest } from '../model/core-create-userfeedback-action-record-request';
import { CoreCustomfieldCreateCategoryRequest } from '../model/core-customfield-create-category-request';
import { CoreCustomfieldDeleteCategoryRequest } from '../model/core-customfield-delete-category-request';
import { CoreCustomfieldDeleteFieldRequest } from '../model/core-customfield-delete-field-request';
import { CoreCustomfieldMoveCategoryRequest } from '../model/core-customfield-move-category-request';
import { CoreCustomfieldMoveFieldRequest } from '../model/core-customfield-move-field-request';
import { CoreCustomfieldReloadTemplate200Response } from '../model/core-customfield-reload-template-200-response';
import { CoreCustomfieldReloadTemplateRequest } from '../model/core-customfield-reload-template-request';
import { CoreDynamicTabsGetContent200Response } from '../model/core-dynamic-tabs-get-content-200-response';
import { CoreDynamicTabsGetContentRequest } from '../model/core-dynamic-tabs-get-content-request';
import { CoreEnrolGetCourseEnrolmentMethodsRequest } from '../model/core-enrol-get-course-enrolment-methods-request';
import { CoreEnrolGetEnrolledUsersRequest } from '../model/core-enrol-get-enrolled-users-request';
import { CoreEnrolGetEnrolledUsersWithCapabilityRequest } from '../model/core-enrol-get-enrolled-users-with-capability-request';
import { CoreEnrolGetPotentialUsersRequest } from '../model/core-enrol-get-potential-users-request';
import { CoreEnrolGetUsersCoursesRequest } from '../model/core-enrol-get-users-courses-request';
import { CoreEnrolSearchUsersRequest } from '../model/core-enrol-search-users-request';
import { CoreEnrolSubmitUserEnrolmentForm200Response } from '../model/core-enrol-submit-user-enrolment-form-200-response';
import { CoreEnrolSubmitUserEnrolmentFormRequest } from '../model/core-enrol-submit-user-enrolment-form-request';
import { CoreEnrolUnenrolUserEnrolment200Response } from '../model/core-enrol-unenrol-user-enrolment-200-response';
import { CoreEnrolUnenrolUserEnrolmentRequest } from '../model/core-enrol-unenrol-user-enrolment-request';
import { CoreFetchNotificationsRequest } from '../model/core-fetch-notifications-request';
import { CoreFilesDeleteDraftFiles200Response } from '../model/core-files-delete-draft-files-200-response';
import { CoreFilesDeleteDraftFilesRequest } from '../model/core-files-delete-draft-files-request';
import { CoreFilesGetFiles200Response } from '../model/core-files-get-files-200-response';
import { CoreFilesGetFilesRequest } from '../model/core-files-get-files-request';
import { CoreFilesGetUnusedDraftItemid200Response } from '../model/core-files-get-unused-draft-itemid-200-response';
import { CoreFilesUpload200Response } from '../model/core-files-upload-200-response';
import { CoreFilesUploadRequest } from '../model/core-files-upload-request';
import { CoreFiltersGetAvailableInContext200Response } from '../model/core-filters-get-available-in-context-200-response';
import { CoreFiltersGetAvailableInContextRequest } from '../model/core-filters-get-available-in-context-request';
import { CoreFormDynamicForm200Response } from '../model/core-form-dynamic-form-200-response';
import { CoreFormDynamicFormRequest } from '../model/core-form-dynamic-form-request';
import { CoreFormGetFiletypesBrowserData200Response } from '../model/core-form-get-filetypes-browser-data-200-response';
import { CoreFormGetFiletypesBrowserDataRequest } from '../model/core-form-get-filetypes-browser-data-request';
import { CoreGetComponentStringsRequest } from '../model/core-get-component-strings-request';
import { CoreGetFragment200Response } from '../model/core-get-fragment-200-response';
import { CoreGetFragmentRequest } from '../model/core-get-fragment-request';
import { CoreGetStringRequest } from '../model/core-get-string-request';
import { CoreGetStringsRequest } from '../model/core-get-strings-request';
import { CoreGetUserDates200Response } from '../model/core-get-user-dates-200-response';
import { CoreGetUserDatesRequest } from '../model/core-get-user-dates-request';
import { CoreGradesCreateGradecategories200Response } from '../model/core-grades-create-gradecategories-200-response';
import { CoreGradesCreateGradecategoriesRequest } from '../model/core-grades-create-gradecategories-request';
import { CoreGradesGetEnrolledUsersForSearchWidget200Response } from '../model/core-grades-get-enrolled-users-for-search-widget-200-response';
import { CoreGradesGetEnrolledUsersForSearchWidgetRequest } from '../model/core-grades-get-enrolled-users-for-search-widget-request';
import { CoreGradesGetEnrolledUsersForSelector200Response } from '../model/core-grades-get-enrolled-users-for-selector-200-response';
import { CoreGradesGetEnrolledUsersForSelectorRequest } from '../model/core-grades-get-enrolled-users-for-selector-request';
import { CoreGradesGetFeedback200Response } from '../model/core-grades-get-feedback-200-response';
import { CoreGradesGetFeedbackRequest } from '../model/core-grades-get-feedback-request';
import { CoreGradesGetGradableUsers200Response } from '../model/core-grades-get-gradable-users-200-response';
import { CoreGradesGetGradableUsersRequest } from '../model/core-grades-get-gradable-users-request';
import { CoreGradesGetGradeitems200Response } from '../model/core-grades-get-gradeitems-200-response';
import { CoreGradesGetGroupsForSearchWidget200Response } from '../model/core-grades-get-groups-for-search-widget-200-response';
import { CoreGradesGetGroupsForSearchWidgetRequest } from '../model/core-grades-get-groups-for-search-widget-request';
import { CoreGradesGetGroupsForSelector200Response } from '../model/core-grades-get-groups-for-selector-200-response';
import { CoreGradesGraderGradingpanelPointFetch200Response } from '../model/core-grades-grader-gradingpanel-point-fetch-200-response';
import { CoreGradesGraderGradingpanelPointFetchRequest } from '../model/core-grades-grader-gradingpanel-point-fetch-request';
import { CoreGradesGraderGradingpanelPointStore200Response } from '../model/core-grades-grader-gradingpanel-point-store-200-response';
import { CoreGradesGraderGradingpanelPointStoreRequest } from '../model/core-grades-grader-gradingpanel-point-store-request';
import { CoreGradesGraderGradingpanelScaleFetch200Response } from '../model/core-grades-grader-gradingpanel-scale-fetch-200-response';
import { CoreGradesGraderGradingpanelScaleFetchRequest } from '../model/core-grades-grader-gradingpanel-scale-fetch-request';
import { CoreGradesGraderGradingpanelScaleStore200Response } from '../model/core-grades-grader-gradingpanel-scale-store-200-response';
import { CoreGradesGraderGradingpanelScaleStoreRequest } from '../model/core-grades-grader-gradingpanel-scale-store-request';
import { CoreGradesUpdateGradesRequest } from '../model/core-grades-update-grades-request';
import { CoreGradingGetDefinitions200Response } from '../model/core-grading-get-definitions-200-response';
import { CoreGradingGetDefinitionsRequest } from '../model/core-grading-get-definitions-request';
import { CoreGradingGetGradingformInstances200Response } from '../model/core-grading-get-gradingform-instances-200-response';
import { CoreGradingGetGradingformInstancesRequest } from '../model/core-grading-get-gradingform-instances-request';
import { CoreGradingSaveDefinitionsRequest } from '../model/core-grading-save-definitions-request';
import { CoreGroupAddGroupMembersRequest } from '../model/core-group-add-group-members-request';
import { CoreGroupAssignGroupingRequest } from '../model/core-group-assign-grouping-request';
import { CoreGroupCreateGroupingsRequest } from '../model/core-group-create-groupings-request';
import { CoreGroupCreateGroupsRequest } from '../model/core-group-create-groups-request';
import { CoreGroupDeleteGroupMembersRequest } from '../model/core-group-delete-group-members-request';
import { CoreGroupDeleteGroupingsRequest } from '../model/core-group-delete-groupings-request';
import { CoreGroupDeleteGroupsRequest } from '../model/core-group-delete-groups-request';
import { CoreGroupGetActivityAllowedGroups200Response } from '../model/core-group-get-activity-allowed-groups-200-response';
import { CoreGroupGetActivityAllowedGroupsRequest } from '../model/core-group-get-activity-allowed-groups-request';
import { CoreGroupGetActivityGroupmode200Response } from '../model/core-group-get-activity-groupmode-200-response';
import { CoreGroupGetActivityGroupmodeRequest } from '../model/core-group-get-activity-groupmode-request';
import { CoreGroupGetCourseGroupingsRequest } from '../model/core-group-get-course-groupings-request';
import { CoreGroupGetCourseUserGroups200Response } from '../model/core-group-get-course-user-groups-200-response';
import { CoreGroupGetCourseUserGroupsRequest } from '../model/core-group-get-course-user-groups-request';
import { CoreGroupGetGroupMembersRequest } from '../model/core-group-get-group-members-request';
import { CoreGroupGetGroupingsRequest } from '../model/core-group-get-groupings-request';
import { CoreGroupUnassignGroupingRequest } from '../model/core-group-unassign-grouping-request';
import { CoreGroupUpdateGroupingsRequest } from '../model/core-group-update-groupings-request';
import { CoreGroupUpdateGroupsRequest } from '../model/core-group-update-groups-request';
import { CoreH5pGetTrustedH5pFile200Response } from '../model/core-h5p-get-trusted-h5p-file-200-response';
import { CoreH5pGetTrustedH5pFileRequest } from '../model/core-h5p-get-trusted-h5p-file-request';
import { CoreMessageBlockUserRequest } from '../model/core-message-block-user-request';
import { CoreMessageConfirmContactRequestRequest } from '../model/core-message-confirm-contact-request-request';
import { CoreMessageCreateContactRequest200Response } from '../model/core-message-create-contact-request-200-response';
import { CoreMessageCreateContactRequestRequest } from '../model/core-message-create-contact-request-request';
import { CoreMessageDataForMessageareaSearchMessages200Response } from '../model/core-message-data-for-messagearea-search-messages-200-response';
import { CoreMessageDataForMessageareaSearchMessagesRequest } from '../model/core-message-data-for-messagearea-search-messages-request';
import { CoreMessageDeleteContactsRequest } from '../model/core-message-delete-contacts-request';
import { CoreMessageDeleteConversationsByIdRequest } from '../model/core-message-delete-conversations-by-id-request';
import { CoreMessageDeleteMessage200Response } from '../model/core-message-delete-message-200-response';
import { CoreMessageDeleteMessageForAllUsersRequest } from '../model/core-message-delete-message-for-all-users-request';
import { CoreMessageDeleteMessageRequest } from '../model/core-message-delete-message-request';
import { CoreMessageGetBlockedUsers200Response } from '../model/core-message-get-blocked-users-200-response';
import { CoreMessageGetBlockedUsersRequest } from '../model/core-message-get-blocked-users-request';
import { CoreMessageGetContactRequestsRequest } from '../model/core-message-get-contact-requests-request';
import { CoreMessageGetConversation200Response } from '../model/core-message-get-conversation-200-response';
import { CoreMessageGetConversationBetweenUsers200Response } from '../model/core-message-get-conversation-between-users-200-response';
import { CoreMessageGetConversationBetweenUsersRequest } from '../model/core-message-get-conversation-between-users-request';
import { CoreMessageGetConversationCounts200Response } from '../model/core-message-get-conversation-counts-200-response';
import { CoreMessageGetConversationCountsRequest } from '../model/core-message-get-conversation-counts-request';
import { CoreMessageGetConversationMembersRequest } from '../model/core-message-get-conversation-members-request';
import { CoreMessageGetConversationMessages200Response } from '../model/core-message-get-conversation-messages-200-response';
import { CoreMessageGetConversationMessagesRequest } from '../model/core-message-get-conversation-messages-request';
import { CoreMessageGetConversationRequest } from '../model/core-message-get-conversation-request';
import { CoreMessageGetConversations200Response } from '../model/core-message-get-conversations-200-response';
import { CoreMessageGetConversationsRequest } from '../model/core-message-get-conversations-request';
import { CoreMessageGetMemberInfoRequest } from '../model/core-message-get-member-info-request';
import { CoreMessageGetMessageProcessor200Response } from '../model/core-message-get-message-processor-200-response';
import { CoreMessageGetMessageProcessorRequest } from '../model/core-message-get-message-processor-request';
import { CoreMessageGetMessages200Response } from '../model/core-message-get-messages-200-response';
import { CoreMessageGetMessagesRequest } from '../model/core-message-get-messages-request';
import { CoreMessageGetReceivedContactRequestsCountRequest } from '../model/core-message-get-received-contact-requests-count-request';
import { CoreMessageGetSelfConversationRequest } from '../model/core-message-get-self-conversation-request';
import { CoreMessageGetUnreadConversationCounts200Response } from '../model/core-message-get-unread-conversation-counts-200-response';
import { CoreMessageGetUnreadConversationsCountRequest } from '../model/core-message-get-unread-conversations-count-request';
import { CoreMessageGetUnreadNotificationCountRequest } from '../model/core-message-get-unread-notification-count-request';
import { CoreMessageGetUserContactsRequest } from '../model/core-message-get-user-contacts-request';
import { CoreMessageGetUserMessagePreferences200Response } from '../model/core-message-get-user-message-preferences-200-response';
import { CoreMessageGetUserNotificationPreferences200Response } from '../model/core-message-get-user-notification-preferences-200-response';
import { CoreMessageMarkAllConversationMessagesAsReadRequest } from '../model/core-message-mark-all-conversation-messages-as-read-request';
import { CoreMessageMarkAllNotificationsAsReadRequest } from '../model/core-message-mark-all-notifications-as-read-request';
import { CoreMessageMarkMessageRead200Response } from '../model/core-message-mark-message-read-200-response';
import { CoreMessageMarkMessageReadRequest } from '../model/core-message-mark-message-read-request';
import { CoreMessageMarkNotificationRead200Response } from '../model/core-message-mark-notification-read-200-response';
import { CoreMessageMarkNotificationReadRequest } from '../model/core-message-mark-notification-read-request';
import { CoreMessageMessageProcessorConfigFormRequest } from '../model/core-message-message-processor-config-form-request';
import { CoreMessageMessageSearchUsers200Response } from '../model/core-message-message-search-users-200-response';
import { CoreMessageMessageSearchUsersRequest } from '../model/core-message-message-search-users-request';
import { CoreMessageMuteConversationsRequest } from '../model/core-message-mute-conversations-request';
import { CoreMessageSearchContactsRequest } from '../model/core-message-search-contacts-request';
import { CoreMessageSendInstantMessagesRequest } from '../model/core-message-send-instant-messages-request';
import { CoreMessageSendMessagesToConversationRequest } from '../model/core-message-send-messages-to-conversation-request';
import { CoreMessageSetFavouriteConversationsRequest } from '../model/core-message-set-favourite-conversations-request';
import { CoreMessageUnblockUserRequest } from '../model/core-message-unblock-user-request';
import { CoreMessageUnmuteConversationsRequest } from '../model/core-message-unmute-conversations-request';
import { CoreMoodlenetAuthCheck200Response } from '../model/core-moodlenet-auth-check-200-response';
import { CoreMoodlenetAuthCheckRequest } from '../model/core-moodlenet-auth-check-request';
import { CoreMoodlenetGetShareInfoActivity200Response } from '../model/core-moodlenet-get-share-info-activity-200-response';
import { CoreMoodlenetGetShareInfoActivityRequest } from '../model/core-moodlenet-get-share-info-activity-request';
import { CoreMoodlenetGetSharedCourseInfo200Response } from '../model/core-moodlenet-get-shared-course-info-200-response';
import { CoreMoodlenetGetSharedCourseInfoRequest } from '../model/core-moodlenet-get-shared-course-info-request';
import { CoreMoodlenetSendActivity200Response } from '../model/core-moodlenet-send-activity-200-response';
import { CoreMoodlenetSendActivityRequest } from '../model/core-moodlenet-send-activity-request';
import { CoreMoodlenetSendCourse200Response } from '../model/core-moodlenet-send-course-200-response';
import { CoreMoodlenetSendCourseRequest } from '../model/core-moodlenet-send-course-request';
import { CoreMyViewPageRequest } from '../model/core-my-view-page-request';
import { CoreNotesCreateNotesRequest } from '../model/core-notes-create-notes-request';
import { CoreNotesDeleteNotesRequest } from '../model/core-notes-delete-notes-request';
import { CoreNotesGetCourseNotes200Response } from '../model/core-notes-get-course-notes-200-response';
import { CoreNotesGetCourseNotesRequest } from '../model/core-notes-get-course-notes-request';
import { CoreNotesGetNotes200Response } from '../model/core-notes-get-notes-200-response';
import { CoreNotesGetNotesRequest } from '../model/core-notes-get-notes-request';
import { CoreNotesUpdateNotesRequest } from '../model/core-notes-update-notes-request';
import { CoreNotesViewNotesRequest } from '../model/core-notes-view-notes-request';
import { CoreOutputLoadFontawesomeIconSystemMapRequest } from '../model/core-output-load-fontawesome-icon-system-map-request';
import { CoreOutputLoadTemplateRequest } from '../model/core-output-load-template-request';
import { CoreOutputLoadTemplateWithDependencies200Response } from '../model/core-output-load-template-with-dependencies-200-response';
import { CoreOutputLoadTemplateWithDependenciesRequest } from '../model/core-output-load-template-with-dependencies-request';
import { CorePaymentGetAvailableGatewaysRequest } from '../model/core-payment-get-available-gateways-request';
import { CoreQuestionGetRandomQuestionSummaries200Response } from '../model/core-question-get-random-question-summaries-200-response';
import { CoreQuestionGetRandomQuestionSummariesRequest } from '../model/core-question-get-random-question-summaries-request';
import { CoreQuestionSubmitTagsForm200Response } from '../model/core-question-submit-tags-form-200-response';
import { CoreQuestionSubmitTagsFormRequest } from '../model/core-question-submit-tags-form-request';
import { CoreQuestionUpdateFlagRequest } from '../model/core-question-update-flag-request';
import { CoreRatingAddRating200Response } from '../model/core-rating-add-rating-200-response';
import { CoreRatingAddRatingRequest } from '../model/core-rating-add-rating-request';
import { CoreRatingGetItemRatings200Response } from '../model/core-rating-get-item-ratings-200-response';
import { CoreRatingGetItemRatingsRequest } from '../model/core-rating-get-item-ratings-request';
import { CoreReportbuilderAudiencesDeleteRequest } from '../model/core-reportbuilder-audiences-delete-request';
import { CoreReportbuilderCanViewSystemReportRequest } from '../model/core-reportbuilder-can-view-system-report-request';
import { CoreReportbuilderColumnsAdd200Response } from '../model/core-reportbuilder-columns-add-200-response';
import { CoreReportbuilderColumnsAddRequest } from '../model/core-reportbuilder-columns-add-request';
import { CoreReportbuilderColumnsDelete200Response } from '../model/core-reportbuilder-columns-delete-200-response';
import { CoreReportbuilderColumnsDeleteRequest } from '../model/core-reportbuilder-columns-delete-request';
import { CoreReportbuilderColumnsReorderRequest } from '../model/core-reportbuilder-columns-reorder-request';
import { CoreReportbuilderColumnsSortGetRequest } from '../model/core-reportbuilder-columns-sort-get-request';
import { CoreReportbuilderColumnsSortReorderRequest } from '../model/core-reportbuilder-columns-sort-reorder-request';
import { CoreReportbuilderColumnsSortToggleRequest } from '../model/core-reportbuilder-columns-sort-toggle-request';
import { CoreReportbuilderConditionsAdd200Response } from '../model/core-reportbuilder-conditions-add-200-response';
import { CoreReportbuilderConditionsAddRequest } from '../model/core-reportbuilder-conditions-add-request';
import { CoreReportbuilderConditionsDelete200Response } from '../model/core-reportbuilder-conditions-delete-200-response';
import { CoreReportbuilderConditionsDeleteRequest } from '../model/core-reportbuilder-conditions-delete-request';
import { CoreReportbuilderConditionsReorderRequest } from '../model/core-reportbuilder-conditions-reorder-request';
import { CoreReportbuilderFiltersAdd200Response } from '../model/core-reportbuilder-filters-add-200-response';
import { CoreReportbuilderFiltersAddRequest } from '../model/core-reportbuilder-filters-add-request';
import { CoreReportbuilderFiltersDelete200Response } from '../model/core-reportbuilder-filters-delete-200-response';
import { CoreReportbuilderFiltersDeleteRequest } from '../model/core-reportbuilder-filters-delete-request';
import { CoreReportbuilderFiltersReorderRequest } from '../model/core-reportbuilder-filters-reorder-request';
import { CoreReportbuilderFiltersResetRequest } from '../model/core-reportbuilder-filters-reset-request';
import { CoreReportbuilderListReports200Response } from '../model/core-reportbuilder-list-reports-200-response';
import { CoreReportbuilderListReportsRequest } from '../model/core-reportbuilder-list-reports-request';
import { CoreReportbuilderReportsGet200Response } from '../model/core-reportbuilder-reports-get-200-response';
import { CoreReportbuilderReportsGetRequest } from '../model/core-reportbuilder-reports-get-request';
import { CoreReportbuilderRetrieveReport200Response } from '../model/core-reportbuilder-retrieve-report-200-response';
import { CoreReportbuilderRetrieveReportRequest } from '../model/core-reportbuilder-retrieve-report-request';
import { CoreReportbuilderRetrieveSystemReport200Response } from '../model/core-reportbuilder-retrieve-system-report-200-response';
import { CoreReportbuilderRetrieveSystemReportRequest } from '../model/core-reportbuilder-retrieve-system-report-request';
import { CoreReportbuilderSchedulesDeleteRequest } from '../model/core-reportbuilder-schedules-delete-request';
import { CoreReportbuilderSchedulesSendRequest } from '../model/core-reportbuilder-schedules-send-request';
import { CoreReportbuilderSchedulesToggleRequest } from '../model/core-reportbuilder-schedules-toggle-request';
import { CoreReportbuilderSetFiltersRequest } from '../model/core-reportbuilder-set-filters-request';
import { CoreReportbuilderViewReport200Response } from '../model/core-reportbuilder-view-report-200-response';
import { CoreRoleAssignRolesRequest } from '../model/core-role-assign-roles-request';
import { CoreRoleUnassignRolesRequest } from '../model/core-role-unassign-roles-request';
import { CoreSearchGetRelevantUsersRequest } from '../model/core-search-get-relevant-users-request';
import { CoreSearchGetResults200Response } from '../model/core-search-get-results-200-response';
import { CoreSearchGetResultsRequest } from '../model/core-search-get-results-request';
import { CoreSearchGetSearchAreasList200Response } from '../model/core-search-get-search-areas-list-200-response';
import { CoreSearchGetSearchAreasListRequest } from '../model/core-search-get-search-areas-list-request';
import { CoreSearchGetTopResults200Response } from '../model/core-search-get-top-results-200-response';
import { CoreSearchGetTopResultsRequest } from '../model/core-search-get-top-results-request';
import { CoreSearchViewResultsRequest } from '../model/core-search-view-results-request';
import { CoreSessionTimeRemaining200Response } from '../model/core-session-time-remaining-200-response';
import { CoreTableGetDynamicTableContent200Response } from '../model/core-table-get-dynamic-table-content-200-response';
import { CoreTableGetDynamicTableContentRequest } from '../model/core-table-get-dynamic-table-content-request';
import { CoreTagGetTagAreas200Response } from '../model/core-tag-get-tag-areas-200-response';
import { CoreTagGetTagCloud200Response } from '../model/core-tag-get-tag-cloud-200-response';
import { CoreTagGetTagCloudRequest } from '../model/core-tag-get-tag-cloud-request';
import { CoreTagGetTagCollections200Response } from '../model/core-tag-get-tag-collections-200-response';
import { CoreTagGetTagindex200Response } from '../model/core-tag-get-tagindex-200-response';
import { CoreTagGetTagindexPerAreaRequest } from '../model/core-tag-get-tagindex-per-area-request';
import { CoreTagGetTagindexRequest } from '../model/core-tag-get-tagindex-request';
import { CoreTagGetTags200Response } from '../model/core-tag-get-tags-200-response';
import { CoreTagGetTagsRequest } from '../model/core-tag-get-tags-request';
import { CoreTagUpdateTagsRequest } from '../model/core-tag-update-tags-request';
import { CoreUpdateInplaceEditable200Response } from '../model/core-update-inplace-editable-200-response';
import { CoreUpdateInplaceEditableRequest } from '../model/core-update-inplace-editable-request';
import { CoreUserAddUserDeviceRequest } from '../model/core-user-add-user-device-request';
import { CoreUserAddUserPrivateFilesRequest } from '../model/core-user-add-user-private-files-request';
import { CoreUserAgreeSitePolicy200Response } from '../model/core-user-agree-site-policy-200-response';
import { CoreUserCreateUsersRequest } from '../model/core-user-create-users-request';
import { CoreUserDeleteUsersRequest } from '../model/core-user-delete-users-request';
import { CoreUserGetCourseUserProfilesRequest } from '../model/core-user-get-course-user-profiles-request';
import { CoreUserGetPrivateFilesInfo200Response } from '../model/core-user-get-private-files-info-200-response';
import { CoreUserGetPrivateFilesInfoRequest } from '../model/core-user-get-private-files-info-request';
import { CoreUserGetUserPreferences200Response } from '../model/core-user-get-user-preferences-200-response';
import { CoreUserGetUserPreferencesRequest } from '../model/core-user-get-user-preferences-request';
import { CoreUserGetUsers200Response } from '../model/core-user-get-users-200-response';
import { CoreUserGetUsersByFieldRequest } from '../model/core-user-get-users-by-field-request';
import { CoreUserGetUsersRequest } from '../model/core-user-get-users-request';
import { CoreUserRemoveUserDevice200Response } from '../model/core-user-remove-user-device-200-response';
import { CoreUserRemoveUserDeviceRequest } from '../model/core-user-remove-user-device-request';
import { CoreUserSearchIdentity200Response } from '../model/core-user-search-identity-200-response';
import { CoreUserSearchIdentityRequest } from '../model/core-user-search-identity-request';
import { CoreUserSetUserPreferences200Response } from '../model/core-user-set-user-preferences-200-response';
import { CoreUserSetUserPreferencesRequest } from '../model/core-user-set-user-preferences-request';
import { CoreUserUpdatePicture200Response } from '../model/core-user-update-picture-200-response';
import { CoreUserUpdatePictureRequest } from '../model/core-user-update-picture-request';
import { CoreUserUpdateUserDevicePublicKey200Response } from '../model/core-user-update-user-device-public-key-200-response';
import { CoreUserUpdateUserDevicePublicKeyRequest } from '../model/core-user-update-user-device-public-key-request';
import { CoreUserUpdateUserPreferencesRequest } from '../model/core-user-update-user-preferences-request';
import { CoreUserUpdateUsersRequest } from '../model/core-user-update-users-request';
import { CoreUserViewUserListRequest } from '../model/core-user-view-user-list-request';
import { CoreUserViewUserProfileRequest } from '../model/core-user-view-user-profile-request';
import { CoreWebserviceGetSiteInfo200Response } from '../model/core-webservice-get-site-info-200-response';
import { CoreWebserviceGetSiteInfoRequest } from '../model/core-webservice-get-site-info-request';
import { CoreXapiDeleteStateRequest } from '../model/core-xapi-delete-state-request';
import { CoreXapiDeleteStatesRequest } from '../model/core-xapi-delete-states-request';
import { CoreXapiGetStateRequest } from '../model/core-xapi-get-state-request';
import { CoreXapiGetStatesRequest } from '../model/core-xapi-get-states-request';
import { CoreXapiPostStateRequest } from '../model/core-xapi-post-state-request';
import { CoreXapiStatementPostRequest } from '../model/core-xapi-statement-post-request';
import { ErrorResponse } from '../model/error-response';
import { Configuration } from '../configuration';


@Injectable()
export class MoodleService {

    protected basePath = 'https://localhost/webservice/restful/server.php';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Set the protection state for a block plugin
     * Set the protection state for a block plugin
     * @param coreAdminSetBlockProtectionRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAdminSetBlockProtection(coreAdminSetBlockProtectionRequest: CoreAdminSetBlockProtectionRequest, ): Observable<AxiosResponse<object>>;
    public coreAdminSetBlockProtection(coreAdminSetBlockProtectionRequest: CoreAdminSetBlockProtectionRequest, ): Observable<any> {

        if (coreAdminSetBlockProtectionRequest === null || coreAdminSetBlockProtectionRequest === undefined) {
            throw new Error('Required parameter coreAdminSetBlockProtectionRequest was null or undefined when calling coreAdminSetBlockProtection.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_admin_set_block_protection`,
            coreAdminSetBlockProtectionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set the order of a plugin
     * Set the order of a plugin
     * @param coreAdminSetPluginOrderRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAdminSetPluginOrder(coreAdminSetPluginOrderRequest: CoreAdminSetPluginOrderRequest, ): Observable<AxiosResponse<object>>;
    public coreAdminSetPluginOrder(coreAdminSetPluginOrderRequest: CoreAdminSetPluginOrderRequest, ): Observable<any> {

        if (coreAdminSetPluginOrderRequest === null || coreAdminSetPluginOrderRequest === undefined) {
            throw new Error('Required parameter coreAdminSetPluginOrderRequest was null or undefined when calling coreAdminSetPluginOrder.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_admin_set_plugin_order`,
            coreAdminSetPluginOrderRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set the state of a plugin
     * Set the state of a plugin
     * @param coreAdminSetPluginStateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAdminSetPluginState(coreAdminSetPluginStateRequest: CoreAdminSetPluginStateRequest, ): Observable<AxiosResponse<object>>;
    public coreAdminSetPluginState(coreAdminSetPluginStateRequest: CoreAdminSetPluginStateRequest, ): Observable<any> {

        if (coreAdminSetPluginStateRequest === null || coreAdminSetPluginStateRequest === undefined) {
            throw new Error('Required parameter coreAdminSetPluginStateRequest was null or undefined when calling coreAdminSetPluginState.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_admin_set_plugin_state`,
            coreAdminSetPluginStateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Confirm a user account.
     * Confirm a user account.
     * @param coreAuthConfirmUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAuthConfirmUser(coreAuthConfirmUserRequest: CoreAuthConfirmUserRequest, ): Observable<AxiosResponse<CoreAuthConfirmUser200Response>>;
    public coreAuthConfirmUser(coreAuthConfirmUserRequest: CoreAuthConfirmUserRequest, ): Observable<any> {

        if (coreAuthConfirmUserRequest === null || coreAuthConfirmUserRequest === undefined) {
            throw new Error('Required parameter coreAuthConfirmUserRequest was null or undefined when calling coreAuthConfirmUser.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreAuthConfirmUser200Response>(`${this.basePath}/core_auth_confirm_user`,
            coreAuthConfirmUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Checks if age digital consent verification is enabled.
     * Checks if age digital consent verification is enabled.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAuthIsAgeDigitalConsentVerificationEnabled(): Observable<AxiosResponse<CoreAuthIsAgeDigitalConsentVerificationEnabled200Response>>;
    public coreAuthIsAgeDigitalConsentVerificationEnabled(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreAuthIsAgeDigitalConsentVerificationEnabled200Response>(`${this.basePath}/core_auth_is_age_digital_consent_verification_enabled`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Requests a check if a user is a digital minor.
     * Requests a check if a user is a digital minor.
     * @param coreAuthIsMinorRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAuthIsMinor(coreAuthIsMinorRequest: CoreAuthIsMinorRequest, ): Observable<AxiosResponse<CoreAuthIsMinor200Response>>;
    public coreAuthIsMinor(coreAuthIsMinorRequest: CoreAuthIsMinorRequest, ): Observable<any> {

        if (coreAuthIsMinorRequest === null || coreAuthIsMinorRequest === undefined) {
            throw new Error('Required parameter coreAuthIsMinorRequest was null or undefined when calling coreAuthIsMinor.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreAuthIsMinor200Response>(`${this.basePath}/core_auth_is_minor`,
            coreAuthIsMinorRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Requests a password reset.
     * Requests a password reset.
     * @param coreAuthRequestPasswordResetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAuthRequestPasswordReset(coreAuthRequestPasswordResetRequest: CoreAuthRequestPasswordResetRequest, ): Observable<AxiosResponse<CoreAuthRequestPasswordReset200Response>>;
    public coreAuthRequestPasswordReset(coreAuthRequestPasswordResetRequest: CoreAuthRequestPasswordResetRequest, ): Observable<any> {

        if (coreAuthRequestPasswordResetRequest === null || coreAuthRequestPasswordResetRequest === undefined) {
            throw new Error('Required parameter coreAuthRequestPasswordResetRequest was null or undefined when calling coreAuthRequestPasswordReset.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreAuthRequestPasswordReset200Response>(`${this.basePath}/core_auth_request_password_reset`,
            coreAuthRequestPasswordResetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Resend confirmation email.
     * Resend confirmation email.
     * @param coreAuthResendConfirmationEmailRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreAuthResendConfirmationEmail(coreAuthResendConfirmationEmailRequest: CoreAuthResendConfirmationEmailRequest, ): Observable<AxiosResponse<CoreAuthResendConfirmationEmail200Response>>;
    public coreAuthResendConfirmationEmail(coreAuthResendConfirmationEmailRequest: CoreAuthResendConfirmationEmailRequest, ): Observable<any> {

        if (coreAuthResendConfirmationEmailRequest === null || coreAuthResendConfirmationEmailRequest === undefined) {
            throw new Error('Required parameter coreAuthResendConfirmationEmailRequest was null or undefined when calling coreAuthResendConfirmationEmail.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreAuthResendConfirmationEmail200Response>(`${this.basePath}/core_auth_resend_confirmation_email`,
            coreAuthResendConfirmationEmailRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets the data to use when updating the status table row in the UI for when an async backup completes.
     * Gets the data to use when updating the status table row in the UI for when an async backup completes.
     * @param coreBackupGetAsyncBackupLinksBackupRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBackupGetAsyncBackupLinksBackup(coreBackupGetAsyncBackupLinksBackupRequest: CoreBackupGetAsyncBackupLinksBackupRequest, ): Observable<AxiosResponse<CoreBackupGetAsyncBackupLinksBackup200Response>>;
    public coreBackupGetAsyncBackupLinksBackup(coreBackupGetAsyncBackupLinksBackupRequest: CoreBackupGetAsyncBackupLinksBackupRequest, ): Observable<any> {

        if (coreBackupGetAsyncBackupLinksBackupRequest === null || coreBackupGetAsyncBackupLinksBackupRequest === undefined) {
            throw new Error('Required parameter coreBackupGetAsyncBackupLinksBackupRequest was null or undefined when calling coreBackupGetAsyncBackupLinksBackup.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBackupGetAsyncBackupLinksBackup200Response>(`${this.basePath}/core_backup_get_async_backup_links_backup`,
            coreBackupGetAsyncBackupLinksBackupRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets the data to use when updating the status table row in the UI for when an async restore completes.
     * Gets the data to use when updating the status table row in the UI for when an async restore completes.
     * @param coreBackupGetAsyncBackupLinksRestoreRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBackupGetAsyncBackupLinksRestore(coreBackupGetAsyncBackupLinksRestoreRequest: CoreBackupGetAsyncBackupLinksRestoreRequest, ): Observable<AxiosResponse<CoreBackupGetAsyncBackupLinksRestore200Response>>;
    public coreBackupGetAsyncBackupLinksRestore(coreBackupGetAsyncBackupLinksRestoreRequest: CoreBackupGetAsyncBackupLinksRestoreRequest, ): Observable<any> {

        if (coreBackupGetAsyncBackupLinksRestoreRequest === null || coreBackupGetAsyncBackupLinksRestoreRequest === undefined) {
            throw new Error('Required parameter coreBackupGetAsyncBackupLinksRestoreRequest was null or undefined when calling coreBackupGetAsyncBackupLinksRestore.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBackupGetAsyncBackupLinksRestore200Response>(`${this.basePath}/core_backup_get_async_backup_links_restore`,
            coreBackupGetAsyncBackupLinksRestoreRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the progress of an Asyncronhous backup.
     * Get the progress of an Asyncronhous backup.
     * @param coreBackupGetAsyncBackupProgressRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBackupGetAsyncBackupProgress(coreBackupGetAsyncBackupProgressRequest: CoreBackupGetAsyncBackupProgressRequest, ): Observable<AxiosResponse<object>>;
    public coreBackupGetAsyncBackupProgress(coreBackupGetAsyncBackupProgressRequest: CoreBackupGetAsyncBackupProgressRequest, ): Observable<any> {

        if (coreBackupGetAsyncBackupProgressRequest === null || coreBackupGetAsyncBackupProgressRequest === undefined) {
            throw new Error('Required parameter coreBackupGetAsyncBackupProgressRequest was null or undefined when calling coreBackupGetAsyncBackupProgress.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_backup_get_async_backup_progress`,
            coreBackupGetAsyncBackupProgressRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets the progress of course copy operations.
     * Gets the progress of course copy operations.
     * @param coreBackupGetCopyProgressRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBackupGetCopyProgress(coreBackupGetCopyProgressRequest: CoreBackupGetCopyProgressRequest, ): Observable<AxiosResponse<object>>;
    public coreBackupGetCopyProgress(coreBackupGetCopyProgressRequest: CoreBackupGetCopyProgressRequest, ): Observable<any> {

        if (coreBackupGetCopyProgressRequest === null || coreBackupGetCopyProgressRequest === undefined) {
            throw new Error('Required parameter coreBackupGetCopyProgressRequest was null or undefined when calling coreBackupGetCopyProgress.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_backup_get_copy_progress`,
            coreBackupGetCopyProgressRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Handles ajax submission of course copy form.
     * Handles ajax submission of course copy form.
     * @param coreBackupSubmitCopyFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBackupSubmitCopyForm(coreBackupSubmitCopyFormRequest: CoreBackupSubmitCopyFormRequest, ): Observable<AxiosResponse<object>>;
    public coreBackupSubmitCopyForm(coreBackupSubmitCopyFormRequest: CoreBackupSubmitCopyFormRequest, ): Observable<any> {

        if (coreBackupSubmitCopyFormRequest === null || coreBackupSubmitCopyFormRequest === undefined) {
            throw new Error('Required parameter coreBackupSubmitCopyFormRequest was null or undefined when calling coreBackupSubmitCopyForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_backup_submit_copy_form`,
            coreBackupSubmitCopyFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the badge awarded to a user by hash.
     * Returns the badge awarded to a user by hash.
     * @param coreBadgesGetUserBadgeByHashRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBadgesGetUserBadgeByHash(coreBadgesGetUserBadgeByHashRequest: CoreBadgesGetUserBadgeByHashRequest, ): Observable<AxiosResponse<CoreBadgesGetUserBadgeByHash200Response>>;
    public coreBadgesGetUserBadgeByHash(coreBadgesGetUserBadgeByHashRequest: CoreBadgesGetUserBadgeByHashRequest, ): Observable<any> {

        if (coreBadgesGetUserBadgeByHashRequest === null || coreBadgesGetUserBadgeByHashRequest === undefined) {
            throw new Error('Required parameter coreBadgesGetUserBadgeByHashRequest was null or undefined when calling coreBadgesGetUserBadgeByHash.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBadgesGetUserBadgeByHash200Response>(`${this.basePath}/core_badges_get_user_badge_by_hash`,
            coreBadgesGetUserBadgeByHashRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the list of badges awarded to a user.
     * Returns the list of badges awarded to a user.
     * @param coreBadgesGetUserBadgesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBadgesGetUserBadges(coreBadgesGetUserBadgesRequest: CoreBadgesGetUserBadgesRequest, ): Observable<AxiosResponse<CoreBadgesGetUserBadges200Response>>;
    public coreBadgesGetUserBadges(coreBadgesGetUserBadgesRequest: CoreBadgesGetUserBadgesRequest, ): Observable<any> {

        if (coreBadgesGetUserBadgesRequest === null || coreBadgesGetUserBadgesRequest === undefined) {
            throw new Error('Required parameter coreBadgesGetUserBadgesRequest was null or undefined when calling coreBadgesGetUserBadges.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBadgesGetUserBadges200Response>(`${this.basePath}/core_badges_get_user_badges`,
            coreBadgesGetUserBadgesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns all addable blocks in a given page.
     * Returns all addable blocks in a given page.
     * @param coreBlockFetchAddableBlocksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBlockFetchAddableBlocks(coreBlockFetchAddableBlocksRequest: CoreBlockFetchAddableBlocksRequest, ): Observable<AxiosResponse<object>>;
    public coreBlockFetchAddableBlocks(coreBlockFetchAddableBlocksRequest: CoreBlockFetchAddableBlocksRequest, ): Observable<any> {

        if (coreBlockFetchAddableBlocksRequest === null || coreBlockFetchAddableBlocksRequest === undefined) {
            throw new Error('Required parameter coreBlockFetchAddableBlocksRequest was null or undefined when calling coreBlockFetchAddableBlocks.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_block_fetch_addable_blocks`,
            coreBlockFetchAddableBlocksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns blocks information for a course.
     * Returns blocks information for a course.
     * @param coreBlockGetCourseBlocksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBlockGetCourseBlocks(coreBlockGetCourseBlocksRequest: CoreBlockGetCourseBlocksRequest, ): Observable<AxiosResponse<CoreBlockGetCourseBlocks200Response>>;
    public coreBlockGetCourseBlocks(coreBlockGetCourseBlocksRequest: CoreBlockGetCourseBlocksRequest, ): Observable<any> {

        if (coreBlockGetCourseBlocksRequest === null || coreBlockGetCourseBlocksRequest === undefined) {
            throw new Error('Required parameter coreBlockGetCourseBlocksRequest was null or undefined when calling coreBlockGetCourseBlocks.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBlockGetCourseBlocks200Response>(`${this.basePath}/core_block_get_course_blocks`,
            coreBlockGetCourseBlocksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns blocks information for the given user dashboard.
     * Returns blocks information for the given user dashboard.
     * @param coreBlockGetDashboardBlocksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBlockGetDashboardBlocks(coreBlockGetDashboardBlocksRequest: CoreBlockGetDashboardBlocksRequest, ): Observable<AxiosResponse<CoreBlockGetDashboardBlocks200Response>>;
    public coreBlockGetDashboardBlocks(coreBlockGetDashboardBlocksRequest: CoreBlockGetDashboardBlocksRequest, ): Observable<any> {

        if (coreBlockGetDashboardBlocksRequest === null || coreBlockGetDashboardBlocksRequest === undefined) {
            throw new Error('Required parameter coreBlockGetDashboardBlocksRequest was null or undefined when calling coreBlockGetDashboardBlocks.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBlockGetDashboardBlocks200Response>(`${this.basePath}/core_block_get_dashboard_blocks`,
            coreBlockGetDashboardBlocksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns blog entries.
     * Returns blog entries.
     * @param coreBlogGetEntriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBlogGetEntries(coreBlogGetEntriesRequest: CoreBlogGetEntriesRequest, ): Observable<AxiosResponse<CoreBlogGetEntries200Response>>;
    public coreBlogGetEntries(coreBlogGetEntriesRequest: CoreBlogGetEntriesRequest, ): Observable<any> {

        if (coreBlogGetEntriesRequest === null || coreBlogGetEntriesRequest === undefined) {
            throw new Error('Required parameter coreBlogGetEntriesRequest was null or undefined when calling coreBlogGetEntries.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBlogGetEntries200Response>(`${this.basePath}/core_blog_get_entries`,
            coreBlogGetEntriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Trigger the blog_entries_viewed event.
     * Trigger the blog_entries_viewed event.
     * @param coreBlogViewEntriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreBlogViewEntries(coreBlogViewEntriesRequest: CoreBlogViewEntriesRequest, ): Observable<AxiosResponse<CoreBlogViewEntries200Response>>;
    public coreBlogViewEntries(coreBlogViewEntriesRequest: CoreBlogViewEntriesRequest, ): Observable<any> {

        if (coreBlogViewEntriesRequest === null || coreBlogViewEntriesRequest === undefined) {
            throw new Error('Required parameter coreBlogViewEntriesRequest was null or undefined when calling coreBlogViewEntries.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreBlogViewEntries200Response>(`${this.basePath}/core_blog_view_entries`,
            coreBlogViewEntriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create calendar events
     * Create calendar events
     * @param coreCalendarCreateCalendarEventsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarCreateCalendarEvents(coreCalendarCreateCalendarEventsRequest: CoreCalendarCreateCalendarEventsRequest, ): Observable<AxiosResponse<CoreCalendarCreateCalendarEvents200Response>>;
    public coreCalendarCreateCalendarEvents(coreCalendarCreateCalendarEventsRequest: CoreCalendarCreateCalendarEventsRequest, ): Observable<any> {

        if (coreCalendarCreateCalendarEventsRequest === null || coreCalendarCreateCalendarEventsRequest === undefined) {
            throw new Error('Required parameter coreCalendarCreateCalendarEventsRequest was null or undefined when calling coreCalendarCreateCalendarEvents.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarCreateCalendarEvents200Response>(`${this.basePath}/core_calendar_create_calendar_events`,
            coreCalendarCreateCalendarEventsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete calendar events
     * Delete calendar events
     * @param coreCalendarDeleteCalendarEventsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarDeleteCalendarEvents(coreCalendarDeleteCalendarEventsRequest: CoreCalendarDeleteCalendarEventsRequest, ): Observable<AxiosResponse<object>>;
    public coreCalendarDeleteCalendarEvents(coreCalendarDeleteCalendarEventsRequest: CoreCalendarDeleteCalendarEventsRequest, ): Observable<any> {

        if (coreCalendarDeleteCalendarEventsRequest === null || coreCalendarDeleteCalendarEventsRequest === undefined) {
            throw new Error('Required parameter coreCalendarDeleteCalendarEventsRequest was null or undefined when calling coreCalendarDeleteCalendarEvents.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_calendar_delete_calendar_events`,
            coreCalendarDeleteCalendarEventsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete the calendar subscription
     * Delete the calendar subscription
     * @param coreCalendarDeleteSubscriptionRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarDeleteSubscription(coreCalendarDeleteSubscriptionRequest: CoreCalendarDeleteSubscriptionRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreCalendarDeleteSubscription(coreCalendarDeleteSubscriptionRequest: CoreCalendarDeleteSubscriptionRequest, ): Observable<any> {

        if (coreCalendarDeleteSubscriptionRequest === null || coreCalendarDeleteSubscriptionRequest === undefined) {
            throw new Error('Required parameter coreCalendarDeleteSubscriptionRequest was null or undefined when calling coreCalendarDeleteSubscription.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_calendar_delete_subscription`,
            coreCalendarDeleteSubscriptionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get calendar action events by course
     * Get calendar action events by course
     * @param coreCalendarGetActionEventsByCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetActionEventsByCourse(coreCalendarGetActionEventsByCourseRequest: CoreCalendarGetActionEventsByCourseRequest, ): Observable<AxiosResponse<CoreCalendarGetActionEventsByCourse200Response>>;
    public coreCalendarGetActionEventsByCourse(coreCalendarGetActionEventsByCourseRequest: CoreCalendarGetActionEventsByCourseRequest, ): Observable<any> {

        if (coreCalendarGetActionEventsByCourseRequest === null || coreCalendarGetActionEventsByCourseRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetActionEventsByCourseRequest was null or undefined when calling coreCalendarGetActionEventsByCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetActionEventsByCourse200Response>(`${this.basePath}/core_calendar_get_action_events_by_course`,
            coreCalendarGetActionEventsByCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get calendar action events by courses
     * Get calendar action events by courses
     * @param coreCalendarGetActionEventsByCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetActionEventsByCourses(coreCalendarGetActionEventsByCoursesRequest: CoreCalendarGetActionEventsByCoursesRequest, ): Observable<AxiosResponse<CoreCalendarGetActionEventsByCourses200Response>>;
    public coreCalendarGetActionEventsByCourses(coreCalendarGetActionEventsByCoursesRequest: CoreCalendarGetActionEventsByCoursesRequest, ): Observable<any> {

        if (coreCalendarGetActionEventsByCoursesRequest === null || coreCalendarGetActionEventsByCoursesRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetActionEventsByCoursesRequest was null or undefined when calling coreCalendarGetActionEventsByCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetActionEventsByCourses200Response>(`${this.basePath}/core_calendar_get_action_events_by_courses`,
            coreCalendarGetActionEventsByCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get calendar action events by tiemsort
     * Get calendar action events by tiemsort
     * @param coreCalendarGetActionEventsByTimesortRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetActionEventsByTimesort(coreCalendarGetActionEventsByTimesortRequest: CoreCalendarGetActionEventsByTimesortRequest, ): Observable<AxiosResponse<CoreCalendarGetActionEventsByTimesort200Response>>;
    public coreCalendarGetActionEventsByTimesort(coreCalendarGetActionEventsByTimesortRequest: CoreCalendarGetActionEventsByTimesortRequest, ): Observable<any> {

        if (coreCalendarGetActionEventsByTimesortRequest === null || coreCalendarGetActionEventsByTimesortRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetActionEventsByTimesortRequest was null or undefined when calling coreCalendarGetActionEventsByTimesort.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetActionEventsByTimesort200Response>(`${this.basePath}/core_calendar_get_action_events_by_timesort`,
            coreCalendarGetActionEventsByTimesortRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the type of events a user can create in the given course.
     * Get the type of events a user can create in the given course.
     * @param coreCalendarGetAllowedEventTypesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetAllowedEventTypes(coreCalendarGetAllowedEventTypesRequest: CoreCalendarGetAllowedEventTypesRequest, ): Observable<AxiosResponse<CoreCalendarGetAllowedEventTypes200Response>>;
    public coreCalendarGetAllowedEventTypes(coreCalendarGetAllowedEventTypesRequest: CoreCalendarGetAllowedEventTypesRequest, ): Observable<any> {

        if (coreCalendarGetAllowedEventTypesRequest === null || coreCalendarGetAllowedEventTypesRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetAllowedEventTypesRequest was null or undefined when calling coreCalendarGetAllowedEventTypes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetAllowedEventTypes200Response>(`${this.basePath}/core_calendar_get_allowed_event_types`,
            coreCalendarGetAllowedEventTypesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Convenience function to retrieve some permissions/access information for the given course calendar.
     * Convenience function to retrieve some permissions/access information for the given course calendar.
     * @param coreCalendarGetCalendarAccessInformationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarAccessInformation(coreCalendarGetCalendarAccessInformationRequest: CoreCalendarGetCalendarAccessInformationRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarAccessInformation200Response>>;
    public coreCalendarGetCalendarAccessInformation(coreCalendarGetCalendarAccessInformationRequest: CoreCalendarGetCalendarAccessInformationRequest, ): Observable<any> {

        if (coreCalendarGetCalendarAccessInformationRequest === null || coreCalendarGetCalendarAccessInformationRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarAccessInformationRequest was null or undefined when calling coreCalendarGetCalendarAccessInformation.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarAccessInformation200Response>(`${this.basePath}/core_calendar_get_calendar_access_information`,
            coreCalendarGetCalendarAccessInformationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the day view data for a calendar
     * Fetch the day view data for a calendar
     * @param coreCalendarGetCalendarDayViewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarDayView(coreCalendarGetCalendarDayViewRequest: CoreCalendarGetCalendarDayViewRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarDayView200Response>>;
    public coreCalendarGetCalendarDayView(coreCalendarGetCalendarDayViewRequest: CoreCalendarGetCalendarDayViewRequest, ): Observable<any> {

        if (coreCalendarGetCalendarDayViewRequest === null || coreCalendarGetCalendarDayViewRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarDayViewRequest was null or undefined when calling coreCalendarGetCalendarDayView.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarDayView200Response>(`${this.basePath}/core_calendar_get_calendar_day_view`,
            coreCalendarGetCalendarDayViewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get calendar event by id
     * Get calendar event by id
     * @param coreCalendarGetCalendarEventByIdRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarEventById(coreCalendarGetCalendarEventByIdRequest: CoreCalendarGetCalendarEventByIdRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarEventById200Response>>;
    public coreCalendarGetCalendarEventById(coreCalendarGetCalendarEventByIdRequest: CoreCalendarGetCalendarEventByIdRequest, ): Observable<any> {

        if (coreCalendarGetCalendarEventByIdRequest === null || coreCalendarGetCalendarEventByIdRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarEventByIdRequest was null or undefined when calling coreCalendarGetCalendarEventById.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarEventById200Response>(`${this.basePath}/core_calendar_get_calendar_event_by_id`,
            coreCalendarGetCalendarEventByIdRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get calendar events
     * Get calendar events
     * @param coreCalendarGetCalendarEventsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarEvents(coreCalendarGetCalendarEventsRequest: CoreCalendarGetCalendarEventsRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarEvents200Response>>;
    public coreCalendarGetCalendarEvents(coreCalendarGetCalendarEventsRequest: CoreCalendarGetCalendarEventsRequest, ): Observable<any> {

        if (coreCalendarGetCalendarEventsRequest === null || coreCalendarGetCalendarEventsRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarEventsRequest was null or undefined when calling coreCalendarGetCalendarEvents.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarEvents200Response>(`${this.basePath}/core_calendar_get_calendar_events`,
            coreCalendarGetCalendarEventsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return the auth token required for exporting a calendar.
     * Return the auth token required for exporting a calendar.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarExportToken(): Observable<AxiosResponse<CoreCalendarGetCalendarExportToken200Response>>;
    public coreCalendarGetCalendarExportToken(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreCalendarGetCalendarExportToken200Response>(`${this.basePath}/core_calendar_get_calendar_export_token`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the monthly view data for a calendar
     * Fetch the monthly view data for a calendar
     * @param coreCalendarGetCalendarMonthlyViewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarMonthlyView(coreCalendarGetCalendarMonthlyViewRequest: CoreCalendarGetCalendarMonthlyViewRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarMonthlyView200Response>>;
    public coreCalendarGetCalendarMonthlyView(coreCalendarGetCalendarMonthlyViewRequest: CoreCalendarGetCalendarMonthlyViewRequest, ): Observable<any> {

        if (coreCalendarGetCalendarMonthlyViewRequest === null || coreCalendarGetCalendarMonthlyViewRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarMonthlyViewRequest was null or undefined when calling coreCalendarGetCalendarMonthlyView.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarMonthlyView200Response>(`${this.basePath}/core_calendar_get_calendar_monthly_view`,
            coreCalendarGetCalendarMonthlyViewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the upcoming view data for a calendar
     * Fetch the upcoming view data for a calendar
     * @param coreCalendarGetCalendarUpcomingViewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetCalendarUpcomingView(coreCalendarGetCalendarUpcomingViewRequest: CoreCalendarGetCalendarUpcomingViewRequest, ): Observable<AxiosResponse<CoreCalendarGetCalendarUpcomingView200Response>>;
    public coreCalendarGetCalendarUpcomingView(coreCalendarGetCalendarUpcomingViewRequest: CoreCalendarGetCalendarUpcomingViewRequest, ): Observable<any> {

        if (coreCalendarGetCalendarUpcomingViewRequest === null || coreCalendarGetCalendarUpcomingViewRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetCalendarUpcomingViewRequest was null or undefined when calling coreCalendarGetCalendarUpcomingView.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetCalendarUpcomingView200Response>(`${this.basePath}/core_calendar_get_calendar_upcoming_view`,
            coreCalendarGetCalendarUpcomingViewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch unix timestamps for given date times.
     * Fetch unix timestamps for given date times.
     * @param coreCalendarGetTimestampsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarGetTimestamps(coreCalendarGetTimestampsRequest: CoreCalendarGetTimestampsRequest, ): Observable<AxiosResponse<CoreCalendarGetTimestamps200Response>>;
    public coreCalendarGetTimestamps(coreCalendarGetTimestampsRequest: CoreCalendarGetTimestampsRequest, ): Observable<any> {

        if (coreCalendarGetTimestampsRequest === null || coreCalendarGetTimestampsRequest === undefined) {
            throw new Error('Required parameter coreCalendarGetTimestampsRequest was null or undefined when calling coreCalendarGetTimestamps.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarGetTimestamps200Response>(`${this.basePath}/core_calendar_get_timestamps`,
            coreCalendarGetTimestampsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Submit form data for event form
     * Submit form data for event form
     * @param coreCalendarSubmitCreateUpdateFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarSubmitCreateUpdateForm(coreCalendarSubmitCreateUpdateFormRequest: CoreCalendarSubmitCreateUpdateFormRequest, ): Observable<AxiosResponse<CoreCalendarSubmitCreateUpdateForm200Response>>;
    public coreCalendarSubmitCreateUpdateForm(coreCalendarSubmitCreateUpdateFormRequest: CoreCalendarSubmitCreateUpdateFormRequest, ): Observable<any> {

        if (coreCalendarSubmitCreateUpdateFormRequest === null || coreCalendarSubmitCreateUpdateFormRequest === undefined) {
            throw new Error('Required parameter coreCalendarSubmitCreateUpdateFormRequest was null or undefined when calling coreCalendarSubmitCreateUpdateForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarSubmitCreateUpdateForm200Response>(`${this.basePath}/core_calendar_submit_create_update_form`,
            coreCalendarSubmitCreateUpdateFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update the start day (but not time) for an event.
     * Update the start day (but not time) for an event.
     * @param coreCalendarUpdateEventStartDayRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCalendarUpdateEventStartDay(coreCalendarUpdateEventStartDayRequest: CoreCalendarUpdateEventStartDayRequest, ): Observable<AxiosResponse<CoreCalendarUpdateEventStartDay200Response>>;
    public coreCalendarUpdateEventStartDay(coreCalendarUpdateEventStartDayRequest: CoreCalendarUpdateEventStartDayRequest, ): Observable<any> {

        if (coreCalendarUpdateEventStartDayRequest === null || coreCalendarUpdateEventStartDayRequest === undefined) {
            throw new Error('Required parameter coreCalendarUpdateEventStartDayRequest was null or undefined when calling coreCalendarUpdateEventStartDay.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarUpdateEventStartDay200Response>(`${this.basePath}/core_calendar_update_event_start_day`,
            coreCalendarUpdateEventStartDayRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Change the editing mode
     * Change the editing mode
     * @param coreChangeEditmodeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreChangeEditmode(coreChangeEditmodeRequest: CoreChangeEditmodeRequest, ): Observable<AxiosResponse<CoreChangeEditmode200Response>>;
    public coreChangeEditmode(coreChangeEditmodeRequest: CoreChangeEditmodeRequest, ): Observable<any> {

        if (coreChangeEditmodeRequest === null || coreChangeEditmodeRequest === undefined) {
            throw new Error('Required parameter coreChangeEditmodeRequest was null or undefined when calling coreChangeEditmode.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreChangeEditmode200Response>(`${this.basePath}/core_change_editmode`,
            coreChangeEditmodeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds cohort members.
     * Adds cohort members.
     * @param coreCohortAddCohortMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortAddCohortMembers(coreCohortAddCohortMembersRequest: CoreCohortAddCohortMembersRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreCohortAddCohortMembers(coreCohortAddCohortMembersRequest: CoreCohortAddCohortMembersRequest, ): Observable<any> {

        if (coreCohortAddCohortMembersRequest === null || coreCohortAddCohortMembersRequest === undefined) {
            throw new Error('Required parameter coreCohortAddCohortMembersRequest was null or undefined when calling coreCohortAddCohortMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_cohort_add_cohort_members`,
            coreCohortAddCohortMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new cohorts.
     * Creates new cohorts.
     * @param coreCohortCreateCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortCreateCohorts(coreCohortCreateCohortsRequest: CoreCohortCreateCohortsRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortCreateCohorts(coreCohortCreateCohortsRequest: CoreCohortCreateCohortsRequest, ): Observable<any> {

        if (coreCohortCreateCohortsRequest === null || coreCohortCreateCohortsRequest === undefined) {
            throw new Error('Required parameter coreCohortCreateCohortsRequest was null or undefined when calling coreCohortCreateCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_create_cohorts`,
            coreCohortCreateCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes cohort members.
     * Deletes cohort members.
     * @param coreCohortDeleteCohortMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortDeleteCohortMembers(coreCohortDeleteCohortMembersRequest: CoreCohortDeleteCohortMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortDeleteCohortMembers(coreCohortDeleteCohortMembersRequest: CoreCohortDeleteCohortMembersRequest, ): Observable<any> {

        if (coreCohortDeleteCohortMembersRequest === null || coreCohortDeleteCohortMembersRequest === undefined) {
            throw new Error('Required parameter coreCohortDeleteCohortMembersRequest was null or undefined when calling coreCohortDeleteCohortMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_delete_cohort_members`,
            coreCohortDeleteCohortMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes all specified cohorts.
     * Deletes all specified cohorts.
     * @param coreCohortDeleteCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortDeleteCohorts(coreCohortDeleteCohortsRequest: CoreCohortDeleteCohortsRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortDeleteCohorts(coreCohortDeleteCohortsRequest: CoreCohortDeleteCohortsRequest, ): Observable<any> {

        if (coreCohortDeleteCohortsRequest === null || coreCohortDeleteCohortsRequest === undefined) {
            throw new Error('Required parameter coreCohortDeleteCohortsRequest was null or undefined when calling coreCohortDeleteCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_delete_cohorts`,
            coreCohortDeleteCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns cohort members.
     * Returns cohort members.
     * @param coreCohortGetCohortMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortGetCohortMembers(coreCohortGetCohortMembersRequest: CoreCohortGetCohortMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortGetCohortMembers(coreCohortGetCohortMembersRequest: CoreCohortGetCohortMembersRequest, ): Observable<any> {

        if (coreCohortGetCohortMembersRequest === null || coreCohortGetCohortMembersRequest === undefined) {
            throw new Error('Required parameter coreCohortGetCohortMembersRequest was null or undefined when calling coreCohortGetCohortMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_get_cohort_members`,
            coreCohortGetCohortMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns cohort details.
     * Returns cohort details.
     * @param coreCohortGetCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortGetCohorts(coreCohortGetCohortsRequest: CoreCohortGetCohortsRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortGetCohorts(coreCohortGetCohortsRequest: CoreCohortGetCohortsRequest, ): Observable<any> {

        if (coreCohortGetCohortsRequest === null || coreCohortGetCohortsRequest === undefined) {
            throw new Error('Required parameter coreCohortGetCohortsRequest was null or undefined when calling coreCohortGetCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_get_cohorts`,
            coreCohortGetCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search for cohorts.
     * Search for cohorts.
     * @param coreCohortSearchCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortSearchCohorts(coreCohortSearchCohortsRequest: CoreCohortSearchCohortsRequest, ): Observable<AxiosResponse<CoreCohortSearchCohorts200Response>>;
    public coreCohortSearchCohorts(coreCohortSearchCohortsRequest: CoreCohortSearchCohortsRequest, ): Observable<any> {

        if (coreCohortSearchCohortsRequest === null || coreCohortSearchCohortsRequest === undefined) {
            throw new Error('Required parameter coreCohortSearchCohortsRequest was null or undefined when calling coreCohortSearchCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortSearchCohorts200Response>(`${this.basePath}/core_cohort_search_cohorts`,
            coreCohortSearchCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Updates existing cohorts.
     * Updates existing cohorts.
     * @param coreCohortUpdateCohortsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCohortUpdateCohorts(coreCohortUpdateCohortsRequest: CoreCohortUpdateCohortsRequest, ): Observable<AxiosResponse<object>>;
    public coreCohortUpdateCohorts(coreCohortUpdateCohortsRequest: CoreCohortUpdateCohortsRequest, ): Observable<any> {

        if (coreCohortUpdateCohortsRequest === null || coreCohortUpdateCohortsRequest === undefined) {
            throw new Error('Required parameter coreCohortUpdateCohortsRequest was null or undefined when calling coreCohortUpdateCohorts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_cohort_update_cohorts`,
            coreCohortUpdateCohortsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds a comment or comments.
     * Adds a comment or comments.
     * @param coreCommentAddCommentsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCommentAddComments(coreCommentAddCommentsRequest: CoreCommentAddCommentsRequest, ): Observable<AxiosResponse<object>>;
    public coreCommentAddComments(coreCommentAddCommentsRequest: CoreCommentAddCommentsRequest, ): Observable<any> {

        if (coreCommentAddCommentsRequest === null || coreCommentAddCommentsRequest === undefined) {
            throw new Error('Required parameter coreCommentAddCommentsRequest was null or undefined when calling coreCommentAddComments.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_comment_add_comments`,
            coreCommentAddCommentsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes a comment or comments.
     * Deletes a comment or comments.
     * @param coreCommentDeleteCommentsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCommentDeleteComments(coreCommentDeleteCommentsRequest: CoreCommentDeleteCommentsRequest, ): Observable<AxiosResponse<object>>;
    public coreCommentDeleteComments(coreCommentDeleteCommentsRequest: CoreCommentDeleteCommentsRequest, ): Observable<any> {

        if (coreCommentDeleteCommentsRequest === null || coreCommentDeleteCommentsRequest === undefined) {
            throw new Error('Required parameter coreCommentDeleteCommentsRequest was null or undefined when calling coreCommentDeleteComments.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_comment_delete_comments`,
            coreCommentDeleteCommentsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns comments.
     * Returns comments.
     * @param coreCommentGetCommentsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCommentGetComments(coreCommentGetCommentsRequest: CoreCommentGetCommentsRequest, ): Observable<AxiosResponse<CoreCommentGetComments200Response>>;
    public coreCommentGetComments(coreCommentGetCommentsRequest: CoreCommentGetCommentsRequest, ): Observable<any> {

        if (coreCommentGetCommentsRequest === null || coreCommentGetCommentsRequest === undefined) {
            throw new Error('Required parameter coreCommentGetCommentsRequest was null or undefined when calling coreCommentGetComments.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCommentGetComments200Response>(`${this.basePath}/core_comment_get_comments`,
            coreCommentGetCommentsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add the competency to a course
     * Add the competency to a course
     * @param coreCompetencyAddCompetencyToCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyAddCompetencyToCourse(coreCompetencyAddCompetencyToCourseRequest: CoreCompetencyAddCompetencyToCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyAddCompetencyToCourse(coreCompetencyAddCompetencyToCourseRequest: CoreCompetencyAddCompetencyToCourseRequest, ): Observable<any> {

        if (coreCompetencyAddCompetencyToCourseRequest === null || coreCompetencyAddCompetencyToCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyAddCompetencyToCourseRequest was null or undefined when calling coreCompetencyAddCompetencyToCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_add_competency_to_course`,
            coreCompetencyAddCompetencyToCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add the competency to a learning plan
     * Add the competency to a learning plan
     * @param coreCompetencyAddCompetencyToPlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyAddCompetencyToPlan(coreCompetencyAddCompetencyToPlanRequest: CoreCompetencyAddCompetencyToPlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyAddCompetencyToPlan(coreCompetencyAddCompetencyToPlanRequest: CoreCompetencyAddCompetencyToPlanRequest, ): Observable<any> {

        if (coreCompetencyAddCompetencyToPlanRequest === null || coreCompetencyAddCompetencyToPlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyAddCompetencyToPlanRequest was null or undefined when calling coreCompetencyAddCompetencyToPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_add_competency_to_plan`,
            coreCompetencyAddCompetencyToPlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add the competency to a template
     * Add the competency to a template
     * @param coreCompetencyAddCompetencyToTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyAddCompetencyToTemplate(coreCompetencyAddCompetencyToTemplateRequest: CoreCompetencyAddCompetencyToTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyAddCompetencyToTemplate(coreCompetencyAddCompetencyToTemplateRequest: CoreCompetencyAddCompetencyToTemplateRequest, ): Observable<any> {

        if (coreCompetencyAddCompetencyToTemplateRequest === null || coreCompetencyAddCompetencyToTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyAddCompetencyToTemplateRequest was null or undefined when calling coreCompetencyAddCompetencyToTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_add_competency_to_template`,
            coreCompetencyAddCompetencyToTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds a related competency
     * Adds a related competency
     * @param coreCompetencyAddRelatedCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyAddRelatedCompetency(coreCompetencyAddRelatedCompetencyRequest: CoreCompetencyAddRelatedCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyAddRelatedCompetency(coreCompetencyAddRelatedCompetencyRequest: CoreCompetencyAddRelatedCompetencyRequest, ): Observable<any> {

        if (coreCompetencyAddRelatedCompetencyRequest === null || coreCompetencyAddRelatedCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyAddRelatedCompetencyRequest was null or undefined when calling coreCompetencyAddRelatedCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_add_related_competency`,
            coreCompetencyAddRelatedCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Approve a plan.
     * Approve a plan.
     * @param coreCompetencyApprovePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyApprovePlan(coreCompetencyApprovePlanRequest: CoreCompetencyApprovePlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyApprovePlan(coreCompetencyApprovePlanRequest: CoreCompetencyApprovePlanRequest, ): Observable<any> {

        if (coreCompetencyApprovePlanRequest === null || coreCompetencyApprovePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyApprovePlanRequest was null or undefined when calling coreCompetencyApprovePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_approve_plan`,
            coreCompetencyApprovePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log event competency framework viewed
     * Log event competency framework viewed
     * @param coreCompetencyCompetencyFrameworkViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCompetencyFrameworkViewed(coreCompetencyCompetencyFrameworkViewedRequest: CoreCompetencyCompetencyFrameworkViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCompetencyFrameworkViewed(coreCompetencyCompetencyFrameworkViewedRequest: CoreCompetencyCompetencyFrameworkViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyFrameworkViewedRequest === null || coreCompetencyCompetencyFrameworkViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyFrameworkViewedRequest was null or undefined when calling coreCompetencyCompetencyFrameworkViewed.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_competency_framework_viewed`,
            coreCompetencyCompetencyFrameworkViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log event competency viewed
     * Log event competency viewed
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCompetencyViewed(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCompetencyViewed(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyCompetencyViewed.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_competency_viewed`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Complete learning plan.
     * Complete learning plan.
     * @param coreCompetencyCompletePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCompletePlan(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCompletePlan(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<any> {

        if (coreCompetencyCompletePlanRequest === null || coreCompetencyCompletePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompletePlanRequest was null or undefined when calling coreCompetencyCompletePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_complete_plan`,
            coreCompetencyCompletePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count a list of a competencies.
     * Count a list of a competencies.
     * @param coreCompetencyCountCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCompetencies(coreCompetencyCountCompetenciesRequest: CoreCompetencyCountCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCompetencies(coreCompetencyCountCompetenciesRequest: CoreCompetencyCountCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesRequest === null || coreCompetencyCountCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesRequest was null or undefined when calling coreCompetencyCountCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_competencies`,
            coreCompetencyCountCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the competencies in a course
     * List the competencies in a course
     * @param coreCompetencyCountCompetenciesInCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCompetenciesInCourse(coreCompetencyCountCompetenciesInCourseRequest: CoreCompetencyCountCompetenciesInCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCompetenciesInCourse(coreCompetencyCountCompetenciesInCourseRequest: CoreCompetencyCountCompetenciesInCourseRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInCourseRequest === null || coreCompetencyCountCompetenciesInCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInCourseRequest was null or undefined when calling coreCompetencyCountCompetenciesInCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_competencies_in_course`,
            coreCompetencyCountCompetenciesInCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count a list of a competencies for a given template.
     * Count a list of a competencies for a given template.
     * @param coreCompetencyCountCompetenciesInTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCompetenciesInTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCompetenciesInTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInTemplateRequest === null || coreCompetencyCountCompetenciesInTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInTemplateRequest was null or undefined when calling coreCompetencyCountCompetenciesInTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_competencies_in_template`,
            coreCompetencyCountCompetenciesInTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count a list of a competency frameworks.
     * Count a list of a competency frameworks.
     * @param coreCompetencyCountCompetencyFrameworksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCompetencyFrameworks(coreCompetencyCountCompetencyFrameworksRequest: CoreCompetencyCountCompetencyFrameworksRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCompetencyFrameworks(coreCompetencyCountCompetencyFrameworksRequest: CoreCompetencyCountCompetencyFrameworksRequest, ): Observable<any> {

        if (coreCompetencyCountCompetencyFrameworksRequest === null || coreCompetencyCountCompetencyFrameworksRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetencyFrameworksRequest was null or undefined when calling coreCompetencyCountCompetencyFrameworks.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_competency_frameworks`,
            coreCompetencyCountCompetencyFrameworksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count the competencies in a course module
     * Count the competencies in a course module
     * @param coreCompetencyCountCourseModuleCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCourseModuleCompetencies(coreCompetencyCountCourseModuleCompetenciesRequest: CoreCompetencyCountCourseModuleCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCourseModuleCompetencies(coreCompetencyCountCourseModuleCompetenciesRequest: CoreCompetencyCountCourseModuleCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyCountCourseModuleCompetenciesRequest === null || coreCompetencyCountCourseModuleCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCourseModuleCompetenciesRequest was null or undefined when calling coreCompetencyCountCourseModuleCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_course_module_competencies`,
            coreCompetencyCountCourseModuleCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the courses using a competency
     * List the courses using a competency
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountCoursesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountCoursesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyCountCoursesUsingCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_courses_using_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count a list of a learning plan templates.
     * Count a list of a learning plan templates.
     * @param coreCompetencyCountCompetencyFrameworksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountTemplates(coreCompetencyCountCompetencyFrameworksRequest: CoreCompetencyCountCompetencyFrameworksRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountTemplates(coreCompetencyCountCompetencyFrameworksRequest: CoreCompetencyCountCompetencyFrameworksRequest, ): Observable<any> {

        if (coreCompetencyCountCompetencyFrameworksRequest === null || coreCompetencyCountCompetencyFrameworksRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetencyFrameworksRequest was null or undefined when calling coreCompetencyCountTemplates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_templates`,
            coreCompetencyCountCompetencyFrameworksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count a list of a learning plan templates for a given competency.
     * Count a list of a learning plan templates for a given competency.
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCountTemplatesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyCountTemplatesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyCountTemplatesUsingCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_count_templates_using_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new competencies.
     * Creates new competencies.
     * @param coreCompetencyCreateCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCreateCompetency(coreCompetencyCreateCompetencyRequest: CoreCompetencyCreateCompetencyRequest, ): Observable<AxiosResponse<CoreCompetencyCreateCompetency200Response>>;
    public coreCompetencyCreateCompetency(coreCompetencyCreateCompetencyRequest: CoreCompetencyCreateCompetencyRequest, ): Observable<any> {

        if (coreCompetencyCreateCompetencyRequest === null || coreCompetencyCreateCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCreateCompetencyRequest was null or undefined when calling coreCompetencyCreateCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateCompetency200Response>(`${this.basePath}/core_competency_create_competency`,
            coreCompetencyCreateCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new competency frameworks.
     * Creates new competency frameworks.
     * @param coreCompetencyCreateCompetencyFrameworkRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCreateCompetencyFramework(coreCompetencyCreateCompetencyFrameworkRequest: CoreCompetencyCreateCompetencyFrameworkRequest, ): Observable<AxiosResponse<CoreCompetencyCreateCompetencyFramework200Response>>;
    public coreCompetencyCreateCompetencyFramework(coreCompetencyCreateCompetencyFrameworkRequest: CoreCompetencyCreateCompetencyFrameworkRequest, ): Observable<any> {

        if (coreCompetencyCreateCompetencyFrameworkRequest === null || coreCompetencyCreateCompetencyFrameworkRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCreateCompetencyFrameworkRequest was null or undefined when calling coreCompetencyCreateCompetencyFramework.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateCompetencyFramework200Response>(`${this.basePath}/core_competency_create_competency_framework`,
            coreCompetencyCreateCompetencyFrameworkRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates a learning plan.
     * Creates a learning plan.
     * @param coreCompetencyCreatePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCreatePlan(coreCompetencyCreatePlanRequest: CoreCompetencyCreatePlanRequest, ): Observable<AxiosResponse<CoreCompetencyCreatePlan200Response>>;
    public coreCompetencyCreatePlan(coreCompetencyCreatePlanRequest: CoreCompetencyCreatePlanRequest, ): Observable<any> {

        if (coreCompetencyCreatePlanRequest === null || coreCompetencyCreatePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCreatePlanRequest was null or undefined when calling coreCompetencyCreatePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreatePlan200Response>(`${this.basePath}/core_competency_create_plan`,
            coreCompetencyCreatePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new learning plan templates.
     * Creates new learning plan templates.
     * @param coreCompetencyCreateTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCreateTemplate(coreCompetencyCreateTemplateRequest: CoreCompetencyCreateTemplateRequest, ): Observable<AxiosResponse<CoreCompetencyCreateTemplate200Response>>;
    public coreCompetencyCreateTemplate(coreCompetencyCreateTemplateRequest: CoreCompetencyCreateTemplateRequest, ): Observable<any> {

        if (coreCompetencyCreateTemplateRequest === null || coreCompetencyCreateTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCreateTemplateRequest was null or undefined when calling coreCompetencyCreateTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateTemplate200Response>(`${this.basePath}/core_competency_create_template`,
            coreCompetencyCreateTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create an evidence of prior learning relationship with a competency.
     * Create an evidence of prior learning relationship with a competency.
     * @param coreCompetencyCreateUserEvidenceCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyCreateUserEvidenceCompetency(coreCompetencyCreateUserEvidenceCompetencyRequest: CoreCompetencyCreateUserEvidenceCompetencyRequest, ): Observable<AxiosResponse<CoreCompetencyCreateUserEvidenceCompetency200Response>>;
    public coreCompetencyCreateUserEvidenceCompetency(coreCompetencyCreateUserEvidenceCompetencyRequest: CoreCompetencyCreateUserEvidenceCompetencyRequest, ): Observable<any> {

        if (coreCompetencyCreateUserEvidenceCompetencyRequest === null || coreCompetencyCreateUserEvidenceCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCreateUserEvidenceCompetencyRequest was null or undefined when calling coreCompetencyCreateUserEvidenceCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateUserEvidenceCompetency200Response>(`${this.basePath}/core_competency_create_user_evidence_competency`,
            coreCompetencyCreateUserEvidenceCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a competency.
     * Delete a competency.
     * @param coreCompetencyDeleteCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteCompetency(coreCompetencyDeleteCompetencyRequest: CoreCompetencyDeleteCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteCompetency(coreCompetencyDeleteCompetencyRequest: CoreCompetencyDeleteCompetencyRequest, ): Observable<any> {

        if (coreCompetencyDeleteCompetencyRequest === null || coreCompetencyDeleteCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteCompetencyRequest was null or undefined when calling coreCompetencyDeleteCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_competency`,
            coreCompetencyDeleteCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a competency framework.
     * Delete a competency framework.
     * @param coreCompetencyDeleteCompetencyFrameworkRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteCompetencyFramework(coreCompetencyDeleteCompetencyFrameworkRequest: CoreCompetencyDeleteCompetencyFrameworkRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteCompetencyFramework(coreCompetencyDeleteCompetencyFrameworkRequest: CoreCompetencyDeleteCompetencyFrameworkRequest, ): Observable<any> {

        if (coreCompetencyDeleteCompetencyFrameworkRequest === null || coreCompetencyDeleteCompetencyFrameworkRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteCompetencyFrameworkRequest was null or undefined when calling coreCompetencyDeleteCompetencyFramework.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_competency_framework`,
            coreCompetencyDeleteCompetencyFrameworkRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete an evidence
     * Delete an evidence
     * @param coreCompetencyDeleteEvidenceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteEvidence(coreCompetencyDeleteEvidenceRequest: CoreCompetencyDeleteEvidenceRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteEvidence(coreCompetencyDeleteEvidenceRequest: CoreCompetencyDeleteEvidenceRequest, ): Observable<any> {

        if (coreCompetencyDeleteEvidenceRequest === null || coreCompetencyDeleteEvidenceRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteEvidenceRequest was null or undefined when calling coreCompetencyDeleteEvidence.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_evidence`,
            coreCompetencyDeleteEvidenceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a learning plan.
     * Delete a learning plan.
     * @param coreCompetencyDeletePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeletePlan(coreCompetencyDeletePlanRequest: CoreCompetencyDeletePlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeletePlan(coreCompetencyDeletePlanRequest: CoreCompetencyDeletePlanRequest, ): Observable<any> {

        if (coreCompetencyDeletePlanRequest === null || coreCompetencyDeletePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeletePlanRequest was null or undefined when calling coreCompetencyDeletePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_plan`,
            coreCompetencyDeletePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a learning plan template.
     * Delete a learning plan template.
     * @param coreCompetencyDeleteTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteTemplate(coreCompetencyDeleteTemplateRequest: CoreCompetencyDeleteTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteTemplate(coreCompetencyDeleteTemplateRequest: CoreCompetencyDeleteTemplateRequest, ): Observable<any> {

        if (coreCompetencyDeleteTemplateRequest === null || coreCompetencyDeleteTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteTemplateRequest was null or undefined when calling coreCompetencyDeleteTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_template`,
            coreCompetencyDeleteTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete an evidence of prior learning.
     * Delete an evidence of prior learning.
     * @param coreCompetencyDeleteUserEvidenceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteUserEvidence(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteUserEvidence(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<any> {

        if (coreCompetencyDeleteUserEvidenceRequest === null || coreCompetencyDeleteUserEvidenceRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteUserEvidenceRequest was null or undefined when calling coreCompetencyDeleteUserEvidence.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_user_evidence`,
            coreCompetencyDeleteUserEvidenceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete an evidence of prior learning relationship with a competency.
     * Delete an evidence of prior learning relationship with a competency.
     * @param coreCompetencyDeleteUserEvidenceCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDeleteUserEvidenceCompetency(coreCompetencyDeleteUserEvidenceCompetencyRequest: CoreCompetencyDeleteUserEvidenceCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyDeleteUserEvidenceCompetency(coreCompetencyDeleteUserEvidenceCompetencyRequest: CoreCompetencyDeleteUserEvidenceCompetencyRequest, ): Observable<any> {

        if (coreCompetencyDeleteUserEvidenceCompetencyRequest === null || coreCompetencyDeleteUserEvidenceCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteUserEvidenceCompetencyRequest was null or undefined when calling coreCompetencyDeleteUserEvidenceCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_delete_user_evidence_competency`,
            coreCompetencyDeleteUserEvidenceCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Duplicate a competency framework.
     * Duplicate a competency framework.
     * @param coreCompetencyDuplicateCompetencyFrameworkRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDuplicateCompetencyFramework(coreCompetencyDuplicateCompetencyFrameworkRequest: CoreCompetencyDuplicateCompetencyFrameworkRequest, ): Observable<AxiosResponse<CoreCompetencyDuplicateCompetencyFramework200Response>>;
    public coreCompetencyDuplicateCompetencyFramework(coreCompetencyDuplicateCompetencyFrameworkRequest: CoreCompetencyDuplicateCompetencyFrameworkRequest, ): Observable<any> {

        if (coreCompetencyDuplicateCompetencyFrameworkRequest === null || coreCompetencyDuplicateCompetencyFrameworkRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDuplicateCompetencyFrameworkRequest was null or undefined when calling coreCompetencyDuplicateCompetencyFramework.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyDuplicateCompetencyFramework200Response>(`${this.basePath}/core_competency_duplicate_competency_framework`,
            coreCompetencyDuplicateCompetencyFrameworkRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Duplicate learning plan template.
     * Duplicate learning plan template.
     * @param coreCompetencyCountCompetenciesInTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyDuplicateTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<AxiosResponse<CoreCompetencyCreateTemplate200Response>>;
    public coreCompetencyDuplicateTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInTemplateRequest === null || coreCompetencyCountCompetenciesInTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInTemplateRequest was null or undefined when calling coreCompetencyDuplicateTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateTemplate200Response>(`${this.basePath}/core_competency_duplicate_template`,
            coreCompetencyCountCompetenciesInTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the values for a specific scale
     * Fetch the values for a specific scale
     * @param coreCompetencyGetScaleValuesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyGetScaleValues(coreCompetencyGetScaleValuesRequest: CoreCompetencyGetScaleValuesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyGetScaleValues(coreCompetencyGetScaleValuesRequest: CoreCompetencyGetScaleValuesRequest, ): Observable<any> {

        if (coreCompetencyGetScaleValuesRequest === null || coreCompetencyGetScaleValuesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyGetScaleValuesRequest was null or undefined when calling coreCompetencyGetScaleValues.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_get_scale_values`,
            coreCompetencyGetScaleValuesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Grade a competency.
     * Grade a competency.
     * @param coreCompetencyGradeCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyGradeCompetency(coreCompetencyGradeCompetencyRequest: CoreCompetencyGradeCompetencyRequest, ): Observable<AxiosResponse<CoreCompetencyGradeCompetency200Response>>;
    public coreCompetencyGradeCompetency(coreCompetencyGradeCompetencyRequest: CoreCompetencyGradeCompetencyRequest, ): Observable<any> {

        if (coreCompetencyGradeCompetencyRequest === null || coreCompetencyGradeCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyGradeCompetencyRequest was null or undefined when calling coreCompetencyGradeCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyGradeCompetency200Response>(`${this.basePath}/core_competency_grade_competency`,
            coreCompetencyGradeCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Grade a competency from the course page.
     * Grade a competency from the course page.
     * @param coreCompetencyGradeCompetencyInCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyGradeCompetencyInCourse(coreCompetencyGradeCompetencyInCourseRequest: CoreCompetencyGradeCompetencyInCourseRequest, ): Observable<AxiosResponse<CoreCompetencyGradeCompetencyInCourse200Response>>;
    public coreCompetencyGradeCompetencyInCourse(coreCompetencyGradeCompetencyInCourseRequest: CoreCompetencyGradeCompetencyInCourseRequest, ): Observable<any> {

        if (coreCompetencyGradeCompetencyInCourseRequest === null || coreCompetencyGradeCompetencyInCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyGradeCompetencyInCourseRequest was null or undefined when calling coreCompetencyGradeCompetencyInCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyGradeCompetencyInCourse200Response>(`${this.basePath}/core_competency_grade_competency_in_course`,
            coreCompetencyGradeCompetencyInCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Grade a competency from the user plan page.
     * Grade a competency from the user plan page.
     * @param coreCompetencyGradeCompetencyInPlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyGradeCompetencyInPlan(coreCompetencyGradeCompetencyInPlanRequest: CoreCompetencyGradeCompetencyInPlanRequest, ): Observable<AxiosResponse<CoreCompetencyGradeCompetencyInCourse200Response>>;
    public coreCompetencyGradeCompetencyInPlan(coreCompetencyGradeCompetencyInPlanRequest: CoreCompetencyGradeCompetencyInPlanRequest, ): Observable<any> {

        if (coreCompetencyGradeCompetencyInPlanRequest === null || coreCompetencyGradeCompetencyInPlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyGradeCompetencyInPlanRequest was null or undefined when calling coreCompetencyGradeCompetencyInPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyGradeCompetencyInCourse200Response>(`${this.basePath}/core_competency_grade_competency_in_plan`,
            coreCompetencyGradeCompetencyInPlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a list of a competencies.
     * Load a list of a competencies.
     * @param coreCompetencyListCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListCompetencies(coreCompetencyListCompetenciesRequest: CoreCompetencyListCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListCompetencies(coreCompetencyListCompetenciesRequest: CoreCompetencyListCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyListCompetenciesRequest === null || coreCompetencyListCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListCompetenciesRequest was null or undefined when calling coreCompetencyListCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_competencies`,
            coreCompetencyListCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a list of a competencies for a given template.
     * Load a list of a competencies for a given template.
     * @param coreCompetencyCountCompetenciesInTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListCompetenciesInTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListCompetenciesInTemplate(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInTemplateRequest === null || coreCompetencyCountCompetenciesInTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInTemplateRequest was null or undefined when calling coreCompetencyListCompetenciesInTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_competencies_in_template`,
            coreCompetencyCountCompetenciesInTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a list of a competency frameworks.
     * Load a list of a competency frameworks.
     * @param coreCompetencyListCompetencyFrameworksRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListCompetencyFrameworks(coreCompetencyListCompetencyFrameworksRequest: CoreCompetencyListCompetencyFrameworksRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListCompetencyFrameworks(coreCompetencyListCompetencyFrameworksRequest: CoreCompetencyListCompetencyFrameworksRequest, ): Observable<any> {

        if (coreCompetencyListCompetencyFrameworksRequest === null || coreCompetencyListCompetencyFrameworksRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListCompetencyFrameworksRequest was null or undefined when calling coreCompetencyListCompetencyFrameworks.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_competency_frameworks`,
            coreCompetencyListCompetencyFrameworksRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the competencies in a course
     * List the competencies in a course
     * @param coreCompetencyCountCompetenciesInCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListCourseCompetencies(coreCompetencyCountCompetenciesInCourseRequest: CoreCompetencyCountCompetenciesInCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListCourseCompetencies(coreCompetencyCountCompetenciesInCourseRequest: CoreCompetencyCountCompetenciesInCourseRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInCourseRequest === null || coreCompetencyCountCompetenciesInCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInCourseRequest was null or undefined when calling coreCompetencyListCourseCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_course_competencies`,
            coreCompetencyCountCompetenciesInCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the competencies in a course module
     * List the competencies in a course module
     * @param coreCompetencyListCourseModuleCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListCourseModuleCompetencies(coreCompetencyListCourseModuleCompetenciesRequest: CoreCompetencyListCourseModuleCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListCourseModuleCompetencies(coreCompetencyListCourseModuleCompetenciesRequest: CoreCompetencyListCourseModuleCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyListCourseModuleCompetenciesRequest === null || coreCompetencyListCourseModuleCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListCourseModuleCompetenciesRequest was null or undefined when calling coreCompetencyListCourseModuleCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_course_module_competencies`,
            coreCompetencyListCourseModuleCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List the competencies in a plan
     * List the competencies in a plan
     * @param coreCompetencyListPlanCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListPlanCompetencies(coreCompetencyListPlanCompetenciesRequest: CoreCompetencyListPlanCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListPlanCompetencies(coreCompetencyListPlanCompetenciesRequest: CoreCompetencyListPlanCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyListPlanCompetenciesRequest === null || coreCompetencyListPlanCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListPlanCompetenciesRequest was null or undefined when calling coreCompetencyListPlanCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_plan_competencies`,
            coreCompetencyListPlanCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a list of a learning plan templates.
     * Load a list of a learning plan templates.
     * @param coreCompetencyListTemplatesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListTemplates(coreCompetencyListTemplatesRequest: CoreCompetencyListTemplatesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListTemplates(coreCompetencyListTemplatesRequest: CoreCompetencyListTemplatesRequest, ): Observable<any> {

        if (coreCompetencyListTemplatesRequest === null || coreCompetencyListTemplatesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListTemplatesRequest was null or undefined when calling coreCompetencyListTemplates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_templates`,
            coreCompetencyListTemplatesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a list of a learning plan templates for a given competency.
     * Load a list of a learning plan templates for a given competency.
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListTemplatesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListTemplatesUsingCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyListTemplatesUsingCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_templates_using_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List a user\&#39;s learning plans.
     * List a user\&#39;s learning plans.
     * @param coreCompetencyListUserPlansRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyListUserPlans(coreCompetencyListUserPlansRequest: CoreCompetencyListUserPlansRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyListUserPlans(coreCompetencyListUserPlansRequest: CoreCompetencyListUserPlansRequest, ): Observable<any> {

        if (coreCompetencyListUserPlansRequest === null || coreCompetencyListUserPlansRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListUserPlansRequest was null or undefined when calling coreCompetencyListUserPlans.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_list_user_plans`,
            coreCompetencyListUserPlansRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order a competency.
     * Re-order a competency.
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyMoveDownCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyMoveDownCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyMoveDownCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_move_down_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order a competency.
     * Re-order a competency.
     * @param coreCompetencyCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyMoveUpCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyMoveUpCompetency(coreCompetencyCompetencyViewedRequest: CoreCompetencyCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyCompetencyViewedRequest === null || coreCompetencyCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompetencyViewedRequest was null or undefined when calling coreCompetencyMoveUpCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_move_up_competency`,
            coreCompetencyCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Cancel the review of a plan.
     * Cancel the review of a plan.
     * @param coreCompetencyPlanCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyPlanCancelReviewRequest(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyPlanCancelReviewRequest(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyPlanCancelReviewRequestRequest === null || coreCompetencyPlanCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyPlanCancelReviewRequestRequest was null or undefined when calling coreCompetencyPlanCancelReviewRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_plan_cancel_review_request`,
            coreCompetencyPlanCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Request for a plan to be reviewed.
     * Request for a plan to be reviewed.
     * @param coreCompetencyPlanCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyPlanRequestReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyPlanRequestReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyPlanCancelReviewRequestRequest === null || coreCompetencyPlanCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyPlanCancelReviewRequestRequest was null or undefined when calling coreCompetencyPlanRequestReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_plan_request_review`,
            coreCompetencyPlanCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Start the review of a plan.
     * Start the review of a plan.
     * @param coreCompetencyPlanCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyPlanStartReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyPlanStartReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyPlanCancelReviewRequestRequest === null || coreCompetencyPlanCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyPlanCancelReviewRequestRequest was null or undefined when calling coreCompetencyPlanStartReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_plan_start_review`,
            coreCompetencyPlanCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Stop the review of a plan.
     * Stop the review of a plan.
     * @param coreCompetencyPlanCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyPlanStopReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyPlanStopReview(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyPlanCancelReviewRequestRequest === null || coreCompetencyPlanCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyPlanCancelReviewRequestRequest was null or undefined when calling coreCompetencyPlanStopReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_plan_stop_review`,
            coreCompetencyPlanCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a competency.
     * Load a summary of a competency.
     * @param coreCompetencyReadCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReadCompetency(coreCompetencyReadCompetencyRequest: CoreCompetencyReadCompetencyRequest, ): Observable<AxiosResponse<CoreCompetencyCreateCompetency200Response>>;
    public coreCompetencyReadCompetency(coreCompetencyReadCompetencyRequest: CoreCompetencyReadCompetencyRequest, ): Observable<any> {

        if (coreCompetencyReadCompetencyRequest === null || coreCompetencyReadCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReadCompetencyRequest was null or undefined when calling coreCompetencyReadCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateCompetency200Response>(`${this.basePath}/core_competency_read_competency`,
            coreCompetencyReadCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a competency framework.
     * Load a summary of a competency framework.
     * @param coreCompetencyDuplicateCompetencyFrameworkRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReadCompetencyFramework(coreCompetencyDuplicateCompetencyFrameworkRequest: CoreCompetencyDuplicateCompetencyFrameworkRequest, ): Observable<AxiosResponse<CoreCompetencyDuplicateCompetencyFramework200Response>>;
    public coreCompetencyReadCompetencyFramework(coreCompetencyDuplicateCompetencyFrameworkRequest: CoreCompetencyDuplicateCompetencyFrameworkRequest, ): Observable<any> {

        if (coreCompetencyDuplicateCompetencyFrameworkRequest === null || coreCompetencyDuplicateCompetencyFrameworkRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDuplicateCompetencyFrameworkRequest was null or undefined when calling coreCompetencyReadCompetencyFramework.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyDuplicateCompetencyFramework200Response>(`${this.basePath}/core_competency_read_competency_framework`,
            coreCompetencyDuplicateCompetencyFrameworkRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a learning plan.
     * Load a learning plan.
     * @param coreCompetencyReadPlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReadPlan(coreCompetencyReadPlanRequest: CoreCompetencyReadPlanRequest, ): Observable<AxiosResponse<CoreCompetencyReadPlan200Response>>;
    public coreCompetencyReadPlan(coreCompetencyReadPlanRequest: CoreCompetencyReadPlanRequest, ): Observable<any> {

        if (coreCompetencyReadPlanRequest === null || coreCompetencyReadPlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReadPlanRequest was null or undefined when calling coreCompetencyReadPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyReadPlan200Response>(`${this.basePath}/core_competency_read_plan`,
            coreCompetencyReadPlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a summary of a learning plan template.
     * Load a summary of a learning plan template.
     * @param coreCompetencyReadTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReadTemplate(coreCompetencyReadTemplateRequest: CoreCompetencyReadTemplateRequest, ): Observable<AxiosResponse<CoreCompetencyCreateTemplate200Response>>;
    public coreCompetencyReadTemplate(coreCompetencyReadTemplateRequest: CoreCompetencyReadTemplateRequest, ): Observable<any> {

        if (coreCompetencyReadTemplateRequest === null || coreCompetencyReadTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReadTemplateRequest was null or undefined when calling coreCompetencyReadTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyCreateTemplate200Response>(`${this.basePath}/core_competency_read_template`,
            coreCompetencyReadTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Read an evidence of prior learning.
     * Read an evidence of prior learning.
     * @param coreCompetencyDeleteUserEvidenceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReadUserEvidence(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<AxiosResponse<CoreCompetencyReadUserEvidence200Response>>;
    public coreCompetencyReadUserEvidence(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<any> {

        if (coreCompetencyDeleteUserEvidenceRequest === null || coreCompetencyDeleteUserEvidenceRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteUserEvidenceRequest was null or undefined when calling coreCompetencyReadUserEvidence.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyReadUserEvidence200Response>(`${this.basePath}/core_competency_read_user_evidence`,
            coreCompetencyDeleteUserEvidenceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove a competency from a course
     * Remove a competency from a course
     * @param coreCompetencyRemoveCompetencyFromCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyRemoveCompetencyFromCourse(coreCompetencyRemoveCompetencyFromCourseRequest: CoreCompetencyRemoveCompetencyFromCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyRemoveCompetencyFromCourse(coreCompetencyRemoveCompetencyFromCourseRequest: CoreCompetencyRemoveCompetencyFromCourseRequest, ): Observable<any> {

        if (coreCompetencyRemoveCompetencyFromCourseRequest === null || coreCompetencyRemoveCompetencyFromCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyRemoveCompetencyFromCourseRequest was null or undefined when calling coreCompetencyRemoveCompetencyFromCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_remove_competency_from_course`,
            coreCompetencyRemoveCompetencyFromCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove the competency from a learning plan
     * Remove the competency from a learning plan
     * @param coreCompetencyRemoveCompetencyFromPlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyRemoveCompetencyFromPlan(coreCompetencyRemoveCompetencyFromPlanRequest: CoreCompetencyRemoveCompetencyFromPlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyRemoveCompetencyFromPlan(coreCompetencyRemoveCompetencyFromPlanRequest: CoreCompetencyRemoveCompetencyFromPlanRequest, ): Observable<any> {

        if (coreCompetencyRemoveCompetencyFromPlanRequest === null || coreCompetencyRemoveCompetencyFromPlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyRemoveCompetencyFromPlanRequest was null or undefined when calling coreCompetencyRemoveCompetencyFromPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_remove_competency_from_plan`,
            coreCompetencyRemoveCompetencyFromPlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove a competency from a template
     * Remove a competency from a template
     * @param coreCompetencyRemoveCompetencyFromTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyRemoveCompetencyFromTemplate(coreCompetencyRemoveCompetencyFromTemplateRequest: CoreCompetencyRemoveCompetencyFromTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyRemoveCompetencyFromTemplate(coreCompetencyRemoveCompetencyFromTemplateRequest: CoreCompetencyRemoveCompetencyFromTemplateRequest, ): Observable<any> {

        if (coreCompetencyRemoveCompetencyFromTemplateRequest === null || coreCompetencyRemoveCompetencyFromTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyRemoveCompetencyFromTemplateRequest was null or undefined when calling coreCompetencyRemoveCompetencyFromTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_remove_competency_from_template`,
            coreCompetencyRemoveCompetencyFromTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove a related competency
     * Remove a related competency
     * @param coreCompetencyRemoveRelatedCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyRemoveRelatedCompetency(coreCompetencyRemoveRelatedCompetencyRequest: CoreCompetencyRemoveRelatedCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyRemoveRelatedCompetency(coreCompetencyRemoveRelatedCompetencyRequest: CoreCompetencyRemoveRelatedCompetencyRequest, ): Observable<any> {

        if (coreCompetencyRemoveRelatedCompetencyRequest === null || coreCompetencyRemoveRelatedCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyRemoveRelatedCompetencyRequest was null or undefined when calling coreCompetencyRemoveRelatedCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_remove_related_competency`,
            coreCompetencyRemoveRelatedCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Reopen learning plan.
     * Reopen learning plan.
     * @param coreCompetencyCompletePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReopenPlan(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyReopenPlan(coreCompetencyCompletePlanRequest: CoreCompetencyCompletePlanRequest, ): Observable<any> {

        if (coreCompetencyCompletePlanRequest === null || coreCompetencyCompletePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCompletePlanRequest was null or undefined when calling coreCompetencyReopenPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_reopen_plan`,
            coreCompetencyCompletePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Move a course competency to a new relative sort order.
     * Move a course competency to a new relative sort order.
     * @param coreCompetencyReorderCourseCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReorderCourseCompetency(coreCompetencyReorderCourseCompetencyRequest: CoreCompetencyReorderCourseCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyReorderCourseCompetency(coreCompetencyReorderCourseCompetencyRequest: CoreCompetencyReorderCourseCompetencyRequest, ): Observable<any> {

        if (coreCompetencyReorderCourseCompetencyRequest === null || coreCompetencyReorderCourseCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReorderCourseCompetencyRequest was null or undefined when calling coreCompetencyReorderCourseCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_reorder_course_competency`,
            coreCompetencyReorderCourseCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Move a plan competency to a new relative sort order.
     * Move a plan competency to a new relative sort order.
     * @param coreCompetencyReorderPlanCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReorderPlanCompetency(coreCompetencyReorderPlanCompetencyRequest: CoreCompetencyReorderPlanCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyReorderPlanCompetency(coreCompetencyReorderPlanCompetencyRequest: CoreCompetencyReorderPlanCompetencyRequest, ): Observable<any> {

        if (coreCompetencyReorderPlanCompetencyRequest === null || coreCompetencyReorderPlanCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReorderPlanCompetencyRequest was null or undefined when calling coreCompetencyReorderPlanCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_reorder_plan_competency`,
            coreCompetencyReorderPlanCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Move a template competency to a new relative sort order.
     * Move a template competency to a new relative sort order.
     * @param coreCompetencyReorderTemplateCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyReorderTemplateCompetency(coreCompetencyReorderTemplateCompetencyRequest: CoreCompetencyReorderTemplateCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyReorderTemplateCompetency(coreCompetencyReorderTemplateCompetencyRequest: CoreCompetencyReorderTemplateCompetencyRequest, ): Observable<any> {

        if (coreCompetencyReorderTemplateCompetencyRequest === null || coreCompetencyReorderTemplateCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReorderTemplateCompetencyRequest was null or undefined when calling coreCompetencyReorderTemplateCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_reorder_template_competency`,
            coreCompetencyReorderTemplateCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send user evidence competencies in review
     * Send user evidence competencies in review
     * @param coreCompetencyDeleteUserEvidenceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyRequestReviewOfUserEvidenceLinkedCompetencies(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyRequestReviewOfUserEvidenceLinkedCompetencies(coreCompetencyDeleteUserEvidenceRequest: CoreCompetencyDeleteUserEvidenceRequest, ): Observable<any> {

        if (coreCompetencyDeleteUserEvidenceRequest === null || coreCompetencyDeleteUserEvidenceRequest === undefined) {
            throw new Error('Required parameter coreCompetencyDeleteUserEvidenceRequest was null or undefined when calling coreCompetencyRequestReviewOfUserEvidenceLinkedCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_request_review_of_user_evidence_linked_competencies`,
            coreCompetencyDeleteUserEvidenceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search a list of a competencies.
     * Search a list of a competencies.
     * @param coreCompetencySearchCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencySearchCompetencies(coreCompetencySearchCompetenciesRequest: CoreCompetencySearchCompetenciesRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencySearchCompetencies(coreCompetencySearchCompetenciesRequest: CoreCompetencySearchCompetenciesRequest, ): Observable<any> {

        if (coreCompetencySearchCompetenciesRequest === null || coreCompetencySearchCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencySearchCompetenciesRequest was null or undefined when calling coreCompetencySearchCompetencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_search_competencies`,
            coreCompetencySearchCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Modify the ruleoutcome value for course competency
     * Modify the ruleoutcome value for course competency
     * @param coreCompetencySetCourseCompetencyRuleoutcomeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencySetCourseCompetencyRuleoutcome(coreCompetencySetCourseCompetencyRuleoutcomeRequest: CoreCompetencySetCourseCompetencyRuleoutcomeRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencySetCourseCompetencyRuleoutcome(coreCompetencySetCourseCompetencyRuleoutcomeRequest: CoreCompetencySetCourseCompetencyRuleoutcomeRequest, ): Observable<any> {

        if (coreCompetencySetCourseCompetencyRuleoutcomeRequest === null || coreCompetencySetCourseCompetencyRuleoutcomeRequest === undefined) {
            throw new Error('Required parameter coreCompetencySetCourseCompetencyRuleoutcomeRequest was null or undefined when calling coreCompetencySetCourseCompetencyRuleoutcome.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_set_course_competency_ruleoutcome`,
            coreCompetencySetCourseCompetencyRuleoutcomeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set a new parent for a competency.
     * Set a new parent for a competency.
     * @param coreCompetencySetParentCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencySetParentCompetency(coreCompetencySetParentCompetencyRequest: CoreCompetencySetParentCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencySetParentCompetency(coreCompetencySetParentCompetencyRequest: CoreCompetencySetParentCompetencyRequest, ): Observable<any> {

        if (coreCompetencySetParentCompetencyRequest === null || coreCompetencySetParentCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencySetParentCompetencyRequest was null or undefined when calling coreCompetencySetParentCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_set_parent_competency`,
            coreCompetencySetParentCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Check if a template has related data
     * Check if a template has related data
     * @param coreCompetencyCountCompetenciesInTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyTemplateHasRelatedData(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyTemplateHasRelatedData(coreCompetencyCountCompetenciesInTemplateRequest: CoreCompetencyCountCompetenciesInTemplateRequest, ): Observable<any> {

        if (coreCompetencyCountCompetenciesInTemplateRequest === null || coreCompetencyCountCompetenciesInTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyCountCompetenciesInTemplateRequest was null or undefined when calling coreCompetencyTemplateHasRelatedData.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_template_has_related_data`,
            coreCompetencyCountCompetenciesInTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log event template viewed
     * Log event template viewed
     * @param coreCompetencyReadTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyTemplateViewed(coreCompetencyReadTemplateRequest: CoreCompetencyReadTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyTemplateViewed(coreCompetencyReadTemplateRequest: CoreCompetencyReadTemplateRequest, ): Observable<any> {

        if (coreCompetencyReadTemplateRequest === null || coreCompetencyReadTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyReadTemplateRequest was null or undefined when calling coreCompetencyTemplateViewed.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_template_viewed`,
            coreCompetencyReadTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unapprove a plan.
     * Unapprove a plan.
     * @param coreCompetencyPlanCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUnapprovePlan(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUnapprovePlan(coreCompetencyPlanCancelReviewRequestRequest: CoreCompetencyPlanCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyPlanCancelReviewRequestRequest === null || coreCompetencyPlanCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyPlanCancelReviewRequestRequest was null or undefined when calling coreCompetencyUnapprovePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_unapprove_plan`,
            coreCompetencyPlanCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unlink a plan form it template.
     * Unlink a plan form it template.
     * @param coreCompetencyUnlinkPlanFromTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUnlinkPlanFromTemplate(coreCompetencyUnlinkPlanFromTemplateRequest: CoreCompetencyUnlinkPlanFromTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUnlinkPlanFromTemplate(coreCompetencyUnlinkPlanFromTemplateRequest: CoreCompetencyUnlinkPlanFromTemplateRequest, ): Observable<any> {

        if (coreCompetencyUnlinkPlanFromTemplateRequest === null || coreCompetencyUnlinkPlanFromTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUnlinkPlanFromTemplateRequest was null or undefined when calling coreCompetencyUnlinkPlanFromTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_unlink_plan_from_template`,
            coreCompetencyUnlinkPlanFromTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a competency.
     * Update a competency.
     * @param coreCompetencyUpdateCompetencyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUpdateCompetency(coreCompetencyUpdateCompetencyRequest: CoreCompetencyUpdateCompetencyRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUpdateCompetency(coreCompetencyUpdateCompetencyRequest: CoreCompetencyUpdateCompetencyRequest, ): Observable<any> {

        if (coreCompetencyUpdateCompetencyRequest === null || coreCompetencyUpdateCompetencyRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUpdateCompetencyRequest was null or undefined when calling coreCompetencyUpdateCompetency.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_update_competency`,
            coreCompetencyUpdateCompetencyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a competency framework.
     * Update a competency framework.
     * @param coreCompetencyUpdateCompetencyFrameworkRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUpdateCompetencyFramework(coreCompetencyUpdateCompetencyFrameworkRequest: CoreCompetencyUpdateCompetencyFrameworkRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUpdateCompetencyFramework(coreCompetencyUpdateCompetencyFrameworkRequest: CoreCompetencyUpdateCompetencyFrameworkRequest, ): Observable<any> {

        if (coreCompetencyUpdateCompetencyFrameworkRequest === null || coreCompetencyUpdateCompetencyFrameworkRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUpdateCompetencyFrameworkRequest was null or undefined when calling coreCompetencyUpdateCompetencyFramework.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_update_competency_framework`,
            coreCompetencyUpdateCompetencyFrameworkRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update the course competency settings
     * Update the course competency settings
     * @param coreCompetencyUpdateCourseCompetencySettingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUpdateCourseCompetencySettings(coreCompetencyUpdateCourseCompetencySettingsRequest: CoreCompetencyUpdateCourseCompetencySettingsRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUpdateCourseCompetencySettings(coreCompetencyUpdateCourseCompetencySettingsRequest: CoreCompetencyUpdateCourseCompetencySettingsRequest, ): Observable<any> {

        if (coreCompetencyUpdateCourseCompetencySettingsRequest === null || coreCompetencyUpdateCourseCompetencySettingsRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUpdateCourseCompetencySettingsRequest was null or undefined when calling coreCompetencyUpdateCourseCompetencySettings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_update_course_competency_settings`,
            coreCompetencyUpdateCourseCompetencySettingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Updates a learning plan.
     * Updates a learning plan.
     * @param coreCompetencyUpdatePlanRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUpdatePlan(coreCompetencyUpdatePlanRequest: CoreCompetencyUpdatePlanRequest, ): Observable<AxiosResponse<CoreCompetencyReadPlan200Response>>;
    public coreCompetencyUpdatePlan(coreCompetencyUpdatePlanRequest: CoreCompetencyUpdatePlanRequest, ): Observable<any> {

        if (coreCompetencyUpdatePlanRequest === null || coreCompetencyUpdatePlanRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUpdatePlanRequest was null or undefined when calling coreCompetencyUpdatePlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompetencyReadPlan200Response>(`${this.basePath}/core_competency_update_plan`,
            coreCompetencyUpdatePlanRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a learning plan template.
     * Update a learning plan template.
     * @param coreCompetencyUpdateTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUpdateTemplate(coreCompetencyUpdateTemplateRequest: CoreCompetencyUpdateTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUpdateTemplate(coreCompetencyUpdateTemplateRequest: CoreCompetencyUpdateTemplateRequest, ): Observable<any> {

        if (coreCompetencyUpdateTemplateRequest === null || coreCompetencyUpdateTemplateRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUpdateTemplateRequest was null or undefined when calling coreCompetencyUpdateTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_update_template`,
            coreCompetencyUpdateTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Cancel a review request.
     * Cancel a review request.
     * @param coreCompetencyUserCompetencyCancelReviewRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyCancelReviewRequest(coreCompetencyUserCompetencyCancelReviewRequestRequest: CoreCompetencyUserCompetencyCancelReviewRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyCancelReviewRequest(coreCompetencyUserCompetencyCancelReviewRequestRequest: CoreCompetencyUserCompetencyCancelReviewRequestRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyCancelReviewRequestRequest === null || coreCompetencyUserCompetencyCancelReviewRequestRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyCancelReviewRequestRequest was null or undefined when calling coreCompetencyUserCompetencyCancelReviewRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_cancel_review_request`,
            coreCompetencyUserCompetencyCancelReviewRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log the user competency plan viewed event.
     * Log the user competency plan viewed event.
     * @param coreCompetencyUserCompetencyPlanViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyPlanViewed(coreCompetencyUserCompetencyPlanViewedRequest: CoreCompetencyUserCompetencyPlanViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyPlanViewed(coreCompetencyUserCompetencyPlanViewedRequest: CoreCompetencyUserCompetencyPlanViewedRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyPlanViewedRequest === null || coreCompetencyUserCompetencyPlanViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyPlanViewedRequest was null or undefined when calling coreCompetencyUserCompetencyPlanViewed.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_plan_viewed`,
            coreCompetencyUserCompetencyPlanViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Request a review.
     * Request a review.
     * @param coreCompetencyUserCompetencyRequestReviewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyRequestReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyRequestReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyRequestReviewRequest === null || coreCompetencyUserCompetencyRequestReviewRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyRequestReviewRequest was null or undefined when calling coreCompetencyUserCompetencyRequestReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_request_review`,
            coreCompetencyUserCompetencyRequestReviewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Start a review.
     * Start a review.
     * @param coreCompetencyUserCompetencyRequestReviewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyStartReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyStartReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyRequestReviewRequest === null || coreCompetencyUserCompetencyRequestReviewRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyRequestReviewRequest was null or undefined when calling coreCompetencyUserCompetencyStartReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_start_review`,
            coreCompetencyUserCompetencyRequestReviewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Stop a review.
     * Stop a review.
     * @param coreCompetencyUserCompetencyRequestReviewRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyStopReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyStopReview(coreCompetencyUserCompetencyRequestReviewRequest: CoreCompetencyUserCompetencyRequestReviewRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyRequestReviewRequest === null || coreCompetencyUserCompetencyRequestReviewRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyRequestReviewRequest was null or undefined when calling coreCompetencyUserCompetencyStopReview.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_stop_review`,
            coreCompetencyUserCompetencyRequestReviewRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log the user competency viewed event.
     * Log the user competency viewed event.
     * @param coreCompetencyUserCompetencyViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyViewed(coreCompetencyUserCompetencyViewedRequest: CoreCompetencyUserCompetencyViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyViewed(coreCompetencyUserCompetencyViewedRequest: CoreCompetencyUserCompetencyViewedRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyViewedRequest === null || coreCompetencyUserCompetencyViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyViewedRequest was null or undefined when calling coreCompetencyUserCompetencyViewed.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_viewed`,
            coreCompetencyUserCompetencyViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log the user competency viewed in course event
     * Log the user competency viewed in course event
     * @param coreCompetencyUserCompetencyViewedInCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyViewedInCourse(coreCompetencyUserCompetencyViewedInCourseRequest: CoreCompetencyUserCompetencyViewedInCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyViewedInCourse(coreCompetencyUserCompetencyViewedInCourseRequest: CoreCompetencyUserCompetencyViewedInCourseRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyViewedInCourseRequest === null || coreCompetencyUserCompetencyViewedInCourseRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyViewedInCourseRequest was null or undefined when calling coreCompetencyUserCompetencyViewedInCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_viewed_in_course`,
            coreCompetencyUserCompetencyViewedInCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log the user competency viewed in plan event.
     * Log the user competency viewed in plan event.
     * @param coreCompetencyUserCompetencyPlanViewedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompetencyUserCompetencyViewedInPlan(coreCompetencyUserCompetencyPlanViewedRequest: CoreCompetencyUserCompetencyPlanViewedRequest, ): Observable<AxiosResponse<object>>;
    public coreCompetencyUserCompetencyViewedInPlan(coreCompetencyUserCompetencyPlanViewedRequest: CoreCompetencyUserCompetencyPlanViewedRequest, ): Observable<any> {

        if (coreCompetencyUserCompetencyPlanViewedRequest === null || coreCompetencyUserCompetencyPlanViewedRequest === undefined) {
            throw new Error('Required parameter coreCompetencyUserCompetencyPlanViewedRequest was null or undefined when calling coreCompetencyUserCompetencyViewedInPlan.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_competency_user_competency_viewed_in_plan`,
            coreCompetencyUserCompetencyPlanViewedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return the activities completion status for a user in a course.
     * Return the activities completion status for a user in a course.
     * @param coreCompletionGetActivitiesCompletionStatusRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompletionGetActivitiesCompletionStatus(coreCompletionGetActivitiesCompletionStatusRequest: CoreCompletionGetActivitiesCompletionStatusRequest, ): Observable<AxiosResponse<CoreCompletionGetActivitiesCompletionStatus200Response>>;
    public coreCompletionGetActivitiesCompletionStatus(coreCompletionGetActivitiesCompletionStatusRequest: CoreCompletionGetActivitiesCompletionStatusRequest, ): Observable<any> {

        if (coreCompletionGetActivitiesCompletionStatusRequest === null || coreCompletionGetActivitiesCompletionStatusRequest === undefined) {
            throw new Error('Required parameter coreCompletionGetActivitiesCompletionStatusRequest was null or undefined when calling coreCompletionGetActivitiesCompletionStatus.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompletionGetActivitiesCompletionStatus200Response>(`${this.basePath}/core_completion_get_activities_completion_status`,
            coreCompletionGetActivitiesCompletionStatusRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns course completion status.
     * Returns course completion status.
     * @param coreCompletionGetActivitiesCompletionStatusRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompletionGetCourseCompletionStatus(coreCompletionGetActivitiesCompletionStatusRequest: CoreCompletionGetActivitiesCompletionStatusRequest, ): Observable<AxiosResponse<CoreCompletionGetCourseCompletionStatus200Response>>;
    public coreCompletionGetCourseCompletionStatus(coreCompletionGetActivitiesCompletionStatusRequest: CoreCompletionGetActivitiesCompletionStatusRequest, ): Observable<any> {

        if (coreCompletionGetActivitiesCompletionStatusRequest === null || coreCompletionGetActivitiesCompletionStatusRequest === undefined) {
            throw new Error('Required parameter coreCompletionGetActivitiesCompletionStatusRequest was null or undefined when calling coreCompletionGetCourseCompletionStatus.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompletionGetCourseCompletionStatus200Response>(`${this.basePath}/core_completion_get_course_completion_status`,
            coreCompletionGetActivitiesCompletionStatusRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update the course completion status for the current user (if course self-completion is enabled).
     * Update the course completion status for the current user (if course self-completion is enabled).
     * @param coreCompletionMarkCourseSelfCompletedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompletionMarkCourseSelfCompleted(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<AxiosResponse<CoreCompletionMarkCourseSelfCompleted200Response>>;
    public coreCompletionMarkCourseSelfCompleted(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<any> {

        if (coreCompletionMarkCourseSelfCompletedRequest === null || coreCompletionMarkCourseSelfCompletedRequest === undefined) {
            throw new Error('Required parameter coreCompletionMarkCourseSelfCompletedRequest was null or undefined when calling coreCompletionMarkCourseSelfCompleted.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompletionMarkCourseSelfCompleted200Response>(`${this.basePath}/core_completion_mark_course_self_completed`,
            coreCompletionMarkCourseSelfCompletedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update completion status for a user in an activity by overriding it.
     * Update completion status for a user in an activity by overriding it.
     * @param coreCompletionOverrideActivityCompletionStatusRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompletionOverrideActivityCompletionStatus(coreCompletionOverrideActivityCompletionStatusRequest: CoreCompletionOverrideActivityCompletionStatusRequest, ): Observable<AxiosResponse<CoreCompletionOverrideActivityCompletionStatus200Response>>;
    public coreCompletionOverrideActivityCompletionStatus(coreCompletionOverrideActivityCompletionStatusRequest: CoreCompletionOverrideActivityCompletionStatusRequest, ): Observable<any> {

        if (coreCompletionOverrideActivityCompletionStatusRequest === null || coreCompletionOverrideActivityCompletionStatusRequest === undefined) {
            throw new Error('Required parameter coreCompletionOverrideActivityCompletionStatusRequest was null or undefined when calling coreCompletionOverrideActivityCompletionStatus.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompletionOverrideActivityCompletionStatus200Response>(`${this.basePath}/core_completion_override_activity_completion_status`,
            coreCompletionOverrideActivityCompletionStatusRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update completion status for the current user in an activity, only for activities with manual tracking.
     * Update completion status for the current user in an activity, only for activities with manual tracking.
     * @param coreCompletionUpdateActivityCompletionStatusManuallyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCompletionUpdateActivityCompletionStatusManually(coreCompletionUpdateActivityCompletionStatusManuallyRequest: CoreCompletionUpdateActivityCompletionStatusManuallyRequest, ): Observable<AxiosResponse<CoreCompletionUpdateActivityCompletionStatusManually200Response>>;
    public coreCompletionUpdateActivityCompletionStatusManually(coreCompletionUpdateActivityCompletionStatusManuallyRequest: CoreCompletionUpdateActivityCompletionStatusManuallyRequest, ): Observable<any> {

        if (coreCompletionUpdateActivityCompletionStatusManuallyRequest === null || coreCompletionUpdateActivityCompletionStatusManuallyRequest === undefined) {
            throw new Error('Required parameter coreCompletionUpdateActivityCompletionStatusManuallyRequest was null or undefined when calling coreCompletionUpdateActivityCompletionStatusManually.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCompletionUpdateActivityCompletionStatusManually200Response>(`${this.basePath}/core_completion_update_activity_completion_status_manually`,
            coreCompletionUpdateActivityCompletionStatusManuallyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Copy a content in the content bank.
     * Copy a content in the content bank.
     * @param coreContentbankCopyContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreContentbankCopyContent(coreContentbankCopyContentRequest: CoreContentbankCopyContentRequest, ): Observable<AxiosResponse<CoreContentbankCopyContent200Response>>;
    public coreContentbankCopyContent(coreContentbankCopyContentRequest: CoreContentbankCopyContentRequest, ): Observable<any> {

        if (coreContentbankCopyContentRequest === null || coreContentbankCopyContentRequest === undefined) {
            throw new Error('Required parameter coreContentbankCopyContentRequest was null or undefined when calling coreContentbankCopyContent.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreContentbankCopyContent200Response>(`${this.basePath}/core_contentbank_copy_content`,
            coreContentbankCopyContentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete a content from the content bank.
     * Delete a content from the content bank.
     * @param coreContentbankDeleteContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreContentbankDeleteContent(coreContentbankDeleteContentRequest: CoreContentbankDeleteContentRequest, ): Observable<AxiosResponse<CoreContentbankDeleteContent200Response>>;
    public coreContentbankDeleteContent(coreContentbankDeleteContentRequest: CoreContentbankDeleteContentRequest, ): Observable<any> {

        if (coreContentbankDeleteContentRequest === null || coreContentbankDeleteContentRequest === undefined) {
            throw new Error('Required parameter coreContentbankDeleteContentRequest was null or undefined when calling coreContentbankDeleteContent.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreContentbankDeleteContent200Response>(`${this.basePath}/core_contentbank_delete_content`,
            coreContentbankDeleteContentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Rename a content in the content bank.
     * Rename a content in the content bank.
     * @param coreContentbankRenameContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreContentbankRenameContent(coreContentbankRenameContentRequest: CoreContentbankRenameContentRequest, ): Observable<AxiosResponse<CoreContentbankRenameContent200Response>>;
    public coreContentbankRenameContent(coreContentbankRenameContentRequest: CoreContentbankRenameContentRequest, ): Observable<any> {

        if (coreContentbankRenameContentRequest === null || coreContentbankRenameContentRequest === undefined) {
            throw new Error('Required parameter coreContentbankRenameContentRequest was null or undefined when calling coreContentbankRenameContent.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreContentbankRenameContent200Response>(`${this.basePath}/core_contentbank_rename_content`,
            coreContentbankRenameContentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set the visibility of a content in the content bank.
     * Set the visibility of a content in the content bank.
     * @param coreContentbankSetContentVisibilityRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreContentbankSetContentVisibility(coreContentbankSetContentVisibilityRequest: CoreContentbankSetContentVisibilityRequest, ): Observable<AxiosResponse<CoreContentbankRenameContent200Response>>;
    public coreContentbankSetContentVisibility(coreContentbankSetContentVisibilityRequest: CoreContentbankSetContentVisibilityRequest, ): Observable<any> {

        if (coreContentbankSetContentVisibilityRequest === null || coreContentbankSetContentVisibilityRequest === undefined) {
            throw new Error('Required parameter coreContentbankSetContentVisibilityRequest was null or undefined when calling coreContentbankSetContentVisibility.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreContentbankRenameContent200Response>(`${this.basePath}/core_contentbank_set_content_visibility`,
            coreContentbankSetContentVisibilityRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds a content item (activity, resource or their subtypes) to the favourites for the user.
     * Adds a content item (activity, resource or their subtypes) to the favourites for the user.
     * @param coreCourseAddContentItemToUserFavouritesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseAddContentItemToUserFavourites(coreCourseAddContentItemToUserFavouritesRequest: CoreCourseAddContentItemToUserFavouritesRequest, ): Observable<AxiosResponse<CoreCourseAddContentItemToUserFavourites200Response>>;
    public coreCourseAddContentItemToUserFavourites(coreCourseAddContentItemToUserFavouritesRequest: CoreCourseAddContentItemToUserFavouritesRequest, ): Observable<any> {

        if (coreCourseAddContentItemToUserFavouritesRequest === null || coreCourseAddContentItemToUserFavouritesRequest === undefined) {
            throw new Error('Required parameter coreCourseAddContentItemToUserFavouritesRequest was null or undefined when calling coreCourseAddContentItemToUserFavourites.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseAddContentItemToUserFavourites200Response>(`${this.basePath}/core_course_add_content_item_to_user_favourites`,
            coreCourseAddContentItemToUserFavouritesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Check if there is updates affecting the user for the given course and contexts.
     * Check if there is updates affecting the user for the given course and contexts.
     * @param coreCourseCheckUpdatesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseCheckUpdates(coreCourseCheckUpdatesRequest: CoreCourseCheckUpdatesRequest, ): Observable<AxiosResponse<CoreCourseCheckUpdates200Response>>;
    public coreCourseCheckUpdates(coreCourseCheckUpdatesRequest: CoreCourseCheckUpdatesRequest, ): Observable<any> {

        if (coreCourseCheckUpdatesRequest === null || coreCourseCheckUpdatesRequest === undefined) {
            throw new Error('Required parameter coreCourseCheckUpdatesRequest was null or undefined when calling coreCourseCheckUpdates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseCheckUpdates200Response>(`${this.basePath}/core_course_check_updates`,
            coreCourseCheckUpdatesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create course categories
     * Create course categories
     * @param coreCourseCreateCategoriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseCreateCategories(coreCourseCreateCategoriesRequest: CoreCourseCreateCategoriesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseCreateCategories(coreCourseCreateCategoriesRequest: CoreCourseCreateCategoriesRequest, ): Observable<any> {

        if (coreCourseCreateCategoriesRequest === null || coreCourseCreateCategoriesRequest === undefined) {
            throw new Error('Required parameter coreCourseCreateCategoriesRequest was null or undefined when calling coreCourseCreateCategories.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_create_categories`,
            coreCourseCreateCategoriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create new courses
     * Create new courses
     * @param coreCourseCreateCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseCreateCourses(coreCourseCreateCoursesRequest: CoreCourseCreateCoursesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseCreateCourses(coreCourseCreateCoursesRequest: CoreCourseCreateCoursesRequest, ): Observable<any> {

        if (coreCourseCreateCoursesRequest === null || coreCourseCreateCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseCreateCoursesRequest was null or undefined when calling coreCourseCreateCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_create_courses`,
            coreCourseCreateCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete course categories
     * Delete course categories
     * @param coreCourseDeleteCategoriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseDeleteCategories(coreCourseDeleteCategoriesRequest: CoreCourseDeleteCategoriesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseDeleteCategories(coreCourseDeleteCategoriesRequest: CoreCourseDeleteCategoriesRequest, ): Observable<any> {

        if (coreCourseDeleteCategoriesRequest === null || coreCourseDeleteCategoriesRequest === undefined) {
            throw new Error('Required parameter coreCourseDeleteCategoriesRequest was null or undefined when calling coreCourseDeleteCategories.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_delete_categories`,
            coreCourseDeleteCategoriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes all specified courses
     * Deletes all specified courses
     * @param coreCourseDeleteCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseDeleteCourses(coreCourseDeleteCoursesRequest: CoreCourseDeleteCoursesRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreCourseDeleteCourses(coreCourseDeleteCoursesRequest: CoreCourseDeleteCoursesRequest, ): Observable<any> {

        if (coreCourseDeleteCoursesRequest === null || coreCourseDeleteCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseDeleteCoursesRequest was null or undefined when calling coreCourseDeleteCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_course_delete_courses`,
            coreCourseDeleteCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes all specified module instances
     * Deletes all specified module instances
     * @param coreCourseDeleteModulesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseDeleteModules(coreCourseDeleteModulesRequest: CoreCourseDeleteModulesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseDeleteModules(coreCourseDeleteModulesRequest: CoreCourseDeleteModulesRequest, ): Observable<any> {

        if (coreCourseDeleteModulesRequest === null || coreCourseDeleteModulesRequest === undefined) {
            throw new Error('Required parameter coreCourseDeleteModulesRequest was null or undefined when calling coreCourseDeleteModules.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_delete_modules`,
            coreCourseDeleteModulesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Duplicate an existing course (creating a new one).
     * Duplicate an existing course (creating a new one).
     * @param coreCourseDuplicateCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseDuplicateCourse(coreCourseDuplicateCourseRequest: CoreCourseDuplicateCourseRequest, ): Observable<AxiosResponse<CoreCourseDuplicateCourse200Response>>;
    public coreCourseDuplicateCourse(coreCourseDuplicateCourseRequest: CoreCourseDuplicateCourseRequest, ): Observable<any> {

        if (coreCourseDuplicateCourseRequest === null || coreCourseDuplicateCourseRequest === undefined) {
            throw new Error('Required parameter coreCourseDuplicateCourseRequest was null or undefined when calling coreCourseDuplicateCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseDuplicateCourse200Response>(`${this.basePath}/core_course_duplicate_course`,
            coreCourseDuplicateCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Performs an action on course module (change visibility, duplicate, delete, etc.)
     * Performs an action on course module (change visibility, duplicate, delete, etc.)
     * @param coreCourseEditModuleRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseEditModule(coreCourseEditModuleRequest: CoreCourseEditModuleRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseEditModule(coreCourseEditModuleRequest: CoreCourseEditModuleRequest, ): Observable<any> {

        if (coreCourseEditModuleRequest === null || coreCourseEditModuleRequest === undefined) {
            throw new Error('Required parameter coreCourseEditModuleRequest was null or undefined when calling coreCourseEditModule.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_edit_module`,
            coreCourseEditModuleRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Performs an action on course section (change visibility, set marker, delete)
     * Performs an action on course section (change visibility, set marker, delete)
     * @param coreCourseEditSectionRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseEditSection(coreCourseEditSectionRequest: CoreCourseEditSectionRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseEditSection(coreCourseEditSectionRequest: CoreCourseEditSectionRequest, ): Observable<any> {

        if (coreCourseEditSectionRequest === null || coreCourseEditSectionRequest === undefined) {
            throw new Error('Required parameter coreCourseEditSectionRequest was null or undefined when calling coreCourseEditSection.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_edit_section`,
            coreCourseEditSectionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the data for the activity chooser footer.
     * Fetch the data for the activity chooser footer.
     * @param coreCourseGetActivityChooserFooterRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetActivityChooserFooter(coreCourseGetActivityChooserFooterRequest: CoreCourseGetActivityChooserFooterRequest, ): Observable<AxiosResponse<CoreCourseGetActivityChooserFooter200Response>>;
    public coreCourseGetActivityChooserFooter(coreCourseGetActivityChooserFooterRequest: CoreCourseGetActivityChooserFooterRequest, ): Observable<any> {

        if (coreCourseGetActivityChooserFooterRequest === null || coreCourseGetActivityChooserFooterRequest === undefined) {
            throw new Error('Required parameter coreCourseGetActivityChooserFooterRequest was null or undefined when calling coreCourseGetActivityChooserFooter.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetActivityChooserFooter200Response>(`${this.basePath}/core_course_get_activity_chooser_footer`,
            coreCourseGetActivityChooserFooterRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return category details
     * Return category details
     * @param coreCourseGetCategoriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCategories(coreCourseGetCategoriesRequest: CoreCourseGetCategoriesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseGetCategories(coreCourseGetCategoriesRequest: CoreCourseGetCategoriesRequest, ): Observable<any> {

        if (coreCourseGetCategoriesRequest === null || coreCourseGetCategoriesRequest === undefined) {
            throw new Error('Required parameter coreCourseGetCategoriesRequest was null or undefined when calling coreCourseGetCategories.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_get_categories`,
            coreCourseGetCategoriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get course contents
     * Get course contents
     * @param coreCourseGetContentsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetContents(coreCourseGetContentsRequest: CoreCourseGetContentsRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseGetContents(coreCourseGetContentsRequest: CoreCourseGetContentsRequest, ): Observable<any> {

        if (coreCourseGetContentsRequest === null || coreCourseGetContentsRequest === undefined) {
            throw new Error('Required parameter coreCourseGetContentsRequest was null or undefined when calling coreCourseGetContents.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_get_contents`,
            coreCourseGetContentsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch all the content items (activities, resources and their subtypes) for the activity picker
     * Fetch all the content items (activities, resources and their subtypes) for the activity picker
     * @param coreCourseGetCourseContentItemsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCourseContentItems(coreCourseGetCourseContentItemsRequest: CoreCourseGetCourseContentItemsRequest, ): Observable<AxiosResponse<CoreCourseGetCourseContentItems200Response>>;
    public coreCourseGetCourseContentItems(coreCourseGetCourseContentItemsRequest: CoreCourseGetCourseContentItemsRequest, ): Observable<any> {

        if (coreCourseGetCourseContentItemsRequest === null || coreCourseGetCourseContentItemsRequest === undefined) {
            throw new Error('Required parameter coreCourseGetCourseContentItemsRequest was null or undefined when calling coreCourseGetCourseContentItems.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetCourseContentItems200Response>(`${this.basePath}/core_course_get_course_content_items`,
            coreCourseGetCourseContentItemsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return information about a course module
     * Return information about a course module
     * @param coreCompetencyListCourseModuleCompetenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCourseModule(coreCompetencyListCourseModuleCompetenciesRequest: CoreCompetencyListCourseModuleCompetenciesRequest, ): Observable<AxiosResponse<CoreCourseGetCourseModule200Response>>;
    public coreCourseGetCourseModule(coreCompetencyListCourseModuleCompetenciesRequest: CoreCompetencyListCourseModuleCompetenciesRequest, ): Observable<any> {

        if (coreCompetencyListCourseModuleCompetenciesRequest === null || coreCompetencyListCourseModuleCompetenciesRequest === undefined) {
            throw new Error('Required parameter coreCompetencyListCourseModuleCompetenciesRequest was null or undefined when calling coreCourseGetCourseModule.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetCourseModule200Response>(`${this.basePath}/core_course_get_course_module`,
            coreCompetencyListCourseModuleCompetenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return information about a given module name and instance id
     * Return information about a given module name and instance id
     * @param coreCourseGetCourseModuleByInstanceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCourseModuleByInstance(coreCourseGetCourseModuleByInstanceRequest: CoreCourseGetCourseModuleByInstanceRequest, ): Observable<AxiosResponse<CoreCourseGetCourseModuleByInstance200Response>>;
    public coreCourseGetCourseModuleByInstance(coreCourseGetCourseModuleByInstanceRequest: CoreCourseGetCourseModuleByInstanceRequest, ): Observable<any> {

        if (coreCourseGetCourseModuleByInstanceRequest === null || coreCourseGetCourseModuleByInstanceRequest === undefined) {
            throw new Error('Required parameter coreCourseGetCourseModuleByInstanceRequest was null or undefined when calling coreCourseGetCourseModuleByInstance.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetCourseModuleByInstance200Response>(`${this.basePath}/core_course_get_course_module_by_instance`,
            coreCourseGetCourseModuleByInstanceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return course details
     * Return course details
     * @param coreCourseGetCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCourses(coreCourseGetCoursesRequest: CoreCourseGetCoursesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseGetCourses(coreCourseGetCoursesRequest: CoreCourseGetCoursesRequest, ): Observable<any> {

        if (coreCourseGetCoursesRequest === null || coreCourseGetCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseGetCoursesRequest was null or undefined when calling coreCourseGetCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_get_courses`,
            coreCourseGetCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get courses matching a specific field (id/s, shortname, idnumber, category)
     * Get courses matching a specific field (id/s, shortname, idnumber, category)
     * @param coreCourseGetCoursesByFieldRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetCoursesByField(coreCourseGetCoursesByFieldRequest: CoreCourseGetCoursesByFieldRequest, ): Observable<AxiosResponse<CoreCourseGetCoursesByField200Response>>;
    public coreCourseGetCoursesByField(coreCourseGetCoursesByFieldRequest: CoreCourseGetCoursesByFieldRequest, ): Observable<any> {

        if (coreCourseGetCoursesByFieldRequest === null || coreCourseGetCoursesByFieldRequest === undefined) {
            throw new Error('Required parameter coreCourseGetCoursesByFieldRequest was null or undefined when calling coreCourseGetCoursesByField.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetCoursesByField200Response>(`${this.basePath}/core_course_get_courses_by_field`,
            coreCourseGetCoursesByFieldRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List of enrolled courses for the given timeline classification (past, inprogress, or future).
     * List of enrolled courses for the given timeline classification (past, inprogress, or future).
     * @param coreCourseGetEnrolledCoursesByTimelineClassificationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetEnrolledCoursesByTimelineClassification(coreCourseGetEnrolledCoursesByTimelineClassificationRequest: CoreCourseGetEnrolledCoursesByTimelineClassificationRequest, ): Observable<AxiosResponse<CoreCourseGetEnrolledCoursesByTimelineClassification200Response>>;
    public coreCourseGetEnrolledCoursesByTimelineClassification(coreCourseGetEnrolledCoursesByTimelineClassificationRequest: CoreCourseGetEnrolledCoursesByTimelineClassificationRequest, ): Observable<any> {

        if (coreCourseGetEnrolledCoursesByTimelineClassificationRequest === null || coreCourseGetEnrolledCoursesByTimelineClassificationRequest === undefined) {
            throw new Error('Required parameter coreCourseGetEnrolledCoursesByTimelineClassificationRequest was null or undefined when calling coreCourseGetEnrolledCoursesByTimelineClassification.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetEnrolledCoursesByTimelineClassification200Response>(`${this.basePath}/core_course_get_enrolled_courses_by_timeline_classification`,
            coreCourseGetEnrolledCoursesByTimelineClassificationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List of enrolled courses with action events in a given timeframe, for the given timeline classification.
     * List of enrolled courses with action events in a given timeframe, for the given timeline classification.
     * @param coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification(coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest: CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest, ): Observable<AxiosResponse<CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification200Response>>;
    public coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification(coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest: CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest, ): Observable<any> {

        if (coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest === null || coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest === undefined) {
            throw new Error('Required parameter coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest was null or undefined when calling coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetEnrolledCoursesWithActionEventsByTimelineClassification200Response>(`${this.basePath}/core_course_get_enrolled_courses_with_action_events_by_timeline_classification`,
            coreCourseGetEnrolledCoursesWithActionEventsByTimelineClassificationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List users by course module id, filter by group and active enrolment status.
     * List users by course module id, filter by group and active enrolment status.
     * @param coreCourseGetEnrolledUsersByCmidRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetEnrolledUsersByCmid(coreCourseGetEnrolledUsersByCmidRequest: CoreCourseGetEnrolledUsersByCmidRequest, ): Observable<AxiosResponse<CoreCourseGetEnrolledUsersByCmid200Response>>;
    public coreCourseGetEnrolledUsersByCmid(coreCourseGetEnrolledUsersByCmidRequest: CoreCourseGetEnrolledUsersByCmidRequest, ): Observable<any> {

        if (coreCourseGetEnrolledUsersByCmidRequest === null || coreCourseGetEnrolledUsersByCmidRequest === undefined) {
            throw new Error('Required parameter coreCourseGetEnrolledUsersByCmidRequest was null or undefined when calling coreCourseGetEnrolledUsersByCmid.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetEnrolledUsersByCmid200Response>(`${this.basePath}/core_course_get_enrolled_users_by_cmid`,
            coreCourseGetEnrolledUsersByCmidRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns html with one activity module on course page
     * Returns html with one activity module on course page
     * @param coreCourseGetModuleRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetModule(coreCourseGetModuleRequest: CoreCourseGetModuleRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseGetModule(coreCourseGetModuleRequest: CoreCourseGetModuleRequest, ): Observable<any> {

        if (coreCourseGetModuleRequest === null || coreCourseGetModuleRequest === undefined) {
            throw new Error('Required parameter coreCourseGetModuleRequest was null or undefined when calling coreCourseGetModule.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_get_module`,
            coreCourseGetModuleRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List of courses a user has accessed most recently.
     * List of courses a user has accessed most recently.
     * @param coreCourseGetRecentCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetRecentCourses(coreCourseGetRecentCoursesRequest: CoreCourseGetRecentCoursesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseGetRecentCourses(coreCourseGetRecentCoursesRequest: CoreCourseGetRecentCoursesRequest, ): Observable<any> {

        if (coreCourseGetRecentCoursesRequest === null || coreCourseGetRecentCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseGetRecentCoursesRequest was null or undefined when calling coreCourseGetRecentCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_get_recent_courses`,
            coreCourseGetRecentCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Check if there are updates affecting the user for the given course since the given time stamp.
     * Check if there are updates affecting the user for the given course since the given time stamp.
     * @param coreCourseGetUpdatesSinceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetUpdatesSince(coreCourseGetUpdatesSinceRequest: CoreCourseGetUpdatesSinceRequest, ): Observable<AxiosResponse<CoreCourseGetUpdatesSince200Response>>;
    public coreCourseGetUpdatesSince(coreCourseGetUpdatesSinceRequest: CoreCourseGetUpdatesSinceRequest, ): Observable<any> {

        if (coreCourseGetUpdatesSinceRequest === null || coreCourseGetUpdatesSinceRequest === undefined) {
            throw new Error('Required parameter coreCourseGetUpdatesSinceRequest was null or undefined when calling coreCourseGetUpdatesSince.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetUpdatesSince200Response>(`${this.basePath}/core_course_get_updates_since`,
            coreCourseGetUpdatesSinceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return a list of administration options in a set of courses that are avaialable or not for the current                             user.
     * Return a list of administration options in a set of courses that are avaialable or not for the current                             user.
     * @param coreCourseGetUserAdministrationOptionsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetUserAdministrationOptions(coreCourseGetUserAdministrationOptionsRequest: CoreCourseGetUserAdministrationOptionsRequest, ): Observable<AxiosResponse<CoreCourseGetUserAdministrationOptions200Response>>;
    public coreCourseGetUserAdministrationOptions(coreCourseGetUserAdministrationOptionsRequest: CoreCourseGetUserAdministrationOptionsRequest, ): Observable<any> {

        if (coreCourseGetUserAdministrationOptionsRequest === null || coreCourseGetUserAdministrationOptionsRequest === undefined) {
            throw new Error('Required parameter coreCourseGetUserAdministrationOptionsRequest was null or undefined when calling coreCourseGetUserAdministrationOptions.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetUserAdministrationOptions200Response>(`${this.basePath}/core_course_get_user_administration_options`,
            coreCourseGetUserAdministrationOptionsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return a list of navigation options in a set of courses that are avaialable or not for the current user.
     * Return a list of navigation options in a set of courses that are avaialable or not for the current user.
     * @param coreCourseGetUserNavigationOptionsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseGetUserNavigationOptions(coreCourseGetUserNavigationOptionsRequest: CoreCourseGetUserNavigationOptionsRequest, ): Observable<AxiosResponse<CoreCourseGetUserNavigationOptions200Response>>;
    public coreCourseGetUserNavigationOptions(coreCourseGetUserNavigationOptionsRequest: CoreCourseGetUserNavigationOptionsRequest, ): Observable<any> {

        if (coreCourseGetUserNavigationOptionsRequest === null || coreCourseGetUserNavigationOptionsRequest === undefined) {
            throw new Error('Required parameter coreCourseGetUserNavigationOptionsRequest was null or undefined when calling coreCourseGetUserNavigationOptions.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseGetUserNavigationOptions200Response>(`${this.basePath}/core_course_get_user_navigation_options`,
            coreCourseGetUserNavigationOptionsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Import course data from a course into another course. Does not include any user data.
     * Import course data from a course into another course. Does not include any user data.
     * @param coreCourseImportCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseImportCourse(coreCourseImportCourseRequest: CoreCourseImportCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseImportCourse(coreCourseImportCourseRequest: CoreCourseImportCourseRequest, ): Observable<any> {

        if (coreCourseImportCourseRequest === null || coreCourseImportCourseRequest === undefined) {
            throw new Error('Required parameter coreCourseImportCourseRequest was null or undefined when calling coreCourseImportCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_import_course`,
            coreCourseImportCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Removes a content item (activity, resource or their subtypes) from the favourites for the user.
     * Removes a content item (activity, resource or their subtypes) from the favourites for the user.
     * @param coreCourseRemoveContentItemFromUserFavouritesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseRemoveContentItemFromUserFavourites(coreCourseRemoveContentItemFromUserFavouritesRequest: CoreCourseRemoveContentItemFromUserFavouritesRequest, ): Observable<AxiosResponse<CoreCourseAddContentItemToUserFavourites200Response>>;
    public coreCourseRemoveContentItemFromUserFavourites(coreCourseRemoveContentItemFromUserFavouritesRequest: CoreCourseRemoveContentItemFromUserFavouritesRequest, ): Observable<any> {

        if (coreCourseRemoveContentItemFromUserFavouritesRequest === null || coreCourseRemoveContentItemFromUserFavouritesRequest === undefined) {
            throw new Error('Required parameter coreCourseRemoveContentItemFromUserFavouritesRequest was null or undefined when calling coreCourseRemoveContentItemFromUserFavourites.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseAddContentItemToUserFavourites200Response>(`${this.basePath}/core_course_remove_content_item_from_user_favourites`,
            coreCourseRemoveContentItemFromUserFavouritesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search courses by (name, module, block, tag)
     * Search courses by (name, module, block, tag)
     * @param coreCourseSearchCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseSearchCourses(coreCourseSearchCoursesRequest: CoreCourseSearchCoursesRequest, ): Observable<AxiosResponse<CoreCourseSearchCourses200Response>>;
    public coreCourseSearchCourses(coreCourseSearchCoursesRequest: CoreCourseSearchCoursesRequest, ): Observable<any> {

        if (coreCourseSearchCoursesRequest === null || coreCourseSearchCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseSearchCoursesRequest was null or undefined when calling coreCourseSearchCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseSearchCourses200Response>(`${this.basePath}/core_course_search_courses`,
            coreCourseSearchCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add a list of courses to the list of favourite courses.
     * Add a list of courses to the list of favourite courses.
     * @param coreCourseSetFavouriteCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseSetFavouriteCourses(coreCourseSetFavouriteCoursesRequest: CoreCourseSetFavouriteCoursesRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreCourseSetFavouriteCourses(coreCourseSetFavouriteCoursesRequest: CoreCourseSetFavouriteCoursesRequest, ): Observable<any> {

        if (coreCourseSetFavouriteCoursesRequest === null || coreCourseSetFavouriteCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseSetFavouriteCoursesRequest was null or undefined when calling coreCourseSetFavouriteCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_course_set_favourite_courses`,
            coreCourseSetFavouriteCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds or removes an activity as a recommendation in the activity chooser.
     * Adds or removes an activity as a recommendation in the activity chooser.
     * @param coreCourseToggleActivityRecommendationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseToggleActivityRecommendation(coreCourseToggleActivityRecommendationRequest: CoreCourseToggleActivityRecommendationRequest, ): Observable<AxiosResponse<CoreCourseToggleActivityRecommendation200Response>>;
    public coreCourseToggleActivityRecommendation(coreCourseToggleActivityRecommendationRequest: CoreCourseToggleActivityRecommendationRequest, ): Observable<any> {

        if (coreCourseToggleActivityRecommendationRequest === null || coreCourseToggleActivityRecommendationRequest === undefined) {
            throw new Error('Required parameter coreCourseToggleActivityRecommendationRequest was null or undefined when calling coreCourseToggleActivityRecommendation.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCourseToggleActivityRecommendation200Response>(`${this.basePath}/core_course_toggle_activity_recommendation`,
            coreCourseToggleActivityRecommendationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update categories
     * Update categories
     * @param coreCourseUpdateCategoriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseUpdateCategories(coreCourseUpdateCategoriesRequest: CoreCourseUpdateCategoriesRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseUpdateCategories(coreCourseUpdateCategoriesRequest: CoreCourseUpdateCategoriesRequest, ): Observable<any> {

        if (coreCourseUpdateCategoriesRequest === null || coreCourseUpdateCategoriesRequest === undefined) {
            throw new Error('Required parameter coreCourseUpdateCategoriesRequest was null or undefined when calling coreCourseUpdateCategories.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_course_update_categories`,
            coreCourseUpdateCategoriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update courses
     * Update courses
     * @param coreCourseUpdateCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseUpdateCourses(coreCourseUpdateCoursesRequest: CoreCourseUpdateCoursesRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreCourseUpdateCourses(coreCourseUpdateCoursesRequest: CoreCourseUpdateCoursesRequest, ): Observable<any> {

        if (coreCourseUpdateCoursesRequest === null || coreCourseUpdateCoursesRequest === undefined) {
            throw new Error('Required parameter coreCourseUpdateCoursesRequest was null or undefined when calling coreCourseUpdateCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_course_update_courses`,
            coreCourseUpdateCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Log that the course was viewed
     * Log that the course was viewed
     * @param coreCourseViewCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseViewCourse(coreCourseViewCourseRequest: CoreCourseViewCourseRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreCourseViewCourse(coreCourseViewCourseRequest: CoreCourseViewCourseRequest, ): Observable<any> {

        if (coreCourseViewCourseRequest === null || coreCourseViewCourseRequest === undefined) {
            throw new Error('Required parameter coreCourseViewCourseRequest was null or undefined when calling coreCourseViewCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_course_view_course`,
            coreCourseViewCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the current course file hanlders.
     * Get the current course file hanlders.
     * @param coreCourseformatFileHandlersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseformatFileHandlers(coreCourseformatFileHandlersRequest: CoreCourseformatFileHandlersRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseformatFileHandlers(coreCourseformatFileHandlersRequest: CoreCourseformatFileHandlersRequest, ): Observable<any> {

        if (coreCourseformatFileHandlersRequest === null || coreCourseformatFileHandlersRequest === undefined) {
            throw new Error('Required parameter coreCourseformatFileHandlersRequest was null or undefined when calling coreCourseformatFileHandlers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_courseformat_file_handlers`,
            coreCourseformatFileHandlersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the current course state.
     * Get the current course state.
     * @param coreCourseformatFileHandlersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseformatGetState(coreCourseformatFileHandlersRequest: CoreCourseformatFileHandlersRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseformatGetState(coreCourseformatFileHandlersRequest: CoreCourseformatFileHandlersRequest, ): Observable<any> {

        if (coreCourseformatFileHandlersRequest === null || coreCourseformatFileHandlersRequest === undefined) {
            throw new Error('Required parameter coreCourseformatFileHandlersRequest was null or undefined when calling coreCourseformatGetState.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_courseformat_get_state`,
            coreCourseformatFileHandlersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update course contents.
     * Update course contents.
     * @param coreCourseformatUpdateCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCourseformatUpdateCourse(coreCourseformatUpdateCourseRequest: CoreCourseformatUpdateCourseRequest, ): Observable<AxiosResponse<object>>;
    public coreCourseformatUpdateCourse(coreCourseformatUpdateCourseRequest: CoreCourseformatUpdateCourseRequest, ): Observable<any> {

        if (coreCourseformatUpdateCourseRequest === null || coreCourseformatUpdateCourseRequest === undefined) {
            throw new Error('Required parameter coreCourseformatUpdateCourseRequest was null or undefined when calling coreCourseformatUpdateCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_courseformat_update_course`,
            coreCourseformatUpdateCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Record the action that the user takes in the user feedback notification for future use.
     * Record the action that the user takes in the user feedback notification for future use.
     * @param coreCreateUserfeedbackActionRecordRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCreateUserfeedbackActionRecord(coreCreateUserfeedbackActionRecordRequest: CoreCreateUserfeedbackActionRecordRequest, ): Observable<AxiosResponse<object>>;
    public coreCreateUserfeedbackActionRecord(coreCreateUserfeedbackActionRecordRequest: CoreCreateUserfeedbackActionRecordRequest, ): Observable<any> {

        if (coreCreateUserfeedbackActionRecordRequest === null || coreCreateUserfeedbackActionRecordRequest === undefined) {
            throw new Error('Required parameter coreCreateUserfeedbackActionRecordRequest was null or undefined when calling coreCreateUserfeedbackActionRecord.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_create_userfeedback_action_record`,
            coreCreateUserfeedbackActionRecordRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates a new category
     * Creates a new category
     * @param coreCustomfieldCreateCategoryRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldCreateCategory(coreCustomfieldCreateCategoryRequest: CoreCustomfieldCreateCategoryRequest, ): Observable<AxiosResponse<object>>;
    public coreCustomfieldCreateCategory(coreCustomfieldCreateCategoryRequest: CoreCustomfieldCreateCategoryRequest, ): Observable<any> {

        if (coreCustomfieldCreateCategoryRequest === null || coreCustomfieldCreateCategoryRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldCreateCategoryRequest was null or undefined when calling coreCustomfieldCreateCategory.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_customfield_create_category`,
            coreCustomfieldCreateCategoryRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes a category
     * Deletes a category
     * @param coreCustomfieldDeleteCategoryRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldDeleteCategory(coreCustomfieldDeleteCategoryRequest: CoreCustomfieldDeleteCategoryRequest, ): Observable<AxiosResponse<object>>;
    public coreCustomfieldDeleteCategory(coreCustomfieldDeleteCategoryRequest: CoreCustomfieldDeleteCategoryRequest, ): Observable<any> {

        if (coreCustomfieldDeleteCategoryRequest === null || coreCustomfieldDeleteCategoryRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldDeleteCategoryRequest was null or undefined when calling coreCustomfieldDeleteCategory.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_customfield_delete_category`,
            coreCustomfieldDeleteCategoryRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes an entry
     * Deletes an entry
     * @param coreCustomfieldDeleteFieldRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldDeleteField(coreCustomfieldDeleteFieldRequest: CoreCustomfieldDeleteFieldRequest, ): Observable<AxiosResponse<object>>;
    public coreCustomfieldDeleteField(coreCustomfieldDeleteFieldRequest: CoreCustomfieldDeleteFieldRequest, ): Observable<any> {

        if (coreCustomfieldDeleteFieldRequest === null || coreCustomfieldDeleteFieldRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldDeleteFieldRequest was null or undefined when calling coreCustomfieldDeleteField.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_customfield_delete_field`,
            coreCustomfieldDeleteFieldRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Drag and drop categories
     * Drag and drop categories
     * @param coreCustomfieldMoveCategoryRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldMoveCategory(coreCustomfieldMoveCategoryRequest: CoreCustomfieldMoveCategoryRequest, ): Observable<AxiosResponse<object>>;
    public coreCustomfieldMoveCategory(coreCustomfieldMoveCategoryRequest: CoreCustomfieldMoveCategoryRequest, ): Observable<any> {

        if (coreCustomfieldMoveCategoryRequest === null || coreCustomfieldMoveCategoryRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldMoveCategoryRequest was null or undefined when calling coreCustomfieldMoveCategory.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_customfield_move_category`,
            coreCustomfieldMoveCategoryRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Drag and drop
     * Drag and drop
     * @param coreCustomfieldMoveFieldRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldMoveField(coreCustomfieldMoveFieldRequest: CoreCustomfieldMoveFieldRequest, ): Observable<AxiosResponse<object>>;
    public coreCustomfieldMoveField(coreCustomfieldMoveFieldRequest: CoreCustomfieldMoveFieldRequest, ): Observable<any> {

        if (coreCustomfieldMoveFieldRequest === null || coreCustomfieldMoveFieldRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldMoveFieldRequest was null or undefined when calling coreCustomfieldMoveField.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_customfield_move_field`,
            coreCustomfieldMoveFieldRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Reloads template
     * Reloads template
     * @param coreCustomfieldReloadTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreCustomfieldReloadTemplate(coreCustomfieldReloadTemplateRequest: CoreCustomfieldReloadTemplateRequest, ): Observable<AxiosResponse<CoreCustomfieldReloadTemplate200Response>>;
    public coreCustomfieldReloadTemplate(coreCustomfieldReloadTemplateRequest: CoreCustomfieldReloadTemplateRequest, ): Observable<any> {

        if (coreCustomfieldReloadTemplateRequest === null || coreCustomfieldReloadTemplateRequest === undefined) {
            throw new Error('Required parameter coreCustomfieldReloadTemplateRequest was null or undefined when calling coreCustomfieldReloadTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCustomfieldReloadTemplate200Response>(`${this.basePath}/core_customfield_reload_template`,
            coreCustomfieldReloadTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the content for a dynamic tab
     * Returns the content for a dynamic tab
     * @param coreDynamicTabsGetContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreDynamicTabsGetContent(coreDynamicTabsGetContentRequest: CoreDynamicTabsGetContentRequest, ): Observable<AxiosResponse<CoreDynamicTabsGetContent200Response>>;
    public coreDynamicTabsGetContent(coreDynamicTabsGetContentRequest: CoreDynamicTabsGetContentRequest, ): Observable<any> {

        if (coreDynamicTabsGetContentRequest === null || coreDynamicTabsGetContentRequest === undefined) {
            throw new Error('Required parameter coreDynamicTabsGetContentRequest was null or undefined when calling coreDynamicTabsGetContent.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreDynamicTabsGetContent200Response>(`${this.basePath}/core_dynamic_tabs_get_content`,
            coreDynamicTabsGetContentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the list of course enrolment methods
     * Get the list of course enrolment methods
     * @param coreEnrolGetCourseEnrolmentMethodsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolGetCourseEnrolmentMethods(coreEnrolGetCourseEnrolmentMethodsRequest: CoreEnrolGetCourseEnrolmentMethodsRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolGetCourseEnrolmentMethods(coreEnrolGetCourseEnrolmentMethodsRequest: CoreEnrolGetCourseEnrolmentMethodsRequest, ): Observable<any> {

        if (coreEnrolGetCourseEnrolmentMethodsRequest === null || coreEnrolGetCourseEnrolmentMethodsRequest === undefined) {
            throw new Error('Required parameter coreEnrolGetCourseEnrolmentMethodsRequest was null or undefined when calling coreEnrolGetCourseEnrolmentMethods.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_get_course_enrolment_methods`,
            coreEnrolGetCourseEnrolmentMethodsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get enrolled users by course id.
     * Get enrolled users by course id.
     * @param coreEnrolGetEnrolledUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolGetEnrolledUsers(coreEnrolGetEnrolledUsersRequest: CoreEnrolGetEnrolledUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolGetEnrolledUsers(coreEnrolGetEnrolledUsersRequest: CoreEnrolGetEnrolledUsersRequest, ): Observable<any> {

        if (coreEnrolGetEnrolledUsersRequest === null || coreEnrolGetEnrolledUsersRequest === undefined) {
            throw new Error('Required parameter coreEnrolGetEnrolledUsersRequest was null or undefined when calling coreEnrolGetEnrolledUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_get_enrolled_users`,
            coreEnrolGetEnrolledUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * For each course and capability specified, return a list of the users that are enrolled in the course                                   and have that capability
     * For each course and capability specified, return a list of the users that are enrolled in the course                                   and have that capability
     * @param coreEnrolGetEnrolledUsersWithCapabilityRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolGetEnrolledUsersWithCapability(coreEnrolGetEnrolledUsersWithCapabilityRequest: CoreEnrolGetEnrolledUsersWithCapabilityRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolGetEnrolledUsersWithCapability(coreEnrolGetEnrolledUsersWithCapabilityRequest: CoreEnrolGetEnrolledUsersWithCapabilityRequest, ): Observable<any> {

        if (coreEnrolGetEnrolledUsersWithCapabilityRequest === null || coreEnrolGetEnrolledUsersWithCapabilityRequest === undefined) {
            throw new Error('Required parameter coreEnrolGetEnrolledUsersWithCapabilityRequest was null or undefined when calling coreEnrolGetEnrolledUsersWithCapability.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_get_enrolled_users_with_capability`,
            coreEnrolGetEnrolledUsersWithCapabilityRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the list of potential users to enrol
     * Get the list of potential users to enrol
     * @param coreEnrolGetPotentialUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolGetPotentialUsers(coreEnrolGetPotentialUsersRequest: CoreEnrolGetPotentialUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolGetPotentialUsers(coreEnrolGetPotentialUsersRequest: CoreEnrolGetPotentialUsersRequest, ): Observable<any> {

        if (coreEnrolGetPotentialUsersRequest === null || coreEnrolGetPotentialUsersRequest === undefined) {
            throw new Error('Required parameter coreEnrolGetPotentialUsersRequest was null or undefined when calling coreEnrolGetPotentialUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_get_potential_users`,
            coreEnrolGetPotentialUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the list of courses where a user is enrolled in
     * Get the list of courses where a user is enrolled in
     * @param coreEnrolGetUsersCoursesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolGetUsersCourses(coreEnrolGetUsersCoursesRequest: CoreEnrolGetUsersCoursesRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolGetUsersCourses(coreEnrolGetUsersCoursesRequest: CoreEnrolGetUsersCoursesRequest, ): Observable<any> {

        if (coreEnrolGetUsersCoursesRequest === null || coreEnrolGetUsersCoursesRequest === undefined) {
            throw new Error('Required parameter coreEnrolGetUsersCoursesRequest was null or undefined when calling coreEnrolGetUsersCourses.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_get_users_courses`,
            coreEnrolGetUsersCoursesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search within the list of course participants
     * Search within the list of course participants
     * @param coreEnrolSearchUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolSearchUsers(coreEnrolSearchUsersRequest: CoreEnrolSearchUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreEnrolSearchUsers(coreEnrolSearchUsersRequest: CoreEnrolSearchUsersRequest, ): Observable<any> {

        if (coreEnrolSearchUsersRequest === null || coreEnrolSearchUsersRequest === undefined) {
            throw new Error('Required parameter coreEnrolSearchUsersRequest was null or undefined when calling coreEnrolSearchUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_enrol_search_users`,
            coreEnrolSearchUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Submit form data for enrolment form
     * Submit form data for enrolment form
     * @param coreEnrolSubmitUserEnrolmentFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolSubmitUserEnrolmentForm(coreEnrolSubmitUserEnrolmentFormRequest: CoreEnrolSubmitUserEnrolmentFormRequest, ): Observable<AxiosResponse<CoreEnrolSubmitUserEnrolmentForm200Response>>;
    public coreEnrolSubmitUserEnrolmentForm(coreEnrolSubmitUserEnrolmentFormRequest: CoreEnrolSubmitUserEnrolmentFormRequest, ): Observable<any> {

        if (coreEnrolSubmitUserEnrolmentFormRequest === null || coreEnrolSubmitUserEnrolmentFormRequest === undefined) {
            throw new Error('Required parameter coreEnrolSubmitUserEnrolmentFormRequest was null or undefined when calling coreEnrolSubmitUserEnrolmentForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreEnrolSubmitUserEnrolmentForm200Response>(`${this.basePath}/core_enrol_submit_user_enrolment_form`,
            coreEnrolSubmitUserEnrolmentFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * External function that unenrols a given user enrolment
     * External function that unenrols a given user enrolment
     * @param coreEnrolUnenrolUserEnrolmentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreEnrolUnenrolUserEnrolment(coreEnrolUnenrolUserEnrolmentRequest: CoreEnrolUnenrolUserEnrolmentRequest, ): Observable<AxiosResponse<CoreEnrolUnenrolUserEnrolment200Response>>;
    public coreEnrolUnenrolUserEnrolment(coreEnrolUnenrolUserEnrolmentRequest: CoreEnrolUnenrolUserEnrolmentRequest, ): Observable<any> {

        if (coreEnrolUnenrolUserEnrolmentRequest === null || coreEnrolUnenrolUserEnrolmentRequest === undefined) {
            throw new Error('Required parameter coreEnrolUnenrolUserEnrolmentRequest was null or undefined when calling coreEnrolUnenrolUserEnrolment.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreEnrolUnenrolUserEnrolment200Response>(`${this.basePath}/core_enrol_unenrol_user_enrolment`,
            coreEnrolUnenrolUserEnrolmentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return a list of notifications for the current session
     * Return a list of notifications for the current session
     * @param coreFetchNotificationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFetchNotifications(coreFetchNotificationsRequest: CoreFetchNotificationsRequest, ): Observable<AxiosResponse<object>>;
    public coreFetchNotifications(coreFetchNotificationsRequest: CoreFetchNotificationsRequest, ): Observable<any> {

        if (coreFetchNotificationsRequest === null || coreFetchNotificationsRequest === undefined) {
            throw new Error('Required parameter coreFetchNotificationsRequest was null or undefined when calling coreFetchNotifications.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_fetch_notifications`,
            coreFetchNotificationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete the indicated files (or directories) from a user draft file area.
     * Delete the indicated files (or directories) from a user draft file area.
     * @param coreFilesDeleteDraftFilesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFilesDeleteDraftFiles(coreFilesDeleteDraftFilesRequest: CoreFilesDeleteDraftFilesRequest, ): Observable<AxiosResponse<CoreFilesDeleteDraftFiles200Response>>;
    public coreFilesDeleteDraftFiles(coreFilesDeleteDraftFilesRequest: CoreFilesDeleteDraftFilesRequest, ): Observable<any> {

        if (coreFilesDeleteDraftFilesRequest === null || coreFilesDeleteDraftFilesRequest === undefined) {
            throw new Error('Required parameter coreFilesDeleteDraftFilesRequest was null or undefined when calling coreFilesDeleteDraftFiles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFilesDeleteDraftFiles200Response>(`${this.basePath}/core_files_delete_draft_files`,
            coreFilesDeleteDraftFilesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * browse moodle files
     * browse moodle files
     * @param coreFilesGetFilesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFilesGetFiles(coreFilesGetFilesRequest: CoreFilesGetFilesRequest, ): Observable<AxiosResponse<CoreFilesGetFiles200Response>>;
    public coreFilesGetFiles(coreFilesGetFilesRequest: CoreFilesGetFilesRequest, ): Observable<any> {

        if (coreFilesGetFilesRequest === null || coreFilesGetFilesRequest === undefined) {
            throw new Error('Required parameter coreFilesGetFilesRequest was null or undefined when calling coreFilesGetFiles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFilesGetFiles200Response>(`${this.basePath}/core_files_get_files`,
            coreFilesGetFilesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Generate a new draft itemid for the current user.
     * Generate a new draft itemid for the current user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFilesGetUnusedDraftItemid(): Observable<AxiosResponse<CoreFilesGetUnusedDraftItemid200Response>>;
    public coreFilesGetUnusedDraftItemid(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreFilesGetUnusedDraftItemid200Response>(`${this.basePath}/core_files_get_unused_draft_itemid`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * upload a file to moodle
     * upload a file to moodle
     * @param coreFilesUploadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFilesUpload(coreFilesUploadRequest: CoreFilesUploadRequest, ): Observable<AxiosResponse<CoreFilesUpload200Response>>;
    public coreFilesUpload(coreFilesUploadRequest: CoreFilesUploadRequest, ): Observable<any> {

        if (coreFilesUploadRequest === null || coreFilesUploadRequest === undefined) {
            throw new Error('Required parameter coreFilesUploadRequest was null or undefined when calling coreFilesUpload.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFilesUpload200Response>(`${this.basePath}/core_files_upload`,
            coreFilesUploadRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the filters available in the given contexts.
     * Returns the filters available in the given contexts.
     * @param coreFiltersGetAvailableInContextRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFiltersGetAvailableInContext(coreFiltersGetAvailableInContextRequest: CoreFiltersGetAvailableInContextRequest, ): Observable<AxiosResponse<CoreFiltersGetAvailableInContext200Response>>;
    public coreFiltersGetAvailableInContext(coreFiltersGetAvailableInContextRequest: CoreFiltersGetAvailableInContextRequest, ): Observable<any> {

        if (coreFiltersGetAvailableInContextRequest === null || coreFiltersGetAvailableInContextRequest === undefined) {
            throw new Error('Required parameter coreFiltersGetAvailableInContextRequest was null or undefined when calling coreFiltersGetAvailableInContext.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFiltersGetAvailableInContext200Response>(`${this.basePath}/core_filters_get_available_in_context`,
            coreFiltersGetAvailableInContextRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Process submission of a dynamic (modal) form
     * Process submission of a dynamic (modal) form
     * @param coreFormDynamicFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFormDynamicForm(coreFormDynamicFormRequest: CoreFormDynamicFormRequest, ): Observable<AxiosResponse<CoreFormDynamicForm200Response>>;
    public coreFormDynamicForm(coreFormDynamicFormRequest: CoreFormDynamicFormRequest, ): Observable<any> {

        if (coreFormDynamicFormRequest === null || coreFormDynamicFormRequest === undefined) {
            throw new Error('Required parameter coreFormDynamicFormRequest was null or undefined when calling coreFormDynamicForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFormDynamicForm200Response>(`${this.basePath}/core_form_dynamic_form`,
            coreFormDynamicFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Provides data for the filetypes element browser.
     * Provides data for the filetypes element browser.
     * @param coreFormGetFiletypesBrowserDataRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreFormGetFiletypesBrowserData(coreFormGetFiletypesBrowserDataRequest: CoreFormGetFiletypesBrowserDataRequest, ): Observable<AxiosResponse<CoreFormGetFiletypesBrowserData200Response>>;
    public coreFormGetFiletypesBrowserData(coreFormGetFiletypesBrowserDataRequest: CoreFormGetFiletypesBrowserDataRequest, ): Observable<any> {

        if (coreFormGetFiletypesBrowserDataRequest === null || coreFormGetFiletypesBrowserDataRequest === undefined) {
            throw new Error('Required parameter coreFormGetFiletypesBrowserDataRequest was null or undefined when calling coreFormGetFiletypesBrowserData.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreFormGetFiletypesBrowserData200Response>(`${this.basePath}/core_form_get_filetypes_browser_data`,
            coreFormGetFiletypesBrowserDataRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return all raw strings (with {$a-&gt;xxx}), for a specific component - similar to core get_component_strings(), call
     * Return all raw strings (with {$a-&gt;xxx}), for a specific component - similar to core get_component_strings(), call
     * @param coreGetComponentStringsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGetComponentStrings(coreGetComponentStringsRequest: CoreGetComponentStringsRequest, ): Observable<AxiosResponse<object>>;
    public coreGetComponentStrings(coreGetComponentStringsRequest: CoreGetComponentStringsRequest, ): Observable<any> {

        if (coreGetComponentStringsRequest === null || coreGetComponentStringsRequest === undefined) {
            throw new Error('Required parameter coreGetComponentStringsRequest was null or undefined when calling coreGetComponentStrings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_get_component_strings`,
            coreGetComponentStringsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return a fragment for inclusion, such as a JavaScript page.
     * Return a fragment for inclusion, such as a JavaScript page.
     * @param coreGetFragmentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGetFragment(coreGetFragmentRequest: CoreGetFragmentRequest, ): Observable<AxiosResponse<CoreGetFragment200Response>>;
    public coreGetFragment(coreGetFragmentRequest: CoreGetFragmentRequest, ): Observable<any> {

        if (coreGetFragmentRequest === null || coreGetFragmentRequest === undefined) {
            throw new Error('Required parameter coreGetFragmentRequest was null or undefined when calling coreGetFragment.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGetFragment200Response>(`${this.basePath}/core_get_fragment`,
            coreGetFragmentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return a translated string - similar to core get_string(), call
     * Return a translated string - similar to core get_string(), call
     * @param coreGetStringRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGetString(coreGetStringRequest: CoreGetStringRequest, ): Observable<AxiosResponse<object>>;
    public coreGetString(coreGetStringRequest: CoreGetStringRequest, ): Observable<any> {

        if (coreGetStringRequest === null || coreGetStringRequest === undefined) {
            throw new Error('Required parameter coreGetStringRequest was null or undefined when calling coreGetString.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_get_string`,
            coreGetStringRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return some translated strings - like several core get_string(), calls
     * Return some translated strings - like several core get_string(), calls
     * @param coreGetStringsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGetStrings(coreGetStringsRequest: CoreGetStringsRequest, ): Observable<AxiosResponse<object>>;
    public coreGetStrings(coreGetStringsRequest: CoreGetStringsRequest, ): Observable<any> {

        if (coreGetStringsRequest === null || coreGetStringsRequest === undefined) {
            throw new Error('Required parameter coreGetStringsRequest was null or undefined when calling coreGetStrings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_get_strings`,
            coreGetStringsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return formatted timestamps
     * Return formatted timestamps
     * @param coreGetUserDatesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGetUserDates(coreGetUserDatesRequest: CoreGetUserDatesRequest, ): Observable<AxiosResponse<CoreGetUserDates200Response>>;
    public coreGetUserDates(coreGetUserDatesRequest: CoreGetUserDatesRequest, ): Observable<any> {

        if (coreGetUserDatesRequest === null || coreGetUserDatesRequest === undefined) {
            throw new Error('Required parameter coreGetUserDatesRequest was null or undefined when calling coreGetUserDates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGetUserDates200Response>(`${this.basePath}/core_get_user_dates`,
            coreGetUserDatesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create grade categories inside a course gradebook.
     * Create grade categories inside a course gradebook.
     * @param coreGradesCreateGradecategoriesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesCreateGradecategories(coreGradesCreateGradecategoriesRequest: CoreGradesCreateGradecategoriesRequest, ): Observable<AxiosResponse<CoreGradesCreateGradecategories200Response>>;
    public coreGradesCreateGradecategories(coreGradesCreateGradecategoriesRequest: CoreGradesCreateGradecategoriesRequest, ): Observable<any> {

        if (coreGradesCreateGradecategoriesRequest === null || coreGradesCreateGradecategoriesRequest === undefined) {
            throw new Error('Required parameter coreGradesCreateGradecategoriesRequest was null or undefined when calling coreGradesCreateGradecategories.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesCreateGradecategories200Response>(`${this.basePath}/core_grades_create_gradecategories`,
            coreGradesCreateGradecategoriesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * ** DEPRECATED ** Please do not call this function any more. Use core_grades_get_enrolled_users_for_selector instead. Returns the enrolled users within and map some fields to the returned array of user objects.
     * ** DEPRECATED ** Please do not call this function any more. Use core_grades_get_enrolled_users_for_selector instead. Returns the enrolled users within and map some fields to the returned array of user objects.
     * @param coreGradesGetEnrolledUsersForSearchWidgetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetEnrolledUsersForSearchWidget(coreGradesGetEnrolledUsersForSearchWidgetRequest: CoreGradesGetEnrolledUsersForSearchWidgetRequest, ): Observable<AxiosResponse<CoreGradesGetEnrolledUsersForSearchWidget200Response>>;
    public coreGradesGetEnrolledUsersForSearchWidget(coreGradesGetEnrolledUsersForSearchWidgetRequest: CoreGradesGetEnrolledUsersForSearchWidgetRequest, ): Observable<any> {

        if (coreGradesGetEnrolledUsersForSearchWidgetRequest === null || coreGradesGetEnrolledUsersForSearchWidgetRequest === undefined) {
            throw new Error('Required parameter coreGradesGetEnrolledUsersForSearchWidgetRequest was null or undefined when calling coreGradesGetEnrolledUsersForSearchWidget.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetEnrolledUsersForSearchWidget200Response>(`${this.basePath}/core_grades_get_enrolled_users_for_search_widget`,
            coreGradesGetEnrolledUsersForSearchWidgetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the enrolled users within and map some fields to the returned array of user objects.
     * Returns the enrolled users within and map some fields to the returned array of user objects.
     * @param coreGradesGetEnrolledUsersForSelectorRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetEnrolledUsersForSelector(coreGradesGetEnrolledUsersForSelectorRequest: CoreGradesGetEnrolledUsersForSelectorRequest, ): Observable<AxiosResponse<CoreGradesGetEnrolledUsersForSelector200Response>>;
    public coreGradesGetEnrolledUsersForSelector(coreGradesGetEnrolledUsersForSelectorRequest: CoreGradesGetEnrolledUsersForSelectorRequest, ): Observable<any> {

        if (coreGradesGetEnrolledUsersForSelectorRequest === null || coreGradesGetEnrolledUsersForSelectorRequest === undefined) {
            throw new Error('Required parameter coreGradesGetEnrolledUsersForSelectorRequest was null or undefined when calling coreGradesGetEnrolledUsersForSelector.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetEnrolledUsersForSelector200Response>(`${this.basePath}/core_grades_get_enrolled_users_for_selector`,
            coreGradesGetEnrolledUsersForSelectorRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the feedback data for a grade item
     * Get the feedback data for a grade item
     * @param coreGradesGetFeedbackRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetFeedback(coreGradesGetFeedbackRequest: CoreGradesGetFeedbackRequest, ): Observable<AxiosResponse<CoreGradesGetFeedback200Response>>;
    public coreGradesGetFeedback(coreGradesGetFeedbackRequest: CoreGradesGetFeedbackRequest, ): Observable<any> {

        if (coreGradesGetFeedbackRequest === null || coreGradesGetFeedbackRequest === undefined) {
            throw new Error('Required parameter coreGradesGetFeedbackRequest was null or undefined when calling coreGradesGetFeedback.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetFeedback200Response>(`${this.basePath}/core_grades_get_feedback`,
            coreGradesGetFeedbackRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns the gradable users in a course
     * Returns the gradable users in a course
     * @param coreGradesGetGradableUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetGradableUsers(coreGradesGetGradableUsersRequest: CoreGradesGetGradableUsersRequest, ): Observable<AxiosResponse<CoreGradesGetGradableUsers200Response>>;
    public coreGradesGetGradableUsers(coreGradesGetGradableUsersRequest: CoreGradesGetGradableUsersRequest, ): Observable<any> {

        if (coreGradesGetGradableUsersRequest === null || coreGradesGetGradableUsersRequest === undefined) {
            throw new Error('Required parameter coreGradesGetGradableUsersRequest was null or undefined when calling coreGradesGetGradableUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetGradableUsers200Response>(`${this.basePath}/core_grades_get_gradable_users`,
            coreGradesGetGradableUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the grade tree structure for a course
     * Get the grade tree structure for a course
     * @param coreCompletionMarkCourseSelfCompletedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetGradeTree(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<AxiosResponse<object>>;
    public coreGradesGetGradeTree(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<any> {

        if (coreCompletionMarkCourseSelfCompletedRequest === null || coreCompletionMarkCourseSelfCompletedRequest === undefined) {
            throw new Error('Required parameter coreCompletionMarkCourseSelfCompletedRequest was null or undefined when calling coreGradesGetGradeTree.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_grades_get_grade_tree`,
            coreCompletionMarkCourseSelfCompletedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the gradeitems for a course
     * Get the gradeitems for a course
     * @param coreCompletionMarkCourseSelfCompletedRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetGradeitems(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<AxiosResponse<CoreGradesGetGradeitems200Response>>;
    public coreGradesGetGradeitems(coreCompletionMarkCourseSelfCompletedRequest: CoreCompletionMarkCourseSelfCompletedRequest, ): Observable<any> {

        if (coreCompletionMarkCourseSelfCompletedRequest === null || coreCompletionMarkCourseSelfCompletedRequest === undefined) {
            throw new Error('Required parameter coreCompletionMarkCourseSelfCompletedRequest was null or undefined when calling coreGradesGetGradeitems.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetGradeitems200Response>(`${this.basePath}/core_grades_get_gradeitems`,
            coreCompletionMarkCourseSelfCompletedRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * ** DEPRECATED ** Please do not call this function any more. Use core_group_get_groups_for_selector instead. Get the group/(s) for a course
     * ** DEPRECATED ** Please do not call this function any more. Use core_group_get_groups_for_selector instead. Get the group/(s) for a course
     * @param coreGradesGetGroupsForSearchWidgetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetGroupsForSearchWidget(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<AxiosResponse<CoreGradesGetGroupsForSearchWidget200Response>>;
    public coreGradesGetGroupsForSearchWidget(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<any> {

        if (coreGradesGetGroupsForSearchWidgetRequest === null || coreGradesGetGroupsForSearchWidgetRequest === undefined) {
            throw new Error('Required parameter coreGradesGetGroupsForSearchWidgetRequest was null or undefined when calling coreGradesGetGroupsForSearchWidget.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetGroupsForSearchWidget200Response>(`${this.basePath}/core_grades_get_groups_for_search_widget`,
            coreGradesGetGroupsForSearchWidgetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * ** DEPRECATED ** Please do not call this function any more. Use core_group_get_groups_for_selector instead. Get the group/(s) for a course
     * ** DEPRECATED ** Please do not call this function any more. Use core_group_get_groups_for_selector instead. Get the group/(s) for a course
     * @param coreGradesGetGroupsForSearchWidgetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGetGroupsForSelector(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<AxiosResponse<CoreGradesGetGroupsForSelector200Response>>;
    public coreGradesGetGroupsForSelector(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<any> {

        if (coreGradesGetGroupsForSearchWidgetRequest === null || coreGradesGetGroupsForSearchWidgetRequest === undefined) {
            throw new Error('Required parameter coreGradesGetGroupsForSearchWidgetRequest was null or undefined when calling coreGradesGetGroupsForSelector.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetGroupsForSelector200Response>(`${this.basePath}/core_grades_get_groups_for_selector`,
            coreGradesGetGroupsForSearchWidgetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the data required to display the grader grading panel for simple grading, creating the grade item if required
     * Fetch the data required to display the grader grading panel for simple grading, creating the grade item if required
     * @param coreGradesGraderGradingpanelPointFetchRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGraderGradingpanelPointFetch(coreGradesGraderGradingpanelPointFetchRequest: CoreGradesGraderGradingpanelPointFetchRequest, ): Observable<AxiosResponse<CoreGradesGraderGradingpanelPointFetch200Response>>;
    public coreGradesGraderGradingpanelPointFetch(coreGradesGraderGradingpanelPointFetchRequest: CoreGradesGraderGradingpanelPointFetchRequest, ): Observable<any> {

        if (coreGradesGraderGradingpanelPointFetchRequest === null || coreGradesGraderGradingpanelPointFetchRequest === undefined) {
            throw new Error('Required parameter coreGradesGraderGradingpanelPointFetchRequest was null or undefined when calling coreGradesGraderGradingpanelPointFetch.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGraderGradingpanelPointFetch200Response>(`${this.basePath}/core_grades_grader_gradingpanel_point_fetch`,
            coreGradesGraderGradingpanelPointFetchRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Store the data required to display the grader grading panel for simple grading
     * Store the data required to display the grader grading panel for simple grading
     * @param coreGradesGraderGradingpanelPointStoreRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGraderGradingpanelPointStore(coreGradesGraderGradingpanelPointStoreRequest: CoreGradesGraderGradingpanelPointStoreRequest, ): Observable<AxiosResponse<CoreGradesGraderGradingpanelPointStore200Response>>;
    public coreGradesGraderGradingpanelPointStore(coreGradesGraderGradingpanelPointStoreRequest: CoreGradesGraderGradingpanelPointStoreRequest, ): Observable<any> {

        if (coreGradesGraderGradingpanelPointStoreRequest === null || coreGradesGraderGradingpanelPointStoreRequest === undefined) {
            throw new Error('Required parameter coreGradesGraderGradingpanelPointStoreRequest was null or undefined when calling coreGradesGraderGradingpanelPointStore.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGraderGradingpanelPointStore200Response>(`${this.basePath}/core_grades_grader_gradingpanel_point_store`,
            coreGradesGraderGradingpanelPointStoreRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Fetch the data required to display the grader grading panel for scale-based grading, creating the grade item if required
     * Fetch the data required to display the grader grading panel for scale-based grading, creating the grade item if required
     * @param coreGradesGraderGradingpanelScaleFetchRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGraderGradingpanelScaleFetch(coreGradesGraderGradingpanelScaleFetchRequest: CoreGradesGraderGradingpanelScaleFetchRequest, ): Observable<AxiosResponse<CoreGradesGraderGradingpanelScaleFetch200Response>>;
    public coreGradesGraderGradingpanelScaleFetch(coreGradesGraderGradingpanelScaleFetchRequest: CoreGradesGraderGradingpanelScaleFetchRequest, ): Observable<any> {

        if (coreGradesGraderGradingpanelScaleFetchRequest === null || coreGradesGraderGradingpanelScaleFetchRequest === undefined) {
            throw new Error('Required parameter coreGradesGraderGradingpanelScaleFetchRequest was null or undefined when calling coreGradesGraderGradingpanelScaleFetch.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGraderGradingpanelScaleFetch200Response>(`${this.basePath}/core_grades_grader_gradingpanel_scale_fetch`,
            coreGradesGraderGradingpanelScaleFetchRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Store the data required to display the grader grading panel for scale-based grading
     * Store the data required to display the grader grading panel for scale-based grading
     * @param coreGradesGraderGradingpanelScaleStoreRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesGraderGradingpanelScaleStore(coreGradesGraderGradingpanelScaleStoreRequest: CoreGradesGraderGradingpanelScaleStoreRequest, ): Observable<AxiosResponse<CoreGradesGraderGradingpanelScaleStore200Response>>;
    public coreGradesGraderGradingpanelScaleStore(coreGradesGraderGradingpanelScaleStoreRequest: CoreGradesGraderGradingpanelScaleStoreRequest, ): Observable<any> {

        if (coreGradesGraderGradingpanelScaleStoreRequest === null || coreGradesGraderGradingpanelScaleStoreRequest === undefined) {
            throw new Error('Required parameter coreGradesGraderGradingpanelScaleStoreRequest was null or undefined when calling coreGradesGraderGradingpanelScaleStore.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGraderGradingpanelScaleStore200Response>(`${this.basePath}/core_grades_grader_gradingpanel_scale_store`,
            coreGradesGraderGradingpanelScaleStoreRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a grade item and associated student grades.
     * Update a grade item and associated student grades.
     * @param coreGradesUpdateGradesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradesUpdateGrades(coreGradesUpdateGradesRequest: CoreGradesUpdateGradesRequest, ): Observable<AxiosResponse<object>>;
    public coreGradesUpdateGrades(coreGradesUpdateGradesRequest: CoreGradesUpdateGradesRequest, ): Observable<any> {

        if (coreGradesUpdateGradesRequest === null || coreGradesUpdateGradesRequest === undefined) {
            throw new Error('Required parameter coreGradesUpdateGradesRequest was null or undefined when calling coreGradesUpdateGrades.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_grades_update_grades`,
            coreGradesUpdateGradesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get grading definitions
     * Get grading definitions
     * @param coreGradingGetDefinitionsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradingGetDefinitions(coreGradingGetDefinitionsRequest: CoreGradingGetDefinitionsRequest, ): Observable<AxiosResponse<CoreGradingGetDefinitions200Response>>;
    public coreGradingGetDefinitions(coreGradingGetDefinitionsRequest: CoreGradingGetDefinitionsRequest, ): Observable<any> {

        if (coreGradingGetDefinitionsRequest === null || coreGradingGetDefinitionsRequest === undefined) {
            throw new Error('Required parameter coreGradingGetDefinitionsRequest was null or undefined when calling coreGradingGetDefinitions.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradingGetDefinitions200Response>(`${this.basePath}/core_grading_get_definitions`,
            coreGradingGetDefinitionsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get grading form instances
     * Get grading form instances
     * @param coreGradingGetGradingformInstancesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradingGetGradingformInstances(coreGradingGetGradingformInstancesRequest: CoreGradingGetGradingformInstancesRequest, ): Observable<AxiosResponse<CoreGradingGetGradingformInstances200Response>>;
    public coreGradingGetGradingformInstances(coreGradingGetGradingformInstancesRequest: CoreGradingGetGradingformInstancesRequest, ): Observable<any> {

        if (coreGradingGetGradingformInstancesRequest === null || coreGradingGetGradingformInstancesRequest === undefined) {
            throw new Error('Required parameter coreGradingGetGradingformInstancesRequest was null or undefined when calling coreGradingGetGradingformInstances.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradingGetGradingformInstances200Response>(`${this.basePath}/core_grading_get_gradingform_instances`,
            coreGradingGetGradingformInstancesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Save grading definitions
     * Save grading definitions
     * @param coreGradingSaveDefinitionsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGradingSaveDefinitions(coreGradingSaveDefinitionsRequest: CoreGradingSaveDefinitionsRequest, ): Observable<AxiosResponse<object>>;
    public coreGradingSaveDefinitions(coreGradingSaveDefinitionsRequest: CoreGradingSaveDefinitionsRequest, ): Observable<any> {

        if (coreGradingSaveDefinitionsRequest === null || coreGradingSaveDefinitionsRequest === undefined) {
            throw new Error('Required parameter coreGradingSaveDefinitionsRequest was null or undefined when calling coreGradingSaveDefinitions.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_grading_save_definitions`,
            coreGradingSaveDefinitionsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Adds group members.
     * Adds group members.
     * @param coreGroupAddGroupMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupAddGroupMembers(coreGroupAddGroupMembersRequest: CoreGroupAddGroupMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupAddGroupMembers(coreGroupAddGroupMembersRequest: CoreGroupAddGroupMembersRequest, ): Observable<any> {

        if (coreGroupAddGroupMembersRequest === null || coreGroupAddGroupMembersRequest === undefined) {
            throw new Error('Required parameter coreGroupAddGroupMembersRequest was null or undefined when calling coreGroupAddGroupMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_add_group_members`,
            coreGroupAddGroupMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Assing groups from groupings
     * Assing groups from groupings
     * @param coreGroupAssignGroupingRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupAssignGrouping(coreGroupAssignGroupingRequest: CoreGroupAssignGroupingRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupAssignGrouping(coreGroupAssignGroupingRequest: CoreGroupAssignGroupingRequest, ): Observable<any> {

        if (coreGroupAssignGroupingRequest === null || coreGroupAssignGroupingRequest === undefined) {
            throw new Error('Required parameter coreGroupAssignGroupingRequest was null or undefined when calling coreGroupAssignGrouping.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_assign_grouping`,
            coreGroupAssignGroupingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new groupings
     * Creates new groupings
     * @param coreGroupCreateGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupCreateGroupings(coreGroupCreateGroupingsRequest: CoreGroupCreateGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupCreateGroupings(coreGroupCreateGroupingsRequest: CoreGroupCreateGroupingsRequest, ): Observable<any> {

        if (coreGroupCreateGroupingsRequest === null || coreGroupCreateGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupCreateGroupingsRequest was null or undefined when calling coreGroupCreateGroupings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_create_groupings`,
            coreGroupCreateGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates new groups.
     * Creates new groups.
     * @param coreGroupCreateGroupsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupCreateGroups(coreGroupCreateGroupsRequest: CoreGroupCreateGroupsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupCreateGroups(coreGroupCreateGroupsRequest: CoreGroupCreateGroupsRequest, ): Observable<any> {

        if (coreGroupCreateGroupsRequest === null || coreGroupCreateGroupsRequest === undefined) {
            throw new Error('Required parameter coreGroupCreateGroupsRequest was null or undefined when calling coreGroupCreateGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_create_groups`,
            coreGroupCreateGroupsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes group members.
     * Deletes group members.
     * @param coreGroupDeleteGroupMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupDeleteGroupMembers(coreGroupDeleteGroupMembersRequest: CoreGroupDeleteGroupMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupDeleteGroupMembers(coreGroupDeleteGroupMembersRequest: CoreGroupDeleteGroupMembersRequest, ): Observable<any> {

        if (coreGroupDeleteGroupMembersRequest === null || coreGroupDeleteGroupMembersRequest === undefined) {
            throw new Error('Required parameter coreGroupDeleteGroupMembersRequest was null or undefined when calling coreGroupDeleteGroupMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_delete_group_members`,
            coreGroupDeleteGroupMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes all specified groupings.
     * Deletes all specified groupings.
     * @param coreGroupDeleteGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupDeleteGroupings(coreGroupDeleteGroupingsRequest: CoreGroupDeleteGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupDeleteGroupings(coreGroupDeleteGroupingsRequest: CoreGroupDeleteGroupingsRequest, ): Observable<any> {

        if (coreGroupDeleteGroupingsRequest === null || coreGroupDeleteGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupDeleteGroupingsRequest was null or undefined when calling coreGroupDeleteGroupings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_delete_groupings`,
            coreGroupDeleteGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes all specified groups.
     * Deletes all specified groups.
     * @param coreGroupDeleteGroupsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupDeleteGroups(coreGroupDeleteGroupsRequest: CoreGroupDeleteGroupsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupDeleteGroups(coreGroupDeleteGroupsRequest: CoreGroupDeleteGroupsRequest, ): Observable<any> {

        if (coreGroupDeleteGroupsRequest === null || coreGroupDeleteGroupsRequest === undefined) {
            throw new Error('Required parameter coreGroupDeleteGroupsRequest was null or undefined when calling coreGroupDeleteGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_delete_groups`,
            coreGroupDeleteGroupsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets a list of groups that the user is allowed to access within the specified activity.
     * Gets a list of groups that the user is allowed to access within the specified activity.
     * @param coreGroupGetActivityAllowedGroupsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetActivityAllowedGroups(coreGroupGetActivityAllowedGroupsRequest: CoreGroupGetActivityAllowedGroupsRequest, ): Observable<AxiosResponse<CoreGroupGetActivityAllowedGroups200Response>>;
    public coreGroupGetActivityAllowedGroups(coreGroupGetActivityAllowedGroupsRequest: CoreGroupGetActivityAllowedGroupsRequest, ): Observable<any> {

        if (coreGroupGetActivityAllowedGroupsRequest === null || coreGroupGetActivityAllowedGroupsRequest === undefined) {
            throw new Error('Required parameter coreGroupGetActivityAllowedGroupsRequest was null or undefined when calling coreGroupGetActivityAllowedGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGroupGetActivityAllowedGroups200Response>(`${this.basePath}/core_group_get_activity_allowed_groups`,
            coreGroupGetActivityAllowedGroupsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns effective groupmode used in a given activity.
     * Returns effective groupmode used in a given activity.
     * @param coreGroupGetActivityGroupmodeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetActivityGroupmode(coreGroupGetActivityGroupmodeRequest: CoreGroupGetActivityGroupmodeRequest, ): Observable<AxiosResponse<CoreGroupGetActivityGroupmode200Response>>;
    public coreGroupGetActivityGroupmode(coreGroupGetActivityGroupmodeRequest: CoreGroupGetActivityGroupmodeRequest, ): Observable<any> {

        if (coreGroupGetActivityGroupmodeRequest === null || coreGroupGetActivityGroupmodeRequest === undefined) {
            throw new Error('Required parameter coreGroupGetActivityGroupmodeRequest was null or undefined when calling coreGroupGetActivityGroupmode.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGroupGetActivityGroupmode200Response>(`${this.basePath}/core_group_get_activity_groupmode`,
            coreGroupGetActivityGroupmodeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns all groupings in specified course.
     * Returns all groupings in specified course.
     * @param coreGroupGetCourseGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetCourseGroupings(coreGroupGetCourseGroupingsRequest: CoreGroupGetCourseGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupGetCourseGroupings(coreGroupGetCourseGroupingsRequest: CoreGroupGetCourseGroupingsRequest, ): Observable<any> {

        if (coreGroupGetCourseGroupingsRequest === null || coreGroupGetCourseGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupGetCourseGroupingsRequest was null or undefined when calling coreGroupGetCourseGroupings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_get_course_groupings`,
            coreGroupGetCourseGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns all groups in specified course.
     * Returns all groups in specified course.
     * @param coreGroupGetCourseGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetCourseGroups(coreGroupGetCourseGroupingsRequest: CoreGroupGetCourseGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupGetCourseGroups(coreGroupGetCourseGroupingsRequest: CoreGroupGetCourseGroupingsRequest, ): Observable<any> {

        if (coreGroupGetCourseGroupingsRequest === null || coreGroupGetCourseGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupGetCourseGroupingsRequest was null or undefined when calling coreGroupGetCourseGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_get_course_groups`,
            coreGroupGetCourseGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns all groups in specified course for the specified user.
     * Returns all groups in specified course for the specified user.
     * @param coreGroupGetCourseUserGroupsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetCourseUserGroups(coreGroupGetCourseUserGroupsRequest: CoreGroupGetCourseUserGroupsRequest, ): Observable<AxiosResponse<CoreGroupGetCourseUserGroups200Response>>;
    public coreGroupGetCourseUserGroups(coreGroupGetCourseUserGroupsRequest: CoreGroupGetCourseUserGroupsRequest, ): Observable<any> {

        if (coreGroupGetCourseUserGroupsRequest === null || coreGroupGetCourseUserGroupsRequest === undefined) {
            throw new Error('Required parameter coreGroupGetCourseUserGroupsRequest was null or undefined when calling coreGroupGetCourseUserGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGroupGetCourseUserGroups200Response>(`${this.basePath}/core_group_get_course_user_groups`,
            coreGroupGetCourseUserGroupsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns group members.
     * Returns group members.
     * @param coreGroupGetGroupMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetGroupMembers(coreGroupGetGroupMembersRequest: CoreGroupGetGroupMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupGetGroupMembers(coreGroupGetGroupMembersRequest: CoreGroupGetGroupMembersRequest, ): Observable<any> {

        if (coreGroupGetGroupMembersRequest === null || coreGroupGetGroupMembersRequest === undefined) {
            throw new Error('Required parameter coreGroupGetGroupMembersRequest was null or undefined when calling coreGroupGetGroupMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_get_group_members`,
            coreGroupGetGroupMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns groupings details.
     * Returns groupings details.
     * @param coreGroupGetGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetGroupings(coreGroupGetGroupingsRequest: CoreGroupGetGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupGetGroupings(coreGroupGetGroupingsRequest: CoreGroupGetGroupingsRequest, ): Observable<any> {

        if (coreGroupGetGroupingsRequest === null || coreGroupGetGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupGetGroupingsRequest was null or undefined when calling coreGroupGetGroupings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_get_groupings`,
            coreGroupGetGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns group details.
     * Returns group details.
     * @param coreGroupGetGroupMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetGroups(coreGroupGetGroupMembersRequest: CoreGroupGetGroupMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupGetGroups(coreGroupGetGroupMembersRequest: CoreGroupGetGroupMembersRequest, ): Observable<any> {

        if (coreGroupGetGroupMembersRequest === null || coreGroupGetGroupMembersRequest === undefined) {
            throw new Error('Required parameter coreGroupGetGroupMembersRequest was null or undefined when calling coreGroupGetGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_get_groups`,
            coreGroupGetGroupMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the group/(s) for a course
     * Get the group/(s) for a course
     * @param coreGradesGetGroupsForSearchWidgetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupGetGroupsForSelector(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<AxiosResponse<CoreGradesGetGroupsForSelector200Response>>;
    public coreGroupGetGroupsForSelector(coreGradesGetGroupsForSearchWidgetRequest: CoreGradesGetGroupsForSearchWidgetRequest, ): Observable<any> {

        if (coreGradesGetGroupsForSearchWidgetRequest === null || coreGradesGetGroupsForSearchWidgetRequest === undefined) {
            throw new Error('Required parameter coreGradesGetGroupsForSearchWidgetRequest was null or undefined when calling coreGroupGetGroupsForSelector.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreGradesGetGroupsForSelector200Response>(`${this.basePath}/core_group_get_groups_for_selector`,
            coreGradesGetGroupsForSearchWidgetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unassing groups from groupings
     * Unassing groups from groupings
     * @param coreGroupUnassignGroupingRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupUnassignGrouping(coreGroupUnassignGroupingRequest: CoreGroupUnassignGroupingRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupUnassignGrouping(coreGroupUnassignGroupingRequest: CoreGroupUnassignGroupingRequest, ): Observable<any> {

        if (coreGroupUnassignGroupingRequest === null || coreGroupUnassignGroupingRequest === undefined) {
            throw new Error('Required parameter coreGroupUnassignGroupingRequest was null or undefined when calling coreGroupUnassignGrouping.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_unassign_grouping`,
            coreGroupUnassignGroupingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Updates existing groupings
     * Updates existing groupings
     * @param coreGroupUpdateGroupingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupUpdateGroupings(coreGroupUpdateGroupingsRequest: CoreGroupUpdateGroupingsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupUpdateGroupings(coreGroupUpdateGroupingsRequest: CoreGroupUpdateGroupingsRequest, ): Observable<any> {

        if (coreGroupUpdateGroupingsRequest === null || coreGroupUpdateGroupingsRequest === undefined) {
            throw new Error('Required parameter coreGroupUpdateGroupingsRequest was null or undefined when calling coreGroupUpdateGroupings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_update_groupings`,
            coreGroupUpdateGroupingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Updates existing groups.
     * Updates existing groups.
     * @param coreGroupUpdateGroupsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreGroupUpdateGroups(coreGroupUpdateGroupsRequest: CoreGroupUpdateGroupsRequest, ): Observable<AxiosResponse<object>>;
    public coreGroupUpdateGroups(coreGroupUpdateGroupsRequest: CoreGroupUpdateGroupsRequest, ): Observable<any> {

        if (coreGroupUpdateGroupsRequest === null || coreGroupUpdateGroupsRequest === undefined) {
            throw new Error('Required parameter coreGroupUpdateGroupsRequest was null or undefined when calling coreGroupUpdateGroups.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_group_update_groups`,
            coreGroupUpdateGroupsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the H5P file cleaned for Mobile App.
     * Get the H5P file cleaned for Mobile App.
     * @param coreH5pGetTrustedH5pFileRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreH5pGetTrustedH5pFile(coreH5pGetTrustedH5pFileRequest: CoreH5pGetTrustedH5pFileRequest, ): Observable<AxiosResponse<CoreH5pGetTrustedH5pFile200Response>>;
    public coreH5pGetTrustedH5pFile(coreH5pGetTrustedH5pFileRequest: CoreH5pGetTrustedH5pFileRequest, ): Observable<any> {

        if (coreH5pGetTrustedH5pFileRequest === null || coreH5pGetTrustedH5pFileRequest === undefined) {
            throw new Error('Required parameter coreH5pGetTrustedH5pFileRequest was null or undefined when calling coreH5pGetTrustedH5pFile.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreH5pGetTrustedH5pFile200Response>(`${this.basePath}/core_h5p_get_trusted_h5p_file`,
            coreH5pGetTrustedH5pFileRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Blocks a user
     * Blocks a user
     * @param coreMessageBlockUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageBlockUser(coreMessageBlockUserRequest: CoreMessageBlockUserRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageBlockUser(coreMessageBlockUserRequest: CoreMessageBlockUserRequest, ): Observable<any> {

        if (coreMessageBlockUserRequest === null || coreMessageBlockUserRequest === undefined) {
            throw new Error('Required parameter coreMessageBlockUserRequest was null or undefined when calling coreMessageBlockUser.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_block_user`,
            coreMessageBlockUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Confirms a contact request
     * Confirms a contact request
     * @param coreMessageConfirmContactRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageConfirmContactRequest(coreMessageConfirmContactRequestRequest: CoreMessageConfirmContactRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageConfirmContactRequest(coreMessageConfirmContactRequestRequest: CoreMessageConfirmContactRequestRequest, ): Observable<any> {

        if (coreMessageConfirmContactRequestRequest === null || coreMessageConfirmContactRequestRequest === undefined) {
            throw new Error('Required parameter coreMessageConfirmContactRequestRequest was null or undefined when calling coreMessageConfirmContactRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_confirm_contact_request`,
            coreMessageConfirmContactRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Creates a contact request
     * Creates a contact request
     * @param coreMessageCreateContactRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageCreateContactRequest(coreMessageCreateContactRequestRequest: CoreMessageCreateContactRequestRequest, ): Observable<AxiosResponse<CoreMessageCreateContactRequest200Response>>;
    public coreMessageCreateContactRequest(coreMessageCreateContactRequestRequest: CoreMessageCreateContactRequestRequest, ): Observable<any> {

        if (coreMessageCreateContactRequestRequest === null || coreMessageCreateContactRequestRequest === undefined) {
            throw new Error('Required parameter coreMessageCreateContactRequestRequest was null or undefined when calling coreMessageCreateContactRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageCreateContactRequest200Response>(`${this.basePath}/core_message_create_contact_request`,
            coreMessageCreateContactRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve the template data for searching for messages
     * Retrieve the template data for searching for messages
     * @param coreMessageDataForMessageareaSearchMessagesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDataForMessageareaSearchMessages(coreMessageDataForMessageareaSearchMessagesRequest: CoreMessageDataForMessageareaSearchMessagesRequest, ): Observable<AxiosResponse<CoreMessageDataForMessageareaSearchMessages200Response>>;
    public coreMessageDataForMessageareaSearchMessages(coreMessageDataForMessageareaSearchMessagesRequest: CoreMessageDataForMessageareaSearchMessagesRequest, ): Observable<any> {

        if (coreMessageDataForMessageareaSearchMessagesRequest === null || coreMessageDataForMessageareaSearchMessagesRequest === undefined) {
            throw new Error('Required parameter coreMessageDataForMessageareaSearchMessagesRequest was null or undefined when calling coreMessageDataForMessageareaSearchMessages.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageDataForMessageareaSearchMessages200Response>(`${this.basePath}/core_message_data_for_messagearea_search_messages`,
            coreMessageDataForMessageareaSearchMessagesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Declines a contact request
     * Declines a contact request
     * @param coreMessageCreateContactRequestRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDeclineContactRequest(coreMessageCreateContactRequestRequest: CoreMessageCreateContactRequestRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageDeclineContactRequest(coreMessageCreateContactRequestRequest: CoreMessageCreateContactRequestRequest, ): Observable<any> {

        if (coreMessageCreateContactRequestRequest === null || coreMessageCreateContactRequestRequest === undefined) {
            throw new Error('Required parameter coreMessageCreateContactRequestRequest was null or undefined when calling coreMessageDeclineContactRequest.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_decline_contact_request`,
            coreMessageCreateContactRequestRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove contacts from the contact list
     * Remove contacts from the contact list
     * @param coreMessageDeleteContactsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDeleteContacts(coreMessageDeleteContactsRequest: CoreMessageDeleteContactsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageDeleteContacts(coreMessageDeleteContactsRequest: CoreMessageDeleteContactsRequest, ): Observable<any> {

        if (coreMessageDeleteContactsRequest === null || coreMessageDeleteContactsRequest === undefined) {
            throw new Error('Required parameter coreMessageDeleteContactsRequest was null or undefined when calling coreMessageDeleteContacts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_delete_contacts`,
            coreMessageDeleteContactsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes a list of conversations.
     * Deletes a list of conversations.
     * @param coreMessageDeleteConversationsByIdRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDeleteConversationsById(coreMessageDeleteConversationsByIdRequest: CoreMessageDeleteConversationsByIdRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageDeleteConversationsById(coreMessageDeleteConversationsByIdRequest: CoreMessageDeleteConversationsByIdRequest, ): Observable<any> {

        if (coreMessageDeleteConversationsByIdRequest === null || coreMessageDeleteConversationsByIdRequest === undefined) {
            throw new Error('Required parameter coreMessageDeleteConversationsByIdRequest was null or undefined when calling coreMessageDeleteConversationsById.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_delete_conversations_by_id`,
            coreMessageDeleteConversationsByIdRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes a message.
     * Deletes a message.
     * @param coreMessageDeleteMessageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDeleteMessage(coreMessageDeleteMessageRequest: CoreMessageDeleteMessageRequest, ): Observable<AxiosResponse<CoreMessageDeleteMessage200Response>>;
    public coreMessageDeleteMessage(coreMessageDeleteMessageRequest: CoreMessageDeleteMessageRequest, ): Observable<any> {

        if (coreMessageDeleteMessageRequest === null || coreMessageDeleteMessageRequest === undefined) {
            throw new Error('Required parameter coreMessageDeleteMessageRequest was null or undefined when calling coreMessageDeleteMessage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageDeleteMessage200Response>(`${this.basePath}/core_message_delete_message`,
            coreMessageDeleteMessageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Deletes a message for all users.
     * Deletes a message for all users.
     * @param coreMessageDeleteMessageForAllUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageDeleteMessageForAllUsers(coreMessageDeleteMessageForAllUsersRequest: CoreMessageDeleteMessageForAllUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageDeleteMessageForAllUsers(coreMessageDeleteMessageForAllUsersRequest: CoreMessageDeleteMessageForAllUsersRequest, ): Observable<any> {

        if (coreMessageDeleteMessageForAllUsersRequest === null || coreMessageDeleteMessageForAllUsersRequest === undefined) {
            throw new Error('Required parameter coreMessageDeleteMessageForAllUsersRequest was null or undefined when calling coreMessageDeleteMessageForAllUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_delete_message_for_all_users`,
            coreMessageDeleteMessageForAllUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of users blocked
     * Retrieve a list of users blocked
     * @param coreMessageGetBlockedUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetBlockedUsers(coreMessageGetBlockedUsersRequest: CoreMessageGetBlockedUsersRequest, ): Observable<AxiosResponse<CoreMessageGetBlockedUsers200Response>>;
    public coreMessageGetBlockedUsers(coreMessageGetBlockedUsersRequest: CoreMessageGetBlockedUsersRequest, ): Observable<any> {

        if (coreMessageGetBlockedUsersRequest === null || coreMessageGetBlockedUsersRequest === undefined) {
            throw new Error('Required parameter coreMessageGetBlockedUsersRequest was null or undefined when calling coreMessageGetBlockedUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetBlockedUsers200Response>(`${this.basePath}/core_message_get_blocked_users`,
            coreMessageGetBlockedUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns contact requests for a user
     * Returns contact requests for a user
     * @param coreMessageGetContactRequestsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetContactRequests(coreMessageGetContactRequestsRequest: CoreMessageGetContactRequestsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetContactRequests(coreMessageGetContactRequestsRequest: CoreMessageGetContactRequestsRequest, ): Observable<any> {

        if (coreMessageGetContactRequestsRequest === null || coreMessageGetContactRequestsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetContactRequestsRequest was null or undefined when calling coreMessageGetContactRequests.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_contact_requests`,
            coreMessageGetContactRequestsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a conversation for a user
     * Retrieve a conversation for a user
     * @param coreMessageGetConversationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversation(coreMessageGetConversationRequest: CoreMessageGetConversationRequest, ): Observable<AxiosResponse<CoreMessageGetConversation200Response>>;
    public coreMessageGetConversation(coreMessageGetConversationRequest: CoreMessageGetConversationRequest, ): Observable<any> {

        if (coreMessageGetConversationRequest === null || coreMessageGetConversationRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationRequest was null or undefined when calling coreMessageGetConversation.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversation200Response>(`${this.basePath}/core_message_get_conversation`,
            coreMessageGetConversationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a conversation for a user between another user
     * Retrieve a conversation for a user between another user
     * @param coreMessageGetConversationBetweenUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversationBetweenUsers(coreMessageGetConversationBetweenUsersRequest: CoreMessageGetConversationBetweenUsersRequest, ): Observable<AxiosResponse<CoreMessageGetConversationBetweenUsers200Response>>;
    public coreMessageGetConversationBetweenUsers(coreMessageGetConversationBetweenUsersRequest: CoreMessageGetConversationBetweenUsersRequest, ): Observable<any> {

        if (coreMessageGetConversationBetweenUsersRequest === null || coreMessageGetConversationBetweenUsersRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationBetweenUsersRequest was null or undefined when calling coreMessageGetConversationBetweenUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversationBetweenUsers200Response>(`${this.basePath}/core_message_get_conversation_between_users`,
            coreMessageGetConversationBetweenUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of conversation counts, indexed by type.
     * Retrieve a list of conversation counts, indexed by type.
     * @param coreMessageGetConversationCountsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversationCounts(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<AxiosResponse<CoreMessageGetConversationCounts200Response>>;
    public coreMessageGetConversationCounts(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<any> {

        if (coreMessageGetConversationCountsRequest === null || coreMessageGetConversationCountsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationCountsRequest was null or undefined when calling coreMessageGetConversationCounts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversationCounts200Response>(`${this.basePath}/core_message_get_conversation_counts`,
            coreMessageGetConversationCountsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of members in a conversation
     * Retrieve a list of members in a conversation
     * @param coreMessageGetConversationMembersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversationMembers(coreMessageGetConversationMembersRequest: CoreMessageGetConversationMembersRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetConversationMembers(coreMessageGetConversationMembersRequest: CoreMessageGetConversationMembersRequest, ): Observable<any> {

        if (coreMessageGetConversationMembersRequest === null || coreMessageGetConversationMembersRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationMembersRequest was null or undefined when calling coreMessageGetConversationMembers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_conversation_members`,
            coreMessageGetConversationMembersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve the conversation messages and relevant member information
     * Retrieve the conversation messages and relevant member information
     * @param coreMessageGetConversationMessagesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversationMessages(coreMessageGetConversationMessagesRequest: CoreMessageGetConversationMessagesRequest, ): Observable<AxiosResponse<CoreMessageGetConversationMessages200Response>>;
    public coreMessageGetConversationMessages(coreMessageGetConversationMessagesRequest: CoreMessageGetConversationMessagesRequest, ): Observable<any> {

        if (coreMessageGetConversationMessagesRequest === null || coreMessageGetConversationMessagesRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationMessagesRequest was null or undefined when calling coreMessageGetConversationMessages.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversationMessages200Response>(`${this.basePath}/core_message_get_conversation_messages`,
            coreMessageGetConversationMessagesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of conversations for a user
     * Retrieve a list of conversations for a user
     * @param coreMessageGetConversationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetConversations(coreMessageGetConversationsRequest: CoreMessageGetConversationsRequest, ): Observable<AxiosResponse<CoreMessageGetConversations200Response>>;
    public coreMessageGetConversations(coreMessageGetConversationsRequest: CoreMessageGetConversationsRequest, ): Observable<any> {

        if (coreMessageGetConversationsRequest === null || coreMessageGetConversationsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationsRequest was null or undefined when calling coreMessageGetConversations.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversations200Response>(`${this.basePath}/core_message_get_conversations`,
            coreMessageGetConversationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a user message profiles
     * Retrieve a user message profiles
     * @param coreMessageGetMemberInfoRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetMemberInfo(coreMessageGetMemberInfoRequest: CoreMessageGetMemberInfoRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetMemberInfo(coreMessageGetMemberInfoRequest: CoreMessageGetMemberInfoRequest, ): Observable<any> {

        if (coreMessageGetMemberInfoRequest === null || coreMessageGetMemberInfoRequest === undefined) {
            throw new Error('Required parameter coreMessageGetMemberInfoRequest was null or undefined when calling coreMessageGetMemberInfo.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_member_info`,
            coreMessageGetMemberInfoRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get a message processor
     * Get a message processor
     * @param coreMessageGetMessageProcessorRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetMessageProcessor(coreMessageGetMessageProcessorRequest: CoreMessageGetMessageProcessorRequest, ): Observable<AxiosResponse<CoreMessageGetMessageProcessor200Response>>;
    public coreMessageGetMessageProcessor(coreMessageGetMessageProcessorRequest: CoreMessageGetMessageProcessorRequest, ): Observable<any> {

        if (coreMessageGetMessageProcessorRequest === null || coreMessageGetMessageProcessorRequest === undefined) {
            throw new Error('Required parameter coreMessageGetMessageProcessorRequest was null or undefined when calling coreMessageGetMessageProcessor.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetMessageProcessor200Response>(`${this.basePath}/core_message_get_message_processor`,
            coreMessageGetMessageProcessorRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of messages sent and received by a user (conversations, notifications or both)
     * Retrieve a list of messages sent and received by a user (conversations, notifications or both)
     * @param coreMessageGetMessagesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetMessages(coreMessageGetMessagesRequest: CoreMessageGetMessagesRequest, ): Observable<AxiosResponse<CoreMessageGetMessages200Response>>;
    public coreMessageGetMessages(coreMessageGetMessagesRequest: CoreMessageGetMessagesRequest, ): Observable<any> {

        if (coreMessageGetMessagesRequest === null || coreMessageGetMessagesRequest === undefined) {
            throw new Error('Required parameter coreMessageGetMessagesRequest was null or undefined when calling coreMessageGetMessages.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetMessages200Response>(`${this.basePath}/core_message_get_messages`,
            coreMessageGetMessagesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets the number of received contact requests
     * Gets the number of received contact requests
     * @param coreMessageGetReceivedContactRequestsCountRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetReceivedContactRequestsCount(coreMessageGetReceivedContactRequestsCountRequest: CoreMessageGetReceivedContactRequestsCountRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetReceivedContactRequestsCount(coreMessageGetReceivedContactRequestsCountRequest: CoreMessageGetReceivedContactRequestsCountRequest, ): Observable<any> {

        if (coreMessageGetReceivedContactRequestsCountRequest === null || coreMessageGetReceivedContactRequestsCountRequest === undefined) {
            throw new Error('Required parameter coreMessageGetReceivedContactRequestsCountRequest was null or undefined when calling coreMessageGetReceivedContactRequestsCount.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_received_contact_requests_count`,
            coreMessageGetReceivedContactRequestsCountRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a self-conversation for a user
     * Retrieve a self-conversation for a user
     * @param coreMessageGetSelfConversationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetSelfConversation(coreMessageGetSelfConversationRequest: CoreMessageGetSelfConversationRequest, ): Observable<AxiosResponse<CoreMessageGetConversationBetweenUsers200Response>>;
    public coreMessageGetSelfConversation(coreMessageGetSelfConversationRequest: CoreMessageGetSelfConversationRequest, ): Observable<any> {

        if (coreMessageGetSelfConversationRequest === null || coreMessageGetSelfConversationRequest === undefined) {
            throw new Error('Required parameter coreMessageGetSelfConversationRequest was null or undefined when calling coreMessageGetSelfConversation.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetConversationBetweenUsers200Response>(`${this.basePath}/core_message_get_self_conversation`,
            coreMessageGetSelfConversationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve a list of unread conversation counts, indexed by type.
     * Retrieve a list of unread conversation counts, indexed by type.
     * @param coreMessageGetConversationCountsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUnreadConversationCounts(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<AxiosResponse<CoreMessageGetUnreadConversationCounts200Response>>;
    public coreMessageGetUnreadConversationCounts(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<any> {

        if (coreMessageGetConversationCountsRequest === null || coreMessageGetConversationCountsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationCountsRequest was null or undefined when calling coreMessageGetUnreadConversationCounts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetUnreadConversationCounts200Response>(`${this.basePath}/core_message_get_unread_conversation_counts`,
            coreMessageGetConversationCountsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve the count of unread conversations for a given user
     * Retrieve the count of unread conversations for a given user
     * @param coreMessageGetUnreadConversationsCountRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUnreadConversationsCount(coreMessageGetUnreadConversationsCountRequest: CoreMessageGetUnreadConversationsCountRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetUnreadConversationsCount(coreMessageGetUnreadConversationsCountRequest: CoreMessageGetUnreadConversationsCountRequest, ): Observable<any> {

        if (coreMessageGetUnreadConversationsCountRequest === null || coreMessageGetUnreadConversationsCountRequest === undefined) {
            throw new Error('Required parameter coreMessageGetUnreadConversationsCountRequest was null or undefined when calling coreMessageGetUnreadConversationsCount.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_unread_conversations_count`,
            coreMessageGetUnreadConversationsCountRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get number of unread notifications.
     * Get number of unread notifications.
     * @param coreMessageGetUnreadNotificationCountRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUnreadNotificationCount(coreMessageGetUnreadNotificationCountRequest: CoreMessageGetUnreadNotificationCountRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetUnreadNotificationCount(coreMessageGetUnreadNotificationCountRequest: CoreMessageGetUnreadNotificationCountRequest, ): Observable<any> {

        if (coreMessageGetUnreadNotificationCountRequest === null || coreMessageGetUnreadNotificationCountRequest === undefined) {
            throw new Error('Required parameter coreMessageGetUnreadNotificationCountRequest was null or undefined when calling coreMessageGetUnreadNotificationCount.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_unread_notification_count`,
            coreMessageGetUnreadNotificationCountRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve the contact list
     * Retrieve the contact list
     * @param coreMessageGetUserContactsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUserContacts(coreMessageGetUserContactsRequest: CoreMessageGetUserContactsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageGetUserContacts(coreMessageGetUserContactsRequest: CoreMessageGetUserContactsRequest, ): Observable<any> {

        if (coreMessageGetUserContactsRequest === null || coreMessageGetUserContactsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetUserContactsRequest was null or undefined when calling coreMessageGetUserContacts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_get_user_contacts`,
            coreMessageGetUserContactsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the message preferences for a given user.
     * Get the message preferences for a given user.
     * @param coreMessageGetConversationCountsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUserMessagePreferences(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<AxiosResponse<CoreMessageGetUserMessagePreferences200Response>>;
    public coreMessageGetUserMessagePreferences(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<any> {

        if (coreMessageGetConversationCountsRequest === null || coreMessageGetConversationCountsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationCountsRequest was null or undefined when calling coreMessageGetUserMessagePreferences.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetUserMessagePreferences200Response>(`${this.basePath}/core_message_get_user_message_preferences`,
            coreMessageGetConversationCountsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the notification preferences for a given user.
     * Get the notification preferences for a given user.
     * @param coreMessageGetConversationCountsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageGetUserNotificationPreferences(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<AxiosResponse<CoreMessageGetUserNotificationPreferences200Response>>;
    public coreMessageGetUserNotificationPreferences(coreMessageGetConversationCountsRequest: CoreMessageGetConversationCountsRequest, ): Observable<any> {

        if (coreMessageGetConversationCountsRequest === null || coreMessageGetConversationCountsRequest === undefined) {
            throw new Error('Required parameter coreMessageGetConversationCountsRequest was null or undefined when calling coreMessageGetUserNotificationPreferences.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageGetUserNotificationPreferences200Response>(`${this.basePath}/core_message_get_user_notification_preferences`,
            coreMessageGetConversationCountsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mark all conversation messages as read for a given user
     * Mark all conversation messages as read for a given user
     * @param coreMessageMarkAllConversationMessagesAsReadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMarkAllConversationMessagesAsRead(coreMessageMarkAllConversationMessagesAsReadRequest: CoreMessageMarkAllConversationMessagesAsReadRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageMarkAllConversationMessagesAsRead(coreMessageMarkAllConversationMessagesAsReadRequest: CoreMessageMarkAllConversationMessagesAsReadRequest, ): Observable<any> {

        if (coreMessageMarkAllConversationMessagesAsReadRequest === null || coreMessageMarkAllConversationMessagesAsReadRequest === undefined) {
            throw new Error('Required parameter coreMessageMarkAllConversationMessagesAsReadRequest was null or undefined when calling coreMessageMarkAllConversationMessagesAsRead.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_mark_all_conversation_messages_as_read`,
            coreMessageMarkAllConversationMessagesAsReadRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mark all notifications as read for a given user
     * Mark all notifications as read for a given user
     * @param coreMessageMarkAllNotificationsAsReadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMarkAllNotificationsAsRead(coreMessageMarkAllNotificationsAsReadRequest: CoreMessageMarkAllNotificationsAsReadRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageMarkAllNotificationsAsRead(coreMessageMarkAllNotificationsAsReadRequest: CoreMessageMarkAllNotificationsAsReadRequest, ): Observable<any> {

        if (coreMessageMarkAllNotificationsAsReadRequest === null || coreMessageMarkAllNotificationsAsReadRequest === undefined) {
            throw new Error('Required parameter coreMessageMarkAllNotificationsAsReadRequest was null or undefined when calling coreMessageMarkAllNotificationsAsRead.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_mark_all_notifications_as_read`,
            coreMessageMarkAllNotificationsAsReadRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mark a single message as read, trigger message_viewed event.
     * Mark a single message as read, trigger message_viewed event.
     * @param coreMessageMarkMessageReadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMarkMessageRead(coreMessageMarkMessageReadRequest: CoreMessageMarkMessageReadRequest, ): Observable<AxiosResponse<CoreMessageMarkMessageRead200Response>>;
    public coreMessageMarkMessageRead(coreMessageMarkMessageReadRequest: CoreMessageMarkMessageReadRequest, ): Observable<any> {

        if (coreMessageMarkMessageReadRequest === null || coreMessageMarkMessageReadRequest === undefined) {
            throw new Error('Required parameter coreMessageMarkMessageReadRequest was null or undefined when calling coreMessageMarkMessageRead.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageMarkMessageRead200Response>(`${this.basePath}/core_message_mark_message_read`,
            coreMessageMarkMessageReadRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mark a single notification as read, trigger notification_viewed event.
     * Mark a single notification as read, trigger notification_viewed event.
     * @param coreMessageMarkNotificationReadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMarkNotificationRead(coreMessageMarkNotificationReadRequest: CoreMessageMarkNotificationReadRequest, ): Observable<AxiosResponse<CoreMessageMarkNotificationRead200Response>>;
    public coreMessageMarkNotificationRead(coreMessageMarkNotificationReadRequest: CoreMessageMarkNotificationReadRequest, ): Observable<any> {

        if (coreMessageMarkNotificationReadRequest === null || coreMessageMarkNotificationReadRequest === undefined) {
            throw new Error('Required parameter coreMessageMarkNotificationReadRequest was null or undefined when calling coreMessageMarkNotificationRead.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageMarkNotificationRead200Response>(`${this.basePath}/core_message_mark_notification_read`,
            coreMessageMarkNotificationReadRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Process the message processor config form
     * Process the message processor config form
     * @param coreMessageMessageProcessorConfigFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMessageProcessorConfigForm(coreMessageMessageProcessorConfigFormRequest: CoreMessageMessageProcessorConfigFormRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageMessageProcessorConfigForm(coreMessageMessageProcessorConfigFormRequest: CoreMessageMessageProcessorConfigFormRequest, ): Observable<any> {

        if (coreMessageMessageProcessorConfigFormRequest === null || coreMessageMessageProcessorConfigFormRequest === undefined) {
            throw new Error('Required parameter coreMessageMessageProcessorConfigFormRequest was null or undefined when calling coreMessageMessageProcessorConfigForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_message_processor_config_form`,
            coreMessageMessageProcessorConfigFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve the data for searching for people
     * Retrieve the data for searching for people
     * @param coreMessageMessageSearchUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMessageSearchUsers(coreMessageMessageSearchUsersRequest: CoreMessageMessageSearchUsersRequest, ): Observable<AxiosResponse<CoreMessageMessageSearchUsers200Response>>;
    public coreMessageMessageSearchUsers(coreMessageMessageSearchUsersRequest: CoreMessageMessageSearchUsersRequest, ): Observable<any> {

        if (coreMessageMessageSearchUsersRequest === null || coreMessageMessageSearchUsersRequest === undefined) {
            throw new Error('Required parameter coreMessageMessageSearchUsersRequest was null or undefined when calling coreMessageMessageSearchUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMessageMessageSearchUsers200Response>(`${this.basePath}/core_message_message_search_users`,
            coreMessageMessageSearchUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mutes a list of conversations
     * Mutes a list of conversations
     * @param coreMessageMuteConversationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageMuteConversations(coreMessageMuteConversationsRequest: CoreMessageMuteConversationsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageMuteConversations(coreMessageMuteConversationsRequest: CoreMessageMuteConversationsRequest, ): Observable<any> {

        if (coreMessageMuteConversationsRequest === null || coreMessageMuteConversationsRequest === undefined) {
            throw new Error('Required parameter coreMessageMuteConversationsRequest was null or undefined when calling coreMessageMuteConversations.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_mute_conversations`,
            coreMessageMuteConversationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Search for contacts
     * Search for contacts
     * @param coreMessageSearchContactsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageSearchContacts(coreMessageSearchContactsRequest: CoreMessageSearchContactsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageSearchContacts(coreMessageSearchContactsRequest: CoreMessageSearchContactsRequest, ): Observable<any> {

        if (coreMessageSearchContactsRequest === null || coreMessageSearchContactsRequest === undefined) {
            throw new Error('Required parameter coreMessageSearchContactsRequest was null or undefined when calling coreMessageSearchContacts.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_search_contacts`,
            coreMessageSearchContactsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send instant messages
     * Send instant messages
     * @param coreMessageSendInstantMessagesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageSendInstantMessages(coreMessageSendInstantMessagesRequest: CoreMessageSendInstantMessagesRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageSendInstantMessages(coreMessageSendInstantMessagesRequest: CoreMessageSendInstantMessagesRequest, ): Observable<any> {

        if (coreMessageSendInstantMessagesRequest === null || coreMessageSendInstantMessagesRequest === undefined) {
            throw new Error('Required parameter coreMessageSendInstantMessagesRequest was null or undefined when calling coreMessageSendInstantMessages.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_send_instant_messages`,
            coreMessageSendInstantMessagesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send messages to an existing conversation between users
     * Send messages to an existing conversation between users
     * @param coreMessageSendMessagesToConversationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageSendMessagesToConversation(coreMessageSendMessagesToConversationRequest: CoreMessageSendMessagesToConversationRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageSendMessagesToConversation(coreMessageSendMessagesToConversationRequest: CoreMessageSendMessagesToConversationRequest, ): Observable<any> {

        if (coreMessageSendMessagesToConversationRequest === null || coreMessageSendMessagesToConversationRequest === undefined) {
            throw new Error('Required parameter coreMessageSendMessagesToConversationRequest was null or undefined when calling coreMessageSendMessagesToConversation.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_send_messages_to_conversation`,
            coreMessageSendMessagesToConversationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Mark a conversation or group of conversations as favourites/starred conversations.
     * Mark a conversation or group of conversations as favourites/starred conversations.
     * @param coreMessageSetFavouriteConversationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageSetFavouriteConversations(coreMessageSetFavouriteConversationsRequest: CoreMessageSetFavouriteConversationsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageSetFavouriteConversations(coreMessageSetFavouriteConversationsRequest: CoreMessageSetFavouriteConversationsRequest, ): Observable<any> {

        if (coreMessageSetFavouriteConversationsRequest === null || coreMessageSetFavouriteConversationsRequest === undefined) {
            throw new Error('Required parameter coreMessageSetFavouriteConversationsRequest was null or undefined when calling coreMessageSetFavouriteConversations.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_set_favourite_conversations`,
            coreMessageSetFavouriteConversationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unblocks a user
     * Unblocks a user
     * @param coreMessageUnblockUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageUnblockUser(coreMessageUnblockUserRequest: CoreMessageUnblockUserRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageUnblockUser(coreMessageUnblockUserRequest: CoreMessageUnblockUserRequest, ): Observable<any> {

        if (coreMessageUnblockUserRequest === null || coreMessageUnblockUserRequest === undefined) {
            throw new Error('Required parameter coreMessageUnblockUserRequest was null or undefined when calling coreMessageUnblockUser.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_unblock_user`,
            coreMessageUnblockUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unmutes a list of conversations
     * Unmutes a list of conversations
     * @param coreMessageUnmuteConversationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageUnmuteConversations(coreMessageUnmuteConversationsRequest: CoreMessageUnmuteConversationsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageUnmuteConversations(coreMessageUnmuteConversationsRequest: CoreMessageUnmuteConversationsRequest, ): Observable<any> {

        if (coreMessageUnmuteConversationsRequest === null || coreMessageUnmuteConversationsRequest === undefined) {
            throw new Error('Required parameter coreMessageUnmuteConversationsRequest was null or undefined when calling coreMessageUnmuteConversations.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_unmute_conversations`,
            coreMessageUnmuteConversationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Unset a conversation or group of conversations as favourites/starred conversations.
     * Unset a conversation or group of conversations as favourites/starred conversations.
     * @param coreMessageSetFavouriteConversationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMessageUnsetFavouriteConversations(coreMessageSetFavouriteConversationsRequest: CoreMessageSetFavouriteConversationsRequest, ): Observable<AxiosResponse<object>>;
    public coreMessageUnsetFavouriteConversations(coreMessageSetFavouriteConversationsRequest: CoreMessageSetFavouriteConversationsRequest, ): Observable<any> {

        if (coreMessageSetFavouriteConversationsRequest === null || coreMessageSetFavouriteConversationsRequest === undefined) {
            throw new Error('Required parameter coreMessageSetFavouriteConversationsRequest was null or undefined when calling coreMessageUnsetFavouriteConversations.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_message_unset_favourite_conversations`,
            coreMessageSetFavouriteConversationsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Check a user has authorized for a given MoodleNet site
     * Check a user has authorized for a given MoodleNet site
     * @param coreMoodlenetAuthCheckRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMoodlenetAuthCheck(coreMoodlenetAuthCheckRequest: CoreMoodlenetAuthCheckRequest, ): Observable<AxiosResponse<CoreMoodlenetAuthCheck200Response>>;
    public coreMoodlenetAuthCheck(coreMoodlenetAuthCheckRequest: CoreMoodlenetAuthCheckRequest, ): Observable<any> {

        if (coreMoodlenetAuthCheckRequest === null || coreMoodlenetAuthCheckRequest === undefined) {
            throw new Error('Required parameter coreMoodlenetAuthCheckRequest was null or undefined when calling coreMoodlenetAuthCheck.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMoodlenetAuthCheck200Response>(`${this.basePath}/core_moodlenet_auth_check`,
            coreMoodlenetAuthCheckRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get information about an activity being shared
     * Get information about an activity being shared
     * @param coreMoodlenetGetShareInfoActivityRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMoodlenetGetShareInfoActivity(coreMoodlenetGetShareInfoActivityRequest: CoreMoodlenetGetShareInfoActivityRequest, ): Observable<AxiosResponse<CoreMoodlenetGetShareInfoActivity200Response>>;
    public coreMoodlenetGetShareInfoActivity(coreMoodlenetGetShareInfoActivityRequest: CoreMoodlenetGetShareInfoActivityRequest, ): Observable<any> {

        if (coreMoodlenetGetShareInfoActivityRequest === null || coreMoodlenetGetShareInfoActivityRequest === undefined) {
            throw new Error('Required parameter coreMoodlenetGetShareInfoActivityRequest was null or undefined when calling coreMoodlenetGetShareInfoActivity.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMoodlenetGetShareInfoActivity200Response>(`${this.basePath}/core_moodlenet_get_share_info_activity`,
            coreMoodlenetGetShareInfoActivityRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get information about an course being shared
     * Get information about an course being shared
     * @param coreMoodlenetGetSharedCourseInfoRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMoodlenetGetSharedCourseInfo(coreMoodlenetGetSharedCourseInfoRequest: CoreMoodlenetGetSharedCourseInfoRequest, ): Observable<AxiosResponse<CoreMoodlenetGetSharedCourseInfo200Response>>;
    public coreMoodlenetGetSharedCourseInfo(coreMoodlenetGetSharedCourseInfoRequest: CoreMoodlenetGetSharedCourseInfoRequest, ): Observable<any> {

        if (coreMoodlenetGetSharedCourseInfoRequest === null || coreMoodlenetGetSharedCourseInfoRequest === undefined) {
            throw new Error('Required parameter coreMoodlenetGetSharedCourseInfoRequest was null or undefined when calling coreMoodlenetGetSharedCourseInfo.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMoodlenetGetSharedCourseInfo200Response>(`${this.basePath}/core_moodlenet_get_shared_course_info`,
            coreMoodlenetGetSharedCourseInfoRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send activity to MoodleNet
     * Send activity to MoodleNet
     * @param coreMoodlenetSendActivityRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMoodlenetSendActivity(coreMoodlenetSendActivityRequest: CoreMoodlenetSendActivityRequest, ): Observable<AxiosResponse<CoreMoodlenetSendActivity200Response>>;
    public coreMoodlenetSendActivity(coreMoodlenetSendActivityRequest: CoreMoodlenetSendActivityRequest, ): Observable<any> {

        if (coreMoodlenetSendActivityRequest === null || coreMoodlenetSendActivityRequest === undefined) {
            throw new Error('Required parameter coreMoodlenetSendActivityRequest was null or undefined when calling coreMoodlenetSendActivity.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMoodlenetSendActivity200Response>(`${this.basePath}/core_moodlenet_send_activity`,
            coreMoodlenetSendActivityRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send course to MoodleNet
     * Send course to MoodleNet
     * @param coreMoodlenetSendCourseRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMoodlenetSendCourse(coreMoodlenetSendCourseRequest: CoreMoodlenetSendCourseRequest, ): Observable<AxiosResponse<CoreMoodlenetSendCourse200Response>>;
    public coreMoodlenetSendCourse(coreMoodlenetSendCourseRequest: CoreMoodlenetSendCourseRequest, ): Observable<any> {

        if (coreMoodlenetSendCourseRequest === null || coreMoodlenetSendCourseRequest === undefined) {
            throw new Error('Required parameter coreMoodlenetSendCourseRequest was null or undefined when calling coreMoodlenetSendCourse.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreMoodlenetSendCourse200Response>(`${this.basePath}/core_moodlenet_send_course`,
            coreMoodlenetSendCourseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Trigger the My or Dashboard viewed event.
     * Trigger the My or Dashboard viewed event.
     * @param coreMyViewPageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreMyViewPage(coreMyViewPageRequest: CoreMyViewPageRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreMyViewPage(coreMyViewPageRequest: CoreMyViewPageRequest, ): Observable<any> {

        if (coreMyViewPageRequest === null || coreMyViewPageRequest === undefined) {
            throw new Error('Required parameter coreMyViewPageRequest was null or undefined when calling coreMyViewPage.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_my_view_page`,
            coreMyViewPageRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create notes
     * Create notes
     * @param coreNotesCreateNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesCreateNotes(coreNotesCreateNotesRequest: CoreNotesCreateNotesRequest, ): Observable<AxiosResponse<object>>;
    public coreNotesCreateNotes(coreNotesCreateNotesRequest: CoreNotesCreateNotesRequest, ): Observable<any> {

        if (coreNotesCreateNotesRequest === null || coreNotesCreateNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesCreateNotesRequest was null or undefined when calling coreNotesCreateNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_notes_create_notes`,
            coreNotesCreateNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete notes
     * Delete notes
     * @param coreNotesDeleteNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesDeleteNotes(coreNotesDeleteNotesRequest: CoreNotesDeleteNotesRequest, ): Observable<AxiosResponse<object>>;
    public coreNotesDeleteNotes(coreNotesDeleteNotesRequest: CoreNotesDeleteNotesRequest, ): Observable<any> {

        if (coreNotesDeleteNotesRequest === null || coreNotesDeleteNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesDeleteNotesRequest was null or undefined when calling coreNotesDeleteNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_notes_delete_notes`,
            coreNotesDeleteNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns all notes in specified course (or site), for the specified user.
     * Returns all notes in specified course (or site), for the specified user.
     * @param coreNotesGetCourseNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesGetCourseNotes(coreNotesGetCourseNotesRequest: CoreNotesGetCourseNotesRequest, ): Observable<AxiosResponse<CoreNotesGetCourseNotes200Response>>;
    public coreNotesGetCourseNotes(coreNotesGetCourseNotesRequest: CoreNotesGetCourseNotesRequest, ): Observable<any> {

        if (coreNotesGetCourseNotesRequest === null || coreNotesGetCourseNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesGetCourseNotesRequest was null or undefined when calling coreNotesGetCourseNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreNotesGetCourseNotes200Response>(`${this.basePath}/core_notes_get_course_notes`,
            coreNotesGetCourseNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get notes
     * Get notes
     * @param coreNotesGetNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesGetNotes(coreNotesGetNotesRequest: CoreNotesGetNotesRequest, ): Observable<AxiosResponse<CoreNotesGetNotes200Response>>;
    public coreNotesGetNotes(coreNotesGetNotesRequest: CoreNotesGetNotesRequest, ): Observable<any> {

        if (coreNotesGetNotesRequest === null || coreNotesGetNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesGetNotesRequest was null or undefined when calling coreNotesGetNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreNotesGetNotes200Response>(`${this.basePath}/core_notes_get_notes`,
            coreNotesGetNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update notes
     * Update notes
     * @param coreNotesUpdateNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesUpdateNotes(coreNotesUpdateNotesRequest: CoreNotesUpdateNotesRequest, ): Observable<AxiosResponse<object>>;
    public coreNotesUpdateNotes(coreNotesUpdateNotesRequest: CoreNotesUpdateNotesRequest, ): Observable<any> {

        if (coreNotesUpdateNotesRequest === null || coreNotesUpdateNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesUpdateNotesRequest was null or undefined when calling coreNotesUpdateNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_notes_update_notes`,
            coreNotesUpdateNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Simulates the web interface view of notes/index.php: trigger events.
     * Simulates the web interface view of notes/index.php: trigger events.
     * @param coreNotesViewNotesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreNotesViewNotes(coreNotesViewNotesRequest: CoreNotesViewNotesRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreNotesViewNotes(coreNotesViewNotesRequest: CoreNotesViewNotesRequest, ): Observable<any> {

        if (coreNotesViewNotesRequest === null || coreNotesViewNotesRequest === undefined) {
            throw new Error('Required parameter coreNotesViewNotesRequest was null or undefined when calling coreNotesViewNotes.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_notes_view_notes`,
            coreNotesViewNotesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the mapping of names to icons
     * Load the mapping of names to icons
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreOutputLoadFontawesomeIconMap(): Observable<AxiosResponse<object>>;
    public coreOutputLoadFontawesomeIconMap(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<object>(`${this.basePath}/core_output_load_fontawesome_icon_map`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load the mapping of moodle pix names to fontawesome icon names
     * Load the mapping of moodle pix names to fontawesome icon names
     * @param coreOutputLoadFontawesomeIconSystemMapRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreOutputLoadFontawesomeIconSystemMap(coreOutputLoadFontawesomeIconSystemMapRequest: CoreOutputLoadFontawesomeIconSystemMapRequest, ): Observable<AxiosResponse<object>>;
    public coreOutputLoadFontawesomeIconSystemMap(coreOutputLoadFontawesomeIconSystemMapRequest: CoreOutputLoadFontawesomeIconSystemMapRequest, ): Observable<any> {

        if (coreOutputLoadFontawesomeIconSystemMapRequest === null || coreOutputLoadFontawesomeIconSystemMapRequest === undefined) {
            throw new Error('Required parameter coreOutputLoadFontawesomeIconSystemMapRequest was null or undefined when calling coreOutputLoadFontawesomeIconSystemMap.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_output_load_fontawesome_icon_system_map`,
            coreOutputLoadFontawesomeIconSystemMapRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a template for a renderable
     * Load a template for a renderable
     * @param coreOutputLoadTemplateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreOutputLoadTemplate(coreOutputLoadTemplateRequest: CoreOutputLoadTemplateRequest, ): Observable<AxiosResponse<object>>;
    public coreOutputLoadTemplate(coreOutputLoadTemplateRequest: CoreOutputLoadTemplateRequest, ): Observable<any> {

        if (coreOutputLoadTemplateRequest === null || coreOutputLoadTemplateRequest === undefined) {
            throw new Error('Required parameter coreOutputLoadTemplateRequest was null or undefined when calling coreOutputLoadTemplate.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_output_load_template`,
            coreOutputLoadTemplateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Load a template and its dependencies for a renderable
     * Load a template and its dependencies for a renderable
     * @param coreOutputLoadTemplateWithDependenciesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreOutputLoadTemplateWithDependencies(coreOutputLoadTemplateWithDependenciesRequest: CoreOutputLoadTemplateWithDependenciesRequest, ): Observable<AxiosResponse<CoreOutputLoadTemplateWithDependencies200Response>>;
    public coreOutputLoadTemplateWithDependencies(coreOutputLoadTemplateWithDependenciesRequest: CoreOutputLoadTemplateWithDependenciesRequest, ): Observable<any> {

        if (coreOutputLoadTemplateWithDependenciesRequest === null || coreOutputLoadTemplateWithDependenciesRequest === undefined) {
            throw new Error('Required parameter coreOutputLoadTemplateWithDependenciesRequest was null or undefined when calling coreOutputLoadTemplateWithDependencies.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreOutputLoadTemplateWithDependencies200Response>(`${this.basePath}/core_output_load_template_with_dependencies`,
            coreOutputLoadTemplateWithDependenciesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the list of payment gateways that support the given component/area
     * Get the list of payment gateways that support the given component/area
     * @param corePaymentGetAvailableGatewaysRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public corePaymentGetAvailableGateways(corePaymentGetAvailableGatewaysRequest: CorePaymentGetAvailableGatewaysRequest, ): Observable<AxiosResponse<object>>;
    public corePaymentGetAvailableGateways(corePaymentGetAvailableGatewaysRequest: CorePaymentGetAvailableGatewaysRequest, ): Observable<any> {

        if (corePaymentGetAvailableGatewaysRequest === null || corePaymentGetAvailableGatewaysRequest === undefined) {
            throw new Error('Required parameter corePaymentGetAvailableGatewaysRequest was null or undefined when calling corePaymentGetAvailableGateways.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_payment_get_available_gateways`,
            corePaymentGetAvailableGatewaysRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the random question set for a criteria
     * Get the random question set for a criteria
     * @param coreQuestionGetRandomQuestionSummariesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreQuestionGetRandomQuestionSummaries(coreQuestionGetRandomQuestionSummariesRequest: CoreQuestionGetRandomQuestionSummariesRequest, ): Observable<AxiosResponse<CoreQuestionGetRandomQuestionSummaries200Response>>;
    public coreQuestionGetRandomQuestionSummaries(coreQuestionGetRandomQuestionSummariesRequest: CoreQuestionGetRandomQuestionSummariesRequest, ): Observable<any> {

        if (coreQuestionGetRandomQuestionSummariesRequest === null || coreQuestionGetRandomQuestionSummariesRequest === undefined) {
            throw new Error('Required parameter coreQuestionGetRandomQuestionSummariesRequest was null or undefined when calling coreQuestionGetRandomQuestionSummaries.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreQuestionGetRandomQuestionSummaries200Response>(`${this.basePath}/core_question_get_random_question_summaries`,
            coreQuestionGetRandomQuestionSummariesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update the question tags.
     * Update the question tags.
     * @param coreQuestionSubmitTagsFormRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreQuestionSubmitTagsForm(coreQuestionSubmitTagsFormRequest: CoreQuestionSubmitTagsFormRequest, ): Observable<AxiosResponse<CoreQuestionSubmitTagsForm200Response>>;
    public coreQuestionSubmitTagsForm(coreQuestionSubmitTagsFormRequest: CoreQuestionSubmitTagsFormRequest, ): Observable<any> {

        if (coreQuestionSubmitTagsFormRequest === null || coreQuestionSubmitTagsFormRequest === undefined) {
            throw new Error('Required parameter coreQuestionSubmitTagsFormRequest was null or undefined when calling coreQuestionSubmitTagsForm.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreQuestionSubmitTagsForm200Response>(`${this.basePath}/core_question_submit_tags_form`,
            coreQuestionSubmitTagsFormRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update the flag state of a question attempt.
     * Update the flag state of a question attempt.
     * @param coreQuestionUpdateFlagRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreQuestionUpdateFlag(coreQuestionUpdateFlagRequest: CoreQuestionUpdateFlagRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreQuestionUpdateFlag(coreQuestionUpdateFlagRequest: CoreQuestionUpdateFlagRequest, ): Observable<any> {

        if (coreQuestionUpdateFlagRequest === null || coreQuestionUpdateFlagRequest === undefined) {
            throw new Error('Required parameter coreQuestionUpdateFlagRequest was null or undefined when calling coreQuestionUpdateFlag.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_question_update_flag`,
            coreQuestionUpdateFlagRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Rates an item.
     * Rates an item.
     * @param coreRatingAddRatingRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreRatingAddRating(coreRatingAddRatingRequest: CoreRatingAddRatingRequest, ): Observable<AxiosResponse<CoreRatingAddRating200Response>>;
    public coreRatingAddRating(coreRatingAddRatingRequest: CoreRatingAddRatingRequest, ): Observable<any> {

        if (coreRatingAddRatingRequest === null || coreRatingAddRatingRequest === undefined) {
            throw new Error('Required parameter coreRatingAddRatingRequest was null or undefined when calling coreRatingAddRating.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreRatingAddRating200Response>(`${this.basePath}/core_rating_add_rating`,
            coreRatingAddRatingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve all the ratings for an item.
     * Retrieve all the ratings for an item.
     * @param coreRatingGetItemRatingsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreRatingGetItemRatings(coreRatingGetItemRatingsRequest: CoreRatingGetItemRatingsRequest, ): Observable<AxiosResponse<CoreRatingGetItemRatings200Response>>;
    public coreRatingGetItemRatings(coreRatingGetItemRatingsRequest: CoreRatingGetItemRatingsRequest, ): Observable<any> {

        if (coreRatingGetItemRatingsRequest === null || coreRatingGetItemRatingsRequest === undefined) {
            throw new Error('Required parameter coreRatingGetItemRatingsRequest was null or undefined when calling coreRatingGetItemRatings.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreRatingGetItemRatings200Response>(`${this.basePath}/core_rating_get_item_ratings`,
            coreRatingGetItemRatingsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete audience from report
     * Delete audience from report
     * @param coreReportbuilderAudiencesDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderAudiencesDelete(coreReportbuilderAudiencesDeleteRequest: CoreReportbuilderAudiencesDeleteRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderAudiencesDelete(coreReportbuilderAudiencesDeleteRequest: CoreReportbuilderAudiencesDeleteRequest, ): Observable<any> {

        if (coreReportbuilderAudiencesDeleteRequest === null || coreReportbuilderAudiencesDeleteRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderAudiencesDeleteRequest was null or undefined when calling coreReportbuilderAudiencesDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_audiences_delete`,
            coreReportbuilderAudiencesDeleteRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Determine access to a system report
     * Determine access to a system report
     * @param coreReportbuilderCanViewSystemReportRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderCanViewSystemReport(coreReportbuilderCanViewSystemReportRequest: CoreReportbuilderCanViewSystemReportRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderCanViewSystemReport(coreReportbuilderCanViewSystemReportRequest: CoreReportbuilderCanViewSystemReportRequest, ): Observable<any> {

        if (coreReportbuilderCanViewSystemReportRequest === null || coreReportbuilderCanViewSystemReportRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderCanViewSystemReportRequest was null or undefined when calling coreReportbuilderCanViewSystemReport.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_can_view_system_report`,
            coreReportbuilderCanViewSystemReportRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add column to report
     * Add column to report
     * @param coreReportbuilderColumnsAddRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsAdd(coreReportbuilderColumnsAddRequest: CoreReportbuilderColumnsAddRequest, ): Observable<AxiosResponse<CoreReportbuilderColumnsAdd200Response>>;
    public coreReportbuilderColumnsAdd(coreReportbuilderColumnsAddRequest: CoreReportbuilderColumnsAddRequest, ): Observable<any> {

        if (coreReportbuilderColumnsAddRequest === null || coreReportbuilderColumnsAddRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsAddRequest was null or undefined when calling coreReportbuilderColumnsAdd.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderColumnsAdd200Response>(`${this.basePath}/core_reportbuilder_columns_add`,
            coreReportbuilderColumnsAddRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete column from report
     * Delete column from report
     * @param coreReportbuilderColumnsDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsDelete(coreReportbuilderColumnsDeleteRequest: CoreReportbuilderColumnsDeleteRequest, ): Observable<AxiosResponse<CoreReportbuilderColumnsDelete200Response>>;
    public coreReportbuilderColumnsDelete(coreReportbuilderColumnsDeleteRequest: CoreReportbuilderColumnsDeleteRequest, ): Observable<any> {

        if (coreReportbuilderColumnsDeleteRequest === null || coreReportbuilderColumnsDeleteRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsDeleteRequest was null or undefined when calling coreReportbuilderColumnsDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderColumnsDelete200Response>(`${this.basePath}/core_reportbuilder_columns_delete`,
            coreReportbuilderColumnsDeleteRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order column within report
     * Re-order column within report
     * @param coreReportbuilderColumnsReorderRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsReorder(coreReportbuilderColumnsReorderRequest: CoreReportbuilderColumnsReorderRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderColumnsReorder(coreReportbuilderColumnsReorderRequest: CoreReportbuilderColumnsReorderRequest, ): Observable<any> {

        if (coreReportbuilderColumnsReorderRequest === null || coreReportbuilderColumnsReorderRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsReorderRequest was null or undefined when calling coreReportbuilderColumnsReorder.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_columns_reorder`,
            coreReportbuilderColumnsReorderRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve column sorting for report
     * Retrieve column sorting for report
     * @param coreReportbuilderColumnsSortGetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsSortGet(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<AxiosResponse<CoreReportbuilderColumnsDelete200Response>>;
    public coreReportbuilderColumnsSortGet(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortGetRequest === null || coreReportbuilderColumnsSortGetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortGetRequest was null or undefined when calling coreReportbuilderColumnsSortGet.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderColumnsDelete200Response>(`${this.basePath}/core_reportbuilder_columns_sort_get`,
            coreReportbuilderColumnsSortGetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order column sorting within report
     * Re-order column sorting within report
     * @param coreReportbuilderColumnsSortReorderRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsSortReorder(coreReportbuilderColumnsSortReorderRequest: CoreReportbuilderColumnsSortReorderRequest, ): Observable<AxiosResponse<CoreReportbuilderColumnsDelete200Response>>;
    public coreReportbuilderColumnsSortReorder(coreReportbuilderColumnsSortReorderRequest: CoreReportbuilderColumnsSortReorderRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortReorderRequest === null || coreReportbuilderColumnsSortReorderRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortReorderRequest was null or undefined when calling coreReportbuilderColumnsSortReorder.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderColumnsDelete200Response>(`${this.basePath}/core_reportbuilder_columns_sort_reorder`,
            coreReportbuilderColumnsSortReorderRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Toggle sorting of column within report
     * Toggle sorting of column within report
     * @param coreReportbuilderColumnsSortToggleRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderColumnsSortToggle(coreReportbuilderColumnsSortToggleRequest: CoreReportbuilderColumnsSortToggleRequest, ): Observable<AxiosResponse<CoreReportbuilderColumnsDelete200Response>>;
    public coreReportbuilderColumnsSortToggle(coreReportbuilderColumnsSortToggleRequest: CoreReportbuilderColumnsSortToggleRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortToggleRequest === null || coreReportbuilderColumnsSortToggleRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortToggleRequest was null or undefined when calling coreReportbuilderColumnsSortToggle.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderColumnsDelete200Response>(`${this.basePath}/core_reportbuilder_columns_sort_toggle`,
            coreReportbuilderColumnsSortToggleRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add condition to report
     * Add condition to report
     * @param coreReportbuilderConditionsAddRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderConditionsAdd(coreReportbuilderConditionsAddRequest: CoreReportbuilderConditionsAddRequest, ): Observable<AxiosResponse<CoreReportbuilderConditionsAdd200Response>>;
    public coreReportbuilderConditionsAdd(coreReportbuilderConditionsAddRequest: CoreReportbuilderConditionsAddRequest, ): Observable<any> {

        if (coreReportbuilderConditionsAddRequest === null || coreReportbuilderConditionsAddRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderConditionsAddRequest was null or undefined when calling coreReportbuilderConditionsAdd.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderConditionsAdd200Response>(`${this.basePath}/core_reportbuilder_conditions_add`,
            coreReportbuilderConditionsAddRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete condition from report
     * Delete condition from report
     * @param coreReportbuilderConditionsDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderConditionsDelete(coreReportbuilderConditionsDeleteRequest: CoreReportbuilderConditionsDeleteRequest, ): Observable<AxiosResponse<CoreReportbuilderConditionsDelete200Response>>;
    public coreReportbuilderConditionsDelete(coreReportbuilderConditionsDeleteRequest: CoreReportbuilderConditionsDeleteRequest, ): Observable<any> {

        if (coreReportbuilderConditionsDeleteRequest === null || coreReportbuilderConditionsDeleteRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderConditionsDeleteRequest was null or undefined when calling coreReportbuilderConditionsDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderConditionsDelete200Response>(`${this.basePath}/core_reportbuilder_conditions_delete`,
            coreReportbuilderConditionsDeleteRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order condition within report
     * Re-order condition within report
     * @param coreReportbuilderConditionsReorderRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderConditionsReorder(coreReportbuilderConditionsReorderRequest: CoreReportbuilderConditionsReorderRequest, ): Observable<AxiosResponse<CoreReportbuilderConditionsDelete200Response>>;
    public coreReportbuilderConditionsReorder(coreReportbuilderConditionsReorderRequest: CoreReportbuilderConditionsReorderRequest, ): Observable<any> {

        if (coreReportbuilderConditionsReorderRequest === null || coreReportbuilderConditionsReorderRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderConditionsReorderRequest was null or undefined when calling coreReportbuilderConditionsReorder.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderConditionsDelete200Response>(`${this.basePath}/core_reportbuilder_conditions_reorder`,
            coreReportbuilderConditionsReorderRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Reset conditions for given report
     * Reset conditions for given report
     * @param coreReportbuilderColumnsSortGetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderConditionsReset(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<AxiosResponse<CoreReportbuilderConditionsDelete200Response>>;
    public coreReportbuilderConditionsReset(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortGetRequest === null || coreReportbuilderColumnsSortGetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortGetRequest was null or undefined when calling coreReportbuilderConditionsReset.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderConditionsDelete200Response>(`${this.basePath}/core_reportbuilder_conditions_reset`,
            coreReportbuilderColumnsSortGetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Add filter to report
     * Add filter to report
     * @param coreReportbuilderFiltersAddRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderFiltersAdd(coreReportbuilderFiltersAddRequest: CoreReportbuilderFiltersAddRequest, ): Observable<AxiosResponse<CoreReportbuilderFiltersAdd200Response>>;
    public coreReportbuilderFiltersAdd(coreReportbuilderFiltersAddRequest: CoreReportbuilderFiltersAddRequest, ): Observable<any> {

        if (coreReportbuilderFiltersAddRequest === null || coreReportbuilderFiltersAddRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderFiltersAddRequest was null or undefined when calling coreReportbuilderFiltersAdd.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderFiltersAdd200Response>(`${this.basePath}/core_reportbuilder_filters_add`,
            coreReportbuilderFiltersAddRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete filter from report
     * Delete filter from report
     * @param coreReportbuilderFiltersDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderFiltersDelete(coreReportbuilderFiltersDeleteRequest: CoreReportbuilderFiltersDeleteRequest, ): Observable<AxiosResponse<CoreReportbuilderFiltersDelete200Response>>;
    public coreReportbuilderFiltersDelete(coreReportbuilderFiltersDeleteRequest: CoreReportbuilderFiltersDeleteRequest, ): Observable<any> {

        if (coreReportbuilderFiltersDeleteRequest === null || coreReportbuilderFiltersDeleteRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderFiltersDeleteRequest was null or undefined when calling coreReportbuilderFiltersDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderFiltersDelete200Response>(`${this.basePath}/core_reportbuilder_filters_delete`,
            coreReportbuilderFiltersDeleteRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Re-order filter within report
     * Re-order filter within report
     * @param coreReportbuilderFiltersReorderRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderFiltersReorder(coreReportbuilderFiltersReorderRequest: CoreReportbuilderFiltersReorderRequest, ): Observable<AxiosResponse<CoreReportbuilderFiltersDelete200Response>>;
    public coreReportbuilderFiltersReorder(coreReportbuilderFiltersReorderRequest: CoreReportbuilderFiltersReorderRequest, ): Observable<any> {

        if (coreReportbuilderFiltersReorderRequest === null || coreReportbuilderFiltersReorderRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderFiltersReorderRequest was null or undefined when calling coreReportbuilderFiltersReorder.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderFiltersDelete200Response>(`${this.basePath}/core_reportbuilder_filters_reorder`,
            coreReportbuilderFiltersReorderRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Reset filters for given report
     * Reset filters for given report
     * @param coreReportbuilderFiltersResetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderFiltersReset(coreReportbuilderFiltersResetRequest: CoreReportbuilderFiltersResetRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderFiltersReset(coreReportbuilderFiltersResetRequest: CoreReportbuilderFiltersResetRequest, ): Observable<any> {

        if (coreReportbuilderFiltersResetRequest === null || coreReportbuilderFiltersResetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderFiltersResetRequest was null or undefined when calling coreReportbuilderFiltersReset.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_filters_reset`,
            coreReportbuilderFiltersResetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * List custom reports for current user
     * List custom reports for current user
     * @param coreReportbuilderListReportsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderListReports(coreReportbuilderListReportsRequest: CoreReportbuilderListReportsRequest, ): Observable<AxiosResponse<CoreReportbuilderListReports200Response>>;
    public coreReportbuilderListReports(coreReportbuilderListReportsRequest: CoreReportbuilderListReportsRequest, ): Observable<any> {

        if (coreReportbuilderListReportsRequest === null || coreReportbuilderListReportsRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderListReportsRequest was null or undefined when calling coreReportbuilderListReports.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderListReports200Response>(`${this.basePath}/core_reportbuilder_list_reports`,
            coreReportbuilderListReportsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete report
     * Delete report
     * @param coreReportbuilderColumnsSortGetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderReportsDelete(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderReportsDelete(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortGetRequest === null || coreReportbuilderColumnsSortGetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortGetRequest was null or undefined when calling coreReportbuilderReportsDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_reports_delete`,
            coreReportbuilderColumnsSortGetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get custom report
     * Get custom report
     * @param coreReportbuilderReportsGetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderReportsGet(coreReportbuilderReportsGetRequest: CoreReportbuilderReportsGetRequest, ): Observable<AxiosResponse<CoreReportbuilderReportsGet200Response>>;
    public coreReportbuilderReportsGet(coreReportbuilderReportsGetRequest: CoreReportbuilderReportsGetRequest, ): Observable<any> {

        if (coreReportbuilderReportsGetRequest === null || coreReportbuilderReportsGetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderReportsGetRequest was null or undefined when calling coreReportbuilderReportsGet.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderReportsGet200Response>(`${this.basePath}/core_reportbuilder_reports_get`,
            coreReportbuilderReportsGetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve custom report content
     * Retrieve custom report content
     * @param coreReportbuilderRetrieveReportRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderRetrieveReport(coreReportbuilderRetrieveReportRequest: CoreReportbuilderRetrieveReportRequest, ): Observable<AxiosResponse<CoreReportbuilderRetrieveReport200Response>>;
    public coreReportbuilderRetrieveReport(coreReportbuilderRetrieveReportRequest: CoreReportbuilderRetrieveReportRequest, ): Observable<any> {

        if (coreReportbuilderRetrieveReportRequest === null || coreReportbuilderRetrieveReportRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderRetrieveReportRequest was null or undefined when calling coreReportbuilderRetrieveReport.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderRetrieveReport200Response>(`${this.basePath}/core_reportbuilder_retrieve_report`,
            coreReportbuilderRetrieveReportRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve system report content
     * Retrieve system report content
     * @param coreReportbuilderRetrieveSystemReportRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderRetrieveSystemReport(coreReportbuilderRetrieveSystemReportRequest: CoreReportbuilderRetrieveSystemReportRequest, ): Observable<AxiosResponse<CoreReportbuilderRetrieveSystemReport200Response>>;
    public coreReportbuilderRetrieveSystemReport(coreReportbuilderRetrieveSystemReportRequest: CoreReportbuilderRetrieveSystemReportRequest, ): Observable<any> {

        if (coreReportbuilderRetrieveSystemReportRequest === null || coreReportbuilderRetrieveSystemReportRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderRetrieveSystemReportRequest was null or undefined when calling coreReportbuilderRetrieveSystemReport.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderRetrieveSystemReport200Response>(`${this.basePath}/core_reportbuilder_retrieve_system_report`,
            coreReportbuilderRetrieveSystemReportRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete schedule from report
     * Delete schedule from report
     * @param coreReportbuilderSchedulesDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderSchedulesDelete(coreReportbuilderSchedulesDeleteRequest: CoreReportbuilderSchedulesDeleteRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderSchedulesDelete(coreReportbuilderSchedulesDeleteRequest: CoreReportbuilderSchedulesDeleteRequest, ): Observable<any> {

        if (coreReportbuilderSchedulesDeleteRequest === null || coreReportbuilderSchedulesDeleteRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderSchedulesDeleteRequest was null or undefined when calling coreReportbuilderSchedulesDelete.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_schedules_delete`,
            coreReportbuilderSchedulesDeleteRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Send report schedule
     * Send report schedule
     * @param coreReportbuilderSchedulesSendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderSchedulesSend(coreReportbuilderSchedulesSendRequest: CoreReportbuilderSchedulesSendRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderSchedulesSend(coreReportbuilderSchedulesSendRequest: CoreReportbuilderSchedulesSendRequest, ): Observable<any> {

        if (coreReportbuilderSchedulesSendRequest === null || coreReportbuilderSchedulesSendRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderSchedulesSendRequest was null or undefined when calling coreReportbuilderSchedulesSend.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_schedules_send`,
            coreReportbuilderSchedulesSendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Toggle state of report schedule
     * Toggle state of report schedule
     * @param coreReportbuilderSchedulesToggleRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderSchedulesToggle(coreReportbuilderSchedulesToggleRequest: CoreReportbuilderSchedulesToggleRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderSchedulesToggle(coreReportbuilderSchedulesToggleRequest: CoreReportbuilderSchedulesToggleRequest, ): Observable<any> {

        if (coreReportbuilderSchedulesToggleRequest === null || coreReportbuilderSchedulesToggleRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderSchedulesToggleRequest was null or undefined when calling coreReportbuilderSchedulesToggle.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_schedules_toggle`,
            coreReportbuilderSchedulesToggleRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set filter values for given report
     * Set filter values for given report
     * @param coreReportbuilderSetFiltersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderSetFilters(coreReportbuilderSetFiltersRequest: CoreReportbuilderSetFiltersRequest, ): Observable<AxiosResponse<object>>;
    public coreReportbuilderSetFilters(coreReportbuilderSetFiltersRequest: CoreReportbuilderSetFiltersRequest, ): Observable<any> {

        if (coreReportbuilderSetFiltersRequest === null || coreReportbuilderSetFiltersRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderSetFiltersRequest was null or undefined when calling coreReportbuilderSetFilters.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_reportbuilder_set_filters`,
            coreReportbuilderSetFiltersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Trigger custom report viewed
     * Trigger custom report viewed
     * @param coreReportbuilderColumnsSortGetRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreReportbuilderViewReport(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<AxiosResponse<CoreReportbuilderViewReport200Response>>;
    public coreReportbuilderViewReport(coreReportbuilderColumnsSortGetRequest: CoreReportbuilderColumnsSortGetRequest, ): Observable<any> {

        if (coreReportbuilderColumnsSortGetRequest === null || coreReportbuilderColumnsSortGetRequest === undefined) {
            throw new Error('Required parameter coreReportbuilderColumnsSortGetRequest was null or undefined when calling coreReportbuilderViewReport.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreReportbuilderViewReport200Response>(`${this.basePath}/core_reportbuilder_view_report`,
            coreReportbuilderColumnsSortGetRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Manual role assignments.
     * Manual role assignments.
     * @param coreRoleAssignRolesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreRoleAssignRoles(coreRoleAssignRolesRequest: CoreRoleAssignRolesRequest, ): Observable<AxiosResponse<object>>;
    public coreRoleAssignRoles(coreRoleAssignRolesRequest: CoreRoleAssignRolesRequest, ): Observable<any> {

        if (coreRoleAssignRolesRequest === null || coreRoleAssignRolesRequest === undefined) {
            throw new Error('Required parameter coreRoleAssignRolesRequest was null or undefined when calling coreRoleAssignRoles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_role_assign_roles`,
            coreRoleAssignRolesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Manual role unassignments.
     * Manual role unassignments.
     * @param coreRoleUnassignRolesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreRoleUnassignRoles(coreRoleUnassignRolesRequest: CoreRoleUnassignRolesRequest, ): Observable<AxiosResponse<object>>;
    public coreRoleUnassignRoles(coreRoleUnassignRolesRequest: CoreRoleUnassignRolesRequest, ): Observable<any> {

        if (coreRoleUnassignRolesRequest === null || coreRoleUnassignRolesRequest === undefined) {
            throw new Error('Required parameter coreRoleUnassignRolesRequest was null or undefined when calling coreRoleUnassignRoles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_role_unassign_roles`,
            coreRoleUnassignRolesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets relevant users for a search request.
     * Gets relevant users for a search request.
     * @param coreSearchGetRelevantUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSearchGetRelevantUsers(coreSearchGetRelevantUsersRequest: CoreSearchGetRelevantUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreSearchGetRelevantUsers(coreSearchGetRelevantUsersRequest: CoreSearchGetRelevantUsersRequest, ): Observable<any> {

        if (coreSearchGetRelevantUsersRequest === null || coreSearchGetRelevantUsersRequest === undefined) {
            throw new Error('Required parameter coreSearchGetRelevantUsersRequest was null or undefined when calling coreSearchGetRelevantUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_search_get_relevant_users`,
            coreSearchGetRelevantUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get search results.
     * Get search results.
     * @param coreSearchGetResultsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSearchGetResults(coreSearchGetResultsRequest: CoreSearchGetResultsRequest, ): Observable<AxiosResponse<CoreSearchGetResults200Response>>;
    public coreSearchGetResults(coreSearchGetResultsRequest: CoreSearchGetResultsRequest, ): Observable<any> {

        if (coreSearchGetResultsRequest === null || coreSearchGetResultsRequest === undefined) {
            throw new Error('Required parameter coreSearchGetResultsRequest was null or undefined when calling coreSearchGetResults.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreSearchGetResults200Response>(`${this.basePath}/core_search_get_results`,
            coreSearchGetResultsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get search areas.
     * Get search areas.
     * @param coreSearchGetSearchAreasListRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSearchGetSearchAreasList(coreSearchGetSearchAreasListRequest: CoreSearchGetSearchAreasListRequest, ): Observable<AxiosResponse<CoreSearchGetSearchAreasList200Response>>;
    public coreSearchGetSearchAreasList(coreSearchGetSearchAreasListRequest: CoreSearchGetSearchAreasListRequest, ): Observable<any> {

        if (coreSearchGetSearchAreasListRequest === null || coreSearchGetSearchAreasListRequest === undefined) {
            throw new Error('Required parameter coreSearchGetSearchAreasListRequest was null or undefined when calling coreSearchGetSearchAreasList.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreSearchGetSearchAreasList200Response>(`${this.basePath}/core_search_get_search_areas_list`,
            coreSearchGetSearchAreasListRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get top search results.
     * Get top search results.
     * @param coreSearchGetTopResultsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSearchGetTopResults(coreSearchGetTopResultsRequest: CoreSearchGetTopResultsRequest, ): Observable<AxiosResponse<CoreSearchGetTopResults200Response>>;
    public coreSearchGetTopResults(coreSearchGetTopResultsRequest: CoreSearchGetTopResultsRequest, ): Observable<any> {

        if (coreSearchGetTopResultsRequest === null || coreSearchGetTopResultsRequest === undefined) {
            throw new Error('Required parameter coreSearchGetTopResultsRequest was null or undefined when calling coreSearchGetTopResults.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreSearchGetTopResults200Response>(`${this.basePath}/core_search_get_top_results`,
            coreSearchGetTopResultsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Trigger view search results event.
     * Trigger view search results event.
     * @param coreSearchViewResultsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSearchViewResults(coreSearchViewResultsRequest: CoreSearchViewResultsRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreSearchViewResults(coreSearchViewResultsRequest: CoreSearchViewResultsRequest, ): Observable<any> {

        if (coreSearchViewResultsRequest === null || coreSearchViewResultsRequest === undefined) {
            throw new Error('Required parameter coreSearchViewResultsRequest was null or undefined when calling coreSearchViewResults.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_search_view_results`,
            coreSearchViewResultsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Count the seconds remaining in this session
     * Count the seconds remaining in this session
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSessionTimeRemaining(): Observable<AxiosResponse<CoreSessionTimeRemaining200Response>>;
    public coreSessionTimeRemaining(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreSessionTimeRemaining200Response>(`${this.basePath}/core_session_time_remaining`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Keep the users session alive
     * Keep the users session alive
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreSessionTouch(): Observable<AxiosResponse<object>>;
    public coreSessionTouch(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<object>(`${this.basePath}/core_session_touch`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get the dynamic table content raw html
     * Get the dynamic table content raw html
     * @param coreTableGetDynamicTableContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTableGetDynamicTableContent(coreTableGetDynamicTableContentRequest: CoreTableGetDynamicTableContentRequest, ): Observable<AxiosResponse<CoreTableGetDynamicTableContent200Response>>;
    public coreTableGetDynamicTableContent(coreTableGetDynamicTableContentRequest: CoreTableGetDynamicTableContentRequest, ): Observable<any> {

        if (coreTableGetDynamicTableContentRequest === null || coreTableGetDynamicTableContentRequest === undefined) {
            throw new Error('Required parameter coreTableGetDynamicTableContentRequest was null or undefined when calling coreTableGetDynamicTableContent.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreTableGetDynamicTableContent200Response>(`${this.basePath}/core_table_get_dynamic_table_content`,
            coreTableGetDynamicTableContentRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieves existing tag areas.
     * Retrieves existing tag areas.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTagAreas(): Observable<AxiosResponse<CoreTagGetTagAreas200Response>>;
    public coreTagGetTagAreas(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreTagGetTagAreas200Response>(`${this.basePath}/core_tag_get_tag_areas`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieves a tag cloud for the given collection and/or query search.
     * Retrieves a tag cloud for the given collection and/or query search.
     * @param coreTagGetTagCloudRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTagCloud(coreTagGetTagCloudRequest: CoreTagGetTagCloudRequest, ): Observable<AxiosResponse<CoreTagGetTagCloud200Response>>;
    public coreTagGetTagCloud(coreTagGetTagCloudRequest: CoreTagGetTagCloudRequest, ): Observable<any> {

        if (coreTagGetTagCloudRequest === null || coreTagGetTagCloudRequest === undefined) {
            throw new Error('Required parameter coreTagGetTagCloudRequest was null or undefined when calling coreTagGetTagCloud.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreTagGetTagCloud200Response>(`${this.basePath}/core_tag_get_tag_cloud`,
            coreTagGetTagCloudRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieves existing tag collections.
     * Retrieves existing tag collections.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTagCollections(): Observable<AxiosResponse<CoreTagGetTagCollections200Response>>;
    public coreTagGetTagCollections(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreTagGetTagCollections200Response>(`${this.basePath}/core_tag_get_tag_collections`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets tag index page for one tag and one tag area
     * Gets tag index page for one tag and one tag area
     * @param coreTagGetTagindexRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTagindex(coreTagGetTagindexRequest: CoreTagGetTagindexRequest, ): Observable<AxiosResponse<CoreTagGetTagindex200Response>>;
    public coreTagGetTagindex(coreTagGetTagindexRequest: CoreTagGetTagindexRequest, ): Observable<any> {

        if (coreTagGetTagindexRequest === null || coreTagGetTagindexRequest === undefined) {
            throw new Error('Required parameter coreTagGetTagindexRequest was null or undefined when calling coreTagGetTagindex.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreTagGetTagindex200Response>(`${this.basePath}/core_tag_get_tagindex`,
            coreTagGetTagindexRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets tag index page per different areas.
     * Gets tag index page per different areas.
     * @param coreTagGetTagindexPerAreaRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTagindexPerArea(coreTagGetTagindexPerAreaRequest: CoreTagGetTagindexPerAreaRequest, ): Observable<AxiosResponse<object>>;
    public coreTagGetTagindexPerArea(coreTagGetTagindexPerAreaRequest: CoreTagGetTagindexPerAreaRequest, ): Observable<any> {

        if (coreTagGetTagindexPerAreaRequest === null || coreTagGetTagindexPerAreaRequest === undefined) {
            throw new Error('Required parameter coreTagGetTagindexPerAreaRequest was null or undefined when calling coreTagGetTagindexPerArea.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_tag_get_tagindex_per_area`,
            coreTagGetTagindexPerAreaRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Gets tags by their ids
     * Gets tags by their ids
     * @param coreTagGetTagsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagGetTags(coreTagGetTagsRequest: CoreTagGetTagsRequest, ): Observable<AxiosResponse<CoreTagGetTags200Response>>;
    public coreTagGetTags(coreTagGetTagsRequest: CoreTagGetTagsRequest, ): Observable<any> {

        if (coreTagGetTagsRequest === null || coreTagGetTagsRequest === undefined) {
            throw new Error('Required parameter coreTagGetTagsRequest was null or undefined when calling coreTagGetTags.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreTagGetTags200Response>(`${this.basePath}/core_tag_get_tags`,
            coreTagGetTagsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Updates tags
     * Updates tags
     * @param coreTagUpdateTagsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreTagUpdateTags(coreTagUpdateTagsRequest: CoreTagUpdateTagsRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreTagUpdateTags(coreTagUpdateTagsRequest: CoreTagUpdateTagsRequest, ): Observable<any> {

        if (coreTagUpdateTagsRequest === null || coreTagUpdateTagsRequest === undefined) {
            throw new Error('Required parameter coreTagUpdateTagsRequest was null or undefined when calling coreTagUpdateTags.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_tag_update_tags`,
            coreTagUpdateTagsRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Generic service to update title
     * Generic service to update title
     * @param coreUpdateInplaceEditableRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUpdateInplaceEditable(coreUpdateInplaceEditableRequest: CoreUpdateInplaceEditableRequest, ): Observable<AxiosResponse<CoreUpdateInplaceEditable200Response>>;
    public coreUpdateInplaceEditable(coreUpdateInplaceEditableRequest: CoreUpdateInplaceEditableRequest, ): Observable<any> {

        if (coreUpdateInplaceEditableRequest === null || coreUpdateInplaceEditableRequest === undefined) {
            throw new Error('Required parameter coreUpdateInplaceEditableRequest was null or undefined when calling coreUpdateInplaceEditable.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUpdateInplaceEditable200Response>(`${this.basePath}/core_update_inplace_editable`,
            coreUpdateInplaceEditableRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Store mobile user devices information for PUSH Notifications.
     * Store mobile user devices information for PUSH Notifications.
     * @param coreUserAddUserDeviceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserAddUserDevice(coreUserAddUserDeviceRequest: CoreUserAddUserDeviceRequest, ): Observable<AxiosResponse<object>>;
    public coreUserAddUserDevice(coreUserAddUserDeviceRequest: CoreUserAddUserDeviceRequest, ): Observable<any> {

        if (coreUserAddUserDeviceRequest === null || coreUserAddUserDeviceRequest === undefined) {
            throw new Error('Required parameter coreUserAddUserDeviceRequest was null or undefined when calling coreUserAddUserDevice.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_add_user_device`,
            coreUserAddUserDeviceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Copy files from a draft area to users private files area.
     * Copy files from a draft area to users private files area.
     * @param coreUserAddUserPrivateFilesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserAddUserPrivateFiles(coreUserAddUserPrivateFilesRequest: CoreUserAddUserPrivateFilesRequest, ): Observable<AxiosResponse<object>>;
    public coreUserAddUserPrivateFiles(coreUserAddUserPrivateFilesRequest: CoreUserAddUserPrivateFilesRequest, ): Observable<any> {

        if (coreUserAddUserPrivateFilesRequest === null || coreUserAddUserPrivateFilesRequest === undefined) {
            throw new Error('Required parameter coreUserAddUserPrivateFilesRequest was null or undefined when calling coreUserAddUserPrivateFiles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_add_user_private_files`,
            coreUserAddUserPrivateFilesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Agree the site policy for the current user.
     * Agree the site policy for the current user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserAgreeSitePolicy(): Observable<AxiosResponse<CoreUserAgreeSitePolicy200Response>>;
    public coreUserAgreeSitePolicy(): Observable<any> {

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return this.httpClient.post<CoreUserAgreeSitePolicy200Response>(`${this.basePath}/core_user_agree_site_policy`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Create users.
     * Create users.
     * @param coreUserCreateUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserCreateUsers(coreUserCreateUsersRequest: CoreUserCreateUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreUserCreateUsers(coreUserCreateUsersRequest: CoreUserCreateUsersRequest, ): Observable<any> {

        if (coreUserCreateUsersRequest === null || coreUserCreateUsersRequest === undefined) {
            throw new Error('Required parameter coreUserCreateUsersRequest was null or undefined when calling coreUserCreateUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_create_users`,
            coreUserCreateUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete users.
     * Delete users.
     * @param coreUserDeleteUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserDeleteUsers(coreUserDeleteUsersRequest: CoreUserDeleteUsersRequest, ): Observable<AxiosResponse<object>>;
    public coreUserDeleteUsers(coreUserDeleteUsersRequest: CoreUserDeleteUsersRequest, ): Observable<any> {

        if (coreUserDeleteUsersRequest === null || coreUserDeleteUsersRequest === undefined) {
            throw new Error('Required parameter coreUserDeleteUsersRequest was null or undefined when calling coreUserDeleteUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_delete_users`,
            coreUserDeleteUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get course user profiles (each of the profils matching a course id and a user id),.
     * Get course user profiles (each of the profils matching a course id and a user id),.
     * @param coreUserGetCourseUserProfilesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserGetCourseUserProfiles(coreUserGetCourseUserProfilesRequest: CoreUserGetCourseUserProfilesRequest, ): Observable<AxiosResponse<object>>;
    public coreUserGetCourseUserProfiles(coreUserGetCourseUserProfilesRequest: CoreUserGetCourseUserProfilesRequest, ): Observable<any> {

        if (coreUserGetCourseUserProfilesRequest === null || coreUserGetCourseUserProfilesRequest === undefined) {
            throw new Error('Required parameter coreUserGetCourseUserProfilesRequest was null or undefined when calling coreUserGetCourseUserProfiles.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_get_course_user_profiles`,
            coreUserGetCourseUserProfilesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Returns general information about files in the user private files area.
     * Returns general information about files in the user private files area.
     * @param coreUserGetPrivateFilesInfoRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserGetPrivateFilesInfo(coreUserGetPrivateFilesInfoRequest: CoreUserGetPrivateFilesInfoRequest, ): Observable<AxiosResponse<CoreUserGetPrivateFilesInfo200Response>>;
    public coreUserGetPrivateFilesInfo(coreUserGetPrivateFilesInfoRequest: CoreUserGetPrivateFilesInfoRequest, ): Observable<any> {

        if (coreUserGetPrivateFilesInfoRequest === null || coreUserGetPrivateFilesInfoRequest === undefined) {
            throw new Error('Required parameter coreUserGetPrivateFilesInfoRequest was null or undefined when calling coreUserGetPrivateFilesInfo.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserGetPrivateFilesInfo200Response>(`${this.basePath}/core_user_get_private_files_info`,
            coreUserGetPrivateFilesInfoRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return user preferences.
     * Return user preferences.
     * @param coreUserGetUserPreferencesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserGetUserPreferences(coreUserGetUserPreferencesRequest: CoreUserGetUserPreferencesRequest, ): Observable<AxiosResponse<CoreUserGetUserPreferences200Response>>;
    public coreUserGetUserPreferences(coreUserGetUserPreferencesRequest: CoreUserGetUserPreferencesRequest, ): Observable<any> {

        if (coreUserGetUserPreferencesRequest === null || coreUserGetUserPreferencesRequest === undefined) {
            throw new Error('Required parameter coreUserGetUserPreferencesRequest was null or undefined when calling coreUserGetUserPreferences.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserGetUserPreferences200Response>(`${this.basePath}/core_user_get_user_preferences`,
            coreUserGetUserPreferencesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * search for users matching the parameters
     * search for users matching the parameters
     * @param coreUserGetUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserGetUsers(coreUserGetUsersRequest: CoreUserGetUsersRequest, ): Observable<AxiosResponse<CoreUserGetUsers200Response>>;
    public coreUserGetUsers(coreUserGetUsersRequest: CoreUserGetUsersRequest, ): Observable<any> {

        if (coreUserGetUsersRequest === null || coreUserGetUsersRequest === undefined) {
            throw new Error('Required parameter coreUserGetUsersRequest was null or undefined when calling coreUserGetUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserGetUsers200Response>(`${this.basePath}/core_user_get_users`,
            coreUserGetUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Retrieve users\&#39; information for a specified unique field - If you want to do a user search, use core_user_get_users() or core_user_search_identity().
     * Retrieve users\&#39; information for a specified unique field - If you want to do a user search, use core_user_get_users() or core_user_search_identity().
     * @param coreUserGetUsersByFieldRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserGetUsersByField(coreUserGetUsersByFieldRequest: CoreUserGetUsersByFieldRequest, ): Observable<AxiosResponse<object>>;
    public coreUserGetUsersByField(coreUserGetUsersByFieldRequest: CoreUserGetUsersByFieldRequest, ): Observable<any> {

        if (coreUserGetUsersByFieldRequest === null || coreUserGetUsersByFieldRequest === undefined) {
            throw new Error('Required parameter coreUserGetUsersByFieldRequest was null or undefined when calling coreUserGetUsersByField.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_get_users_by_field`,
            coreUserGetUsersByFieldRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Remove a user device from the Moodle database.
     * Remove a user device from the Moodle database.
     * @param coreUserRemoveUserDeviceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserRemoveUserDevice(coreUserRemoveUserDeviceRequest: CoreUserRemoveUserDeviceRequest, ): Observable<AxiosResponse<CoreUserRemoveUserDevice200Response>>;
    public coreUserRemoveUserDevice(coreUserRemoveUserDeviceRequest: CoreUserRemoveUserDeviceRequest, ): Observable<any> {

        if (coreUserRemoveUserDeviceRequest === null || coreUserRemoveUserDeviceRequest === undefined) {
            throw new Error('Required parameter coreUserRemoveUserDeviceRequest was null or undefined when calling coreUserRemoveUserDevice.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserRemoveUserDevice200Response>(`${this.basePath}/core_user_remove_user_device`,
            coreUserRemoveUserDeviceRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return list of users identities matching the given criteria in their name or other identity fields.
     * Return list of users identities matching the given criteria in their name or other identity fields.
     * @param coreUserSearchIdentityRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserSearchIdentity(coreUserSearchIdentityRequest: CoreUserSearchIdentityRequest, ): Observable<AxiosResponse<CoreUserSearchIdentity200Response>>;
    public coreUserSearchIdentity(coreUserSearchIdentityRequest: CoreUserSearchIdentityRequest, ): Observable<any> {

        if (coreUserSearchIdentityRequest === null || coreUserSearchIdentityRequest === undefined) {
            throw new Error('Required parameter coreUserSearchIdentityRequest was null or undefined when calling coreUserSearchIdentity.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserSearchIdentity200Response>(`${this.basePath}/core_user_search_identity`,
            coreUserSearchIdentityRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Set user preferences.
     * Set user preferences.
     * @param coreUserSetUserPreferencesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserSetUserPreferences(coreUserSetUserPreferencesRequest: CoreUserSetUserPreferencesRequest, ): Observable<AxiosResponse<CoreUserSetUserPreferences200Response>>;
    public coreUserSetUserPreferences(coreUserSetUserPreferencesRequest: CoreUserSetUserPreferencesRequest, ): Observable<any> {

        if (coreUserSetUserPreferencesRequest === null || coreUserSetUserPreferencesRequest === undefined) {
            throw new Error('Required parameter coreUserSetUserPreferencesRequest was null or undefined when calling coreUserSetUserPreferences.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserSetUserPreferences200Response>(`${this.basePath}/core_user_set_user_preferences`,
            coreUserSetUserPreferencesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update or delete the user picture in the site
     * Update or delete the user picture in the site
     * @param coreUserUpdatePictureRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserUpdatePicture(coreUserUpdatePictureRequest: CoreUserUpdatePictureRequest, ): Observable<AxiosResponse<CoreUserUpdatePicture200Response>>;
    public coreUserUpdatePicture(coreUserUpdatePictureRequest: CoreUserUpdatePictureRequest, ): Observable<any> {

        if (coreUserUpdatePictureRequest === null || coreUserUpdatePictureRequest === undefined) {
            throw new Error('Required parameter coreUserUpdatePictureRequest was null or undefined when calling coreUserUpdatePicture.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserUpdatePicture200Response>(`${this.basePath}/core_user_update_picture`,
            coreUserUpdatePictureRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Store mobile user public key.
     * Store mobile user public key.
     * @param coreUserUpdateUserDevicePublicKeyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserUpdateUserDevicePublicKey(coreUserUpdateUserDevicePublicKeyRequest: CoreUserUpdateUserDevicePublicKeyRequest, ): Observable<AxiosResponse<CoreUserUpdateUserDevicePublicKey200Response>>;
    public coreUserUpdateUserDevicePublicKey(coreUserUpdateUserDevicePublicKeyRequest: CoreUserUpdateUserDevicePublicKeyRequest, ): Observable<any> {

        if (coreUserUpdateUserDevicePublicKeyRequest === null || coreUserUpdateUserDevicePublicKeyRequest === undefined) {
            throw new Error('Required parameter coreUserUpdateUserDevicePublicKeyRequest was null or undefined when calling coreUserUpdateUserDevicePublicKey.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreUserUpdateUserDevicePublicKey200Response>(`${this.basePath}/core_user_update_user_device_public_key`,
            coreUserUpdateUserDevicePublicKeyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update a user\&#39;s preferences
     * Update a user\&#39;s preferences
     * @param coreUserUpdateUserPreferencesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserUpdateUserPreferences(coreUserUpdateUserPreferencesRequest: CoreUserUpdateUserPreferencesRequest, ): Observable<AxiosResponse<object>>;
    public coreUserUpdateUserPreferences(coreUserUpdateUserPreferencesRequest: CoreUserUpdateUserPreferencesRequest, ): Observable<any> {

        if (coreUserUpdateUserPreferencesRequest === null || coreUserUpdateUserPreferencesRequest === undefined) {
            throw new Error('Required parameter coreUserUpdateUserPreferencesRequest was null or undefined when calling coreUserUpdateUserPreferences.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_user_update_user_preferences`,
            coreUserUpdateUserPreferencesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Update users.
     * Update users.
     * @param coreUserUpdateUsersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserUpdateUsers(coreUserUpdateUsersRequest: CoreUserUpdateUsersRequest, ): Observable<AxiosResponse<CoreCohortAddCohortMembers200Response>>;
    public coreUserUpdateUsers(coreUserUpdateUsersRequest: CoreUserUpdateUsersRequest, ): Observable<any> {

        if (coreUserUpdateUsersRequest === null || coreUserUpdateUsersRequest === undefined) {
            throw new Error('Required parameter coreUserUpdateUsersRequest was null or undefined when calling coreUserUpdateUsers.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCohortAddCohortMembers200Response>(`${this.basePath}/core_user_update_users`,
            coreUserUpdateUsersRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Simulates the web-interface view of user/index.php (triggering events),.
     * Simulates the web-interface view of user/index.php (triggering events),.
     * @param coreUserViewUserListRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserViewUserList(coreUserViewUserListRequest: CoreUserViewUserListRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreUserViewUserList(coreUserViewUserListRequest: CoreUserViewUserListRequest, ): Observable<any> {

        if (coreUserViewUserListRequest === null || coreUserViewUserListRequest === undefined) {
            throw new Error('Required parameter coreUserViewUserListRequest was null or undefined when calling coreUserViewUserList.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_user_view_user_list`,
            coreUserViewUserListRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Simulates the web-interface view of user/view.php and user/profile.php (triggering events),.
     * Simulates the web-interface view of user/view.php and user/profile.php (triggering events),.
     * @param coreUserViewUserProfileRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreUserViewUserProfile(coreUserViewUserProfileRequest: CoreUserViewUserProfileRequest, ): Observable<AxiosResponse<CoreCalendarDeleteSubscription200Response>>;
    public coreUserViewUserProfile(coreUserViewUserProfileRequest: CoreUserViewUserProfileRequest, ): Observable<any> {

        if (coreUserViewUserProfileRequest === null || coreUserViewUserProfileRequest === undefined) {
            throw new Error('Required parameter coreUserViewUserProfileRequest was null or undefined when calling coreUserViewUserProfile.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreCalendarDeleteSubscription200Response>(`${this.basePath}/core_user_view_user_profile`,
            coreUserViewUserProfileRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Return some site info / user info / list web service functions
     * Return some site info / user info / list web service functions
     * @param coreWebserviceGetSiteInfoRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreWebserviceGetSiteInfo(coreWebserviceGetSiteInfoRequest: CoreWebserviceGetSiteInfoRequest, ): Observable<AxiosResponse<CoreWebserviceGetSiteInfo200Response>>;
    public coreWebserviceGetSiteInfo(coreWebserviceGetSiteInfoRequest: CoreWebserviceGetSiteInfoRequest, ): Observable<any> {

        if (coreWebserviceGetSiteInfoRequest === null || coreWebserviceGetSiteInfoRequest === undefined) {
            throw new Error('Required parameter coreWebserviceGetSiteInfoRequest was null or undefined when calling coreWebserviceGetSiteInfo.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<CoreWebserviceGetSiteInfo200Response>(`${this.basePath}/core_webservice_get_site_info`,
            coreWebserviceGetSiteInfoRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete an xAPI state data from an activityId.
     * Delete an xAPI state data from an activityId.
     * @param coreXapiDeleteStateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiDeleteState(coreXapiDeleteStateRequest: CoreXapiDeleteStateRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiDeleteState(coreXapiDeleteStateRequest: CoreXapiDeleteStateRequest, ): Observable<any> {

        if (coreXapiDeleteStateRequest === null || coreXapiDeleteStateRequest === undefined) {
            throw new Error('Required parameter coreXapiDeleteStateRequest was null or undefined when calling coreXapiDeleteState.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_delete_state`,
            coreXapiDeleteStateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Delete all xAPI state data from an activityId.
     * Delete all xAPI state data from an activityId.
     * @param coreXapiDeleteStatesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiDeleteStates(coreXapiDeleteStatesRequest: CoreXapiDeleteStatesRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiDeleteStates(coreXapiDeleteStatesRequest: CoreXapiDeleteStatesRequest, ): Observable<any> {

        if (coreXapiDeleteStatesRequest === null || coreXapiDeleteStatesRequest === undefined) {
            throw new Error('Required parameter coreXapiDeleteStatesRequest was null or undefined when calling coreXapiDeleteStates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_delete_states`,
            coreXapiDeleteStatesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get an xAPI state data from an activityId.
     * Get an xAPI state data from an activityId.
     * @param coreXapiGetStateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiGetState(coreXapiGetStateRequest: CoreXapiGetStateRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiGetState(coreXapiGetStateRequest: CoreXapiGetStateRequest, ): Observable<any> {

        if (coreXapiGetStateRequest === null || coreXapiGetStateRequest === undefined) {
            throw new Error('Required parameter coreXapiGetStateRequest was null or undefined when calling coreXapiGetState.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_get_state`,
            coreXapiGetStateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Get all state ID from an activityId.
     * Get all state ID from an activityId.
     * @param coreXapiGetStatesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiGetStates(coreXapiGetStatesRequest: CoreXapiGetStatesRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiGetStates(coreXapiGetStatesRequest: CoreXapiGetStatesRequest, ): Observable<any> {

        if (coreXapiGetStatesRequest === null || coreXapiGetStatesRequest === undefined) {
            throw new Error('Required parameter coreXapiGetStatesRequest was null or undefined when calling coreXapiGetStates.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_get_states`,
            coreXapiGetStatesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Post an xAPI state into an activityId.
     * Post an xAPI state into an activityId.
     * @param coreXapiPostStateRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiPostState(coreXapiPostStateRequest: CoreXapiPostStateRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiPostState(coreXapiPostStateRequest: CoreXapiPostStateRequest, ): Observable<any> {

        if (coreXapiPostStateRequest === null || coreXapiPostStateRequest === undefined) {
            throw new Error('Required parameter coreXapiPostStateRequest was null or undefined when calling coreXapiPostState.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_post_state`,
            coreXapiPostStateRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
    /**
     * Post an xAPI statement.
     * Post an xAPI statement.
     * @param coreXapiStatementPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coreXapiStatementPost(coreXapiStatementPostRequest: CoreXapiStatementPostRequest, ): Observable<AxiosResponse<object>>;
    public coreXapiStatementPost(coreXapiStatementPostRequest: CoreXapiStatementPostRequest, ): Observable<any> {

        if (coreXapiStatementPostRequest === null || coreXapiStatementPostRequest === undefined) {
            throw new Error('Required parameter coreXapiStatementPostRequest was null or undefined when calling coreXapiStatementPost.');
        }

        let headers = {...this.defaultHeaders};

        // authentication (apiKey) required
        if (this.configuration.apiKeys?.["Authorization"]) {
            headers['Authorization'] = this.configuration.apiKeys["Authorization"];
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return this.httpClient.post<object>(`${this.basePath}/core_xapi_statement_post`,
            coreXapiStatementPostRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        );
    }
}
